[{"example":"(dyn 'defn)\u000D\u000A# => @{:source-map (\"boot.janet\" 12 1) :value <function defn> :doc \"(defn name & more)\\n\\nDefine a function. Equivalent to (def name (fn name [args] ...)).\" :macro true}\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (dyn key &opt default)\\n    \\n    Get a dynamic binding. Returns the default value (or nil) if no\\n    binding found.\\n\\n\\n\"","gh-username":"sogaiu","name":"dyn","created-at":1608465320},{"example":"(dyn :pretty-format)\u000D\u000A# => \"%.20Q\"","docstring":"\"\\n\\n    cfunction\\n\\n    (dyn key &opt default)\\n    \\n    Get a dynamic binding. Returns the default value (or nil) if no\\n    binding found.\\n\\n\\n\"","gh-username":"sogaiu","name":"dyn","created-at":1608465247},{"example":"(varglobal \"smile\" false)\u000D\u000A# => nil\u000D\u000A\u000D\u000Asmile\u000D\u000A# => false\u000D\u000A\u000D\u000A(set smile true)\u000D\u000A# => smile\u000D\u000A\u000D\u000Asmile\u000D\u000A# => true\u000D\u000A\u000D\u000A(dyn 'smile)\u000D\u000A# => @{:ref @[true]}\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 75, column 1\\n\\n    (varglobal name init)\\n    \\n    Dynamically create a global var.\\n\\n\\n\"","gh-username":"sogaiu","name":"varglobal","created-at":1608465209},{"example":"(some odd? [2 4 6 8 10])\u000D\u000A# => nil\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1866, column 1\\n\\n    (some pred xs)\\n    \\n    Returns nil if all xs are false or nil, otherwise returns the result\\n    of the first truthy predicate, (pred x).\\n\\n\\n\"","gh-username":"sogaiu","name":"some","created-at":1608446999},{"example":"(some even? [1 3 5 7 11 18])\u000D\u000A# => true\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1866, column 1\\n\\n    (some pred xs)\\n    \\n    Returns nil if all xs are false or nil, otherwise returns the result\\n    of the first truthy predicate, (pred x).\\n\\n\\n\"","gh-username":"sogaiu","name":"some","created-at":1608446988},{"example":"(let [tbl @{:a 1}]\u000D\u000A  (merge-into tbl {:b 2})\u000D\u000A  tbl)\u000D\u000A# => @{:a 1 :b 2}\u000D\u000A\u000D\u000A# real-world example: https://git.sr.ht/~subsetpark/bagatto/tree/19aea03fe23fe5486890912df7dc4a936ce617a3/item/main.janet#L23\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1350, column 1\\n\\n    (merge-into tab & colls)\\n    \\n    Merges multiple tables/structs into a table. If a key appears in more\\n    than one collection, then later values replace any previous ones.\\n    Returns the original table.\\n\\n\\n\"","gh-username":"sogaiu","name":"merge-into","created-at":1608446902},{"example":"(string/find \"a\" \"abcdefa\" 1)\u000D\u000A# not yet documented start ^ position\u000D\u000A# => 6","docstring":"\"\\n\\n    cfunction\\n\\n    (string/find patt str)\\n    \\n    Searches for the first instance of pattern patt in string str. Returns\\n    the index of the first character in patt if found, otherwise returns\\n    nil.\\n\\n\\n\"","gh-username":"pepe","name":"string/find","created-at":1608195642},{"example":"(merge {:a 1 :b 2} \u000D\u000A       {:c 3 :a 4})\u000D\u000A# -> @{:c 3 :a 4 :b 2}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1360, column 1\\n\\n    (merge & colls)\\n    \\n    Merges multiple tables/structs to one. If a key appears in more than\\n    one collection, then later values replace any previous ones. Returns a\\n    new table.\\n\\n\\n\"","gh-username":"Krasjet","name":"merge","created-at":1607918243},{"example":"# excess elements of the longer list are discarded\u000D\u000A(interleave [1] \u000D\u000A            [2 4] \u000D\u000A            [3 6])\u000D\u000A# -> @[1 2 3]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1410, column 1\\n\\n    (interleave & cols)\\n    \\n    Returns an array of the first elements of each col, then the second,\\n    etc.\\n\\n\\n\"","gh-username":"Krasjet","name":"interleave","created-at":1607915842},{"example":"(interpose 0 [1])\u000D\u000A# -> @[1]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1455, column 1\\n\\n    (interpose sep ind)\\n    \\n    Returns a sequence of the elements of ind separated by sep. Returns a\\n    new array.\\n\\n\\n\"","gh-username":"Krasjet","name":"interpose","created-at":1607915157},{"example":"(interpose 0 [1 2 3])\u000D\u000A# -> @[1 0 2 0 3]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1455, column 1\\n\\n    (interpose sep ind)\\n    \\n    Returns a sequence of the elements of ind separated by sep. Returns a\\n    new array.\\n\\n\\n\"","gh-username":"Krasjet","name":"interpose","created-at":1607915147},{"example":"(when-let [root   (math/sqrt 64) \u000D\u000A           unused (even? root)] \u000D\u000A         (printf \"%d is even\" root))\u000D\u000A# -> \"8 is even\"","docstring":"\"\\n\\n    macro\\n    boot.janet on line 646, column 1\\n\\n    (when-let bindings & body)\\n    \\n    Same as (if-let bindings (do ;body)).\\n\\n\\n\"","gh-username":"felixr","name":"when-let","created-at":1607878438},{"example":"In order to use :fresh, write:\u000D\u000A(import path :fresh true)","docstring":"\"\\n\\n    macro\\n    boot.janet on line 2473, column 1\\n\\n    (import path & args)\\n    \\n    Import a module. First requires the module, and then merges its\\n    symbols into the current environment, prepending a given prefix as\\n    needed. (use the :as or :prefix option to set a prefix). If no prefix\\n    is provided, use the name of the module as a prefix. One can also use\\n    :export true to re-export the imported symbols. If :exit true is given\\n    as an argument, any errors encountered at the top level in the module\\n    will cause (os/exit 1) to be called. Dynamic bindings will NOT be\\n    imported. Use :fresh to bypass the module cache.\\n\\n\\n\"","gh-username":"Saikyun","name":"import","created-at":1607805776},{"example":"(as-> [1 2 3] _ \u000D\u000A  (map inc _)\u000D\u000A  (sum _)\u000D\u000A  (- _ 10)\u000D\u000A  (< _ 0))\u000D\u000A# -> true\u000D\u000A\u000D\u000A# same as\u000D\u000A(< (- (sum (map inc [1 2 3])) 10) 0)","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1161, column 1\\n\\n    (as-> x as & forms)\\n    \\n    Thread forms together, replacing as in forms with the value of the\\n    previous form. The first for is the value x. Returns the last value.\\n\\n\\n\"","gh-username":"felixr","name":"as->","created-at":1607791510},{"example":"(->\u000D\u000A  {:a [1 2 3] :b [4 5 6]}\u000D\u000A  (get :a)\u000D\u000A  (sum)\u000D\u000A  (string \" is the result\"))\u000D\u000A# -> \"6 is the result\"\u000D\u000A\u000D\u000A# same as:\u000D\u000A(string (sum (get {:a [1 2 3] :b [4 5 6]} :a))\" is the result\")\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1064, column 1\\n\\n    (-> x & forms)\\n    \\n    Threading macro. Inserts x as the second value in the first form in\\n    forms, and inserts the modified first form into the second form in the\\n    same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"felixr","name":"->","created-at":1607791027},{"example":"(->> \u000D\u000A  (string/split \" \" \"this  is an  example yes, an example\")\u000D\u000A  (filter (complement empty?))\u000D\u000A  (frequencies))\u000D\u000A# -> @{\"is\" 1 \"example\" 2 \"yes,\" 1 \"an\" 2 \"this\" 1}\u000D\u000A\u000D\u000A# same as:\u000D\u000A(frequencies\u000D\u000A  (filter\u000D\u000A    (complement empty?)\u000D\u000A    (string/split \" \" \"this  is an  example yes, an example\")))","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1077, column 1\\n\\n    (->> x & forms)\\n    \\n    Threading macro. Inserts x as the last value in the first form in\\n    forms, and inserts the modified first form into the second form in the\\n    same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"felixr","name":"->>","created-at":1607790691},{"example":"# see https://janet-lang.org/docs/abstract_machine.html\u000D\u000A\u000D\u000A(def plus10\u000D\u000A (asm \u000D\u000A   '{\u000D\u000A     :arity 1\u000D\u000A     :bytecode @[(ldi 1 10)    # $1 = 10\u000D\u000A                 (add 2 0 1)   # $2 = $0 + $1\u000D\u000A                 (ret 2)]}))   # return $2\u000D\u000A\u000D\u000A(plus10 1) # -> 11","docstring":"\"\\n\\n    cfunction\\n\\n    (asm assembly)\\n    \\n    Returns a new function that is the compiled result of the assembly.\\n    The syntax for the assembly can be found on the Janet website, and\\n    should correspond\\n    to the return value of disasm. Will throw an\\n    error on invalid assembly.\\n\\n\\n\"","gh-username":"felixr","name":"asm","created-at":1607782267},{"example":"(sort @[5 4 1 3 2])   # -> @[1 2 3 4 5]\u000D\u000A(sort @[5 4 1 3 2] >) # -> @[5 4 3 2 1]","docstring":"\"\\n\\n    function\\n    boot.janet on line 787, column 1\\n\\n    (sort a &opt by)\\n    \\n    Sort an array in-place. Uses quick-sort and is not a stable sort.\\n\\n\\n\"","gh-username":"felixr","name":"sort","created-at":1607779529},{"example":"(sort-by\u000D\u000A  (fn [x] (get x :b)\u000D\u000A   @[{:a 1 :b 100} {:a 100 :b 1} {:a -1 :b 50}])\u000D\u000A\u000D\u000A# -> @[{:a 100 :b 1} {:a -1 :b 50} {:a 1 :b 100}]","docstring":"\"\\n\\n    function\\n    boot.janet on line 795, column 1\\n\\n    (sort-by f ind)\\n    \\n    Returns a new sorted array that compares elements by invoking a\\n    function on each element and comparing the result with <.\\n\\n\\n\"","gh-username":"felixr","name":"sort-by","created-at":1607779386},{"example":"(def person-ids {\"Alice\" 42 \"Bob\" 23})\u000D\u000A\u000D\u000A(keep person-ids [\"Carl\" \"Bob\" \"Alice\"])   # -> @[23 42]\u000D\u000A\u000D\u000A(filter person-ids [\"Carl\" \"Bob\" \"Alice\"]) # -> @[\"Bob\" \"Alice\"]\u000D\u000A(map person-ids [\"Carl\" \"Bob\" \"Alice\"])    # -> @[nil 23 42]","docstring":"\"\\n\\n    function\\n    boot.janet on line 911, column 1\\n\\n    (keep pred ind)\\n    \\n    Given a predicate, take only elements from an array or tuple for which\\n    (pred element) is truthy. Returns a new array of truthy predicate\\n    results.\\n\\n\\n\"","gh-username":"felixr","name":"keep","created-at":1607778417},{"example":"(def record @{:recipient @{:name \"Bob\" :age 60} :sender @{:name \"Alice\" :age 21}})\u000D\u000A\u000D\u000A(put-in\u000D\u000A  record\u000D\u000A  [:sender :age] \u000D\u000A  26)\u000D\u000A\u000D\u000A# @{:recipient @{:name \"Bob\" :age 60} :sender @{:name \"Alice\" :age 26}}\u000D\u000A\u000D\u000A(put-in\u000D\u000A  record\u000D\u000A  [:recipient] \u000D\u000A  @{:name \"Carl\"})\u000D\u000A\u000D\u000A# @{:recipient @{:name \"Carl\"} :sender @{:name \"Alice\" :age 26}}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1320, column 1\\n\\n    (put-in ds ks v)\\n    \\n    Put a value into a nested data structure. Looks into the data\\n    structure via a sequence of keys. Missing data structures will be\\n    replaced with tables. Returns the modified, original data structure.\\n\\n\\n\"","gh-username":"felixr","name":"put-in","created-at":1607617429},{"example":"(print\u000D\u000A  (prompt :a \u000D\u000A          (for i 0 1000000000000 \u000D\u000A            (print (string \"i=\" i))\u000D\u000A            (if (= i 2) \u000D\u000A                (return :a 10)))))\u000D\u000A# output:\u000D\u000A# i=0\u000D\u000A# i=1\u000D\u000A# i=2\u000D\u000A# 10","docstring":"\"\\n\\n    function\\n    boot.janet on line 349, column 1\\n\\n    (return to &opt value)\\n    \\n    Return to a prompt point.\\n\\n\\n\"","gh-username":"felixr","name":"return","created-at":1607507080},{"example":"(print\u000D\u000A  (prompt :a \u000D\u000A          (for i 0 1000000000000 \u000D\u000A            (print (string \"i=\" i))\u000D\u000A            (if (= i 2) \u000D\u000A                (return :a 10)))))\u000D\u000A# output:\u000D\u000A# i=0\u000D\u000A# i=1\u000D\u000A# i=2\u000D\u000A# 10","docstring":"\"\\n\\n    macro\\n    boot.janet on line 321, column 1\\n\\n    (prompt tag & body)\\n    \\n    Set up a checkpoint that can be returned to. Tag should be a value\\n    that is used in a return statement, like a keyword.\\n\\n\\n\"","gh-username":"felixr","name":"prompt","created-at":1607507029},{"example":"(describe @[:a :b]) # => \"<array 0x55EC375CF440>\"","docstring":"\"\\n\\n    cfunction\\n\\n    (describe x)\\n    \\n    Returns a string that is a human readable description of a value x.\\n\\n\\n\"","gh-username":"sogaiu","name":"describe","created-at":1607381162},{"example":"(describe {:a 1}) # => \"<struct 0x5564AF1BD6C0>\"","docstring":"\"\\n\\n    cfunction\\n\\n    (describe x)\\n    \\n    Returns a string that is a human readable description of a value x.\\n\\n\\n\"","gh-username":"sogaiu","name":"describe","created-at":1607381063},{"example":"### read a file line by line ###\u000D\u000A\u000D\u000A(let [f (file/open \"filename.txt\")] # bind an open file handle to \"f\"\u000D\u000A  (while true                       # loop until \"break\" is called\u000D\u000A    (let [l (file/read f :line)]    # bind a line of the file to \"l\" \u000D\u000A      (if l                         \u000D\u000A\u0009(print l)                   # if l is truthy print l\u000D\u000A\u0009(break))))                  # if l is not break from loop\u000D\u000A  (file/close f))                   # close the file handle \u000D\u000A\u000D\u000A\u000D\u000A# same as above but using \"with\"\u000D\u000A# this means there's no need to \u000D\u000A# call file/close, also replace\u000D\u000A# let with var\u000D\u000A(with [f (file/open \"filename.txt\")]\u000D\u000A      (while true\u000D\u000A\u0009(var l (file/read f :line))\u000D\u000A\u0009(if l\u000D\u000A\u0009  (print l)\u000D\u000A\u0009  (break))))","docstring":"\"\\n\\n    cfunction\\n\\n    (file/read f what &opt buf)\\n    \\n    Read a number of bytes from a file into a buffer. A buffer can be\\n    provided as an optional fourth argument, otherwise a new buffer is\\n    created. 'what' can either be an integer or a keyword. Returns the\\n    buffer with file contents. Values for 'what':\\n    \\n      :all - read the whole file\\n      :line - read up to and including the next newline character\\n      n (integer) - read up to n bytes from the file\\n\\n\\n\"","gh-username":"yvan","name":"file/read","created-at":1607108623},{"example":"(defn test\u000D\u000A  [x]\u000D\u000A  (cond\u000D\u000A    (> x 10) \"Pretty big!\"\u000D\u000A    (< x 5) \"Quite small\"\u000D\u000A    \"Medium size\"))\u000D\u000A\u000D\u000A(test 40) # => \"Pretty big!\"\u000D\u000A(test 2) # => \"Quite small\"\u000D\u000A(test 6) # => \"Medium size\"","docstring":"\"\\n\\n    macro\\n    boot.janet on line 172, column 1\\n\\n    (cond & pairs)\\n    \\n    Evaluates conditions sequentially until the first true condition is\\n    found, and then executes the corresponding body. If there are an odd\\n    number of forms, the last expression is executed if no forms are\\n    matched. If there are no matches, return nil.\\n\\n\\n\"","gh-username":"pingiun","name":"cond","created-at":1606658964},{"example":"(reduce (fn [s1 s2]\u000D\u000A          (string \"[\" s1 \"+\" s2 \"]\"))\u000D\u000A        \"x\"\u000D\u000A        [\"a\" \"b\" \"c\"])\u000D\u000A\u000D\u000A#=> \"[[[x+a]+b]+c]\"\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 812, column 1\\n\\n    (reduce f init ind)\\n    \\n    Reduce, also know as fold-left in many languages, transforms an\\n    indexed type (array, tuple) with a function to produce a value.\\n\\n\\n\"","gh-username":"uvtc","name":"reduce","created-at":1606332118},{"example":"(filter (fn [x] (> x 2)) [1 2 3 4 5])  # @[3 4 5]","docstring":"\"\\n\\n    function\\n    boot.janet on line 891, column 1\\n\\n    (filter pred ind)\\n    \\n    Given a predicate, take only elements from an array or tuple for which\\n    (pred element) is truthy. Returns a new array.\\n\\n\\n\"","gh-username":"btbytes","name":"filter","created-at":1606239416},{"example":"(os/lstat \"t.janet\")\u000D\u000A# @{:size 249 :permissions \"rw-r--r--\" :nlink 1 :blocks 8 :dev 16777221 :accessed 1606236760 :modified 1606236759 :uid 501 :mode :file :blocksize 4096 :changed 1606236759 :inode 14801850 :rdev 0 :int-permissions 420 :gid 501}\u000D\u000A\u000D\u000A(get (os/lstat \"t.janet\") :size)  # 249","docstring":"\"\\n\\n    cfunction\\n\\n    (os/lstat path &opt tab|key)\\n    \\n    Like os/stat, but don't follow symlinks.\\n    \\n\\n\\n\"","gh-username":"btbytes","name":"os/lstat","created-at":1606239175},{"example":"(do\u000D\u000A  (var a 88)\u000D\u000A  (+= a 12))  # 100\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 131, column 1\\n\\n    (+= x n)\\n    \\n    Increments the var x by n.\\n\\n\\n\"","gh-username":"btbytes","name":"+=","created-at":1606207234},{"example":"(print (doc-format \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\" 30))\u000D\u000A\u000D\u000A    Lorem ipsum dolor\u000D\u000A    sit amet, consectetur\u000D\u000A    adipiscing elit, sed\u000D\u000A    do eiusmod tempor\u000D\u000A    incididunt ut labore\u000D\u000A    et dolore magna\u000D\u000A    aliqua. Ut enim ad\u000D\u000A    minim veniam, quis\u000D\u000A    nostrud exercitation\u000D\u000A    ullamco laboris nisi\u000D\u000A    ut aliquip ex ea\u000D\u000A    commodo consequat.\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1658, column 1\\n\\n    (doc-format text &opt width)\\n    \\n    Reformat text to wrap at a given line.\\n\\n\\n\"","gh-username":"btbytes","name":"doc-format","created-at":1606207006},{"example":"(mod 13 5)  # 3","docstring":"\"\\n\\n    function\\n\\n    (mod dividend divisor)\\n    \\n    Returns the modulo of dividend / divisor.\\n\\n\\n\"","gh-username":"btbytes","name":"mod","created-at":1606206533},{"example":"(math/random)  # 0.487181","docstring":"\"\\n\\n    cfunction\\n\\n    (math/random)\\n    \\n    Returns a uniformly distributed random number between 0 and 1.\\n\\n\\n\"","gh-username":"btbytes","name":"math/random","created-at":1606206452},{"example":"(sorted [1 -2 2 3 9 -10])  # @[-10 -2 1 2 3 9]","docstring":"\"\\n\\n    function\\n    boot.janet on line 801, column 1\\n\\n    (sorted ind &opt by)\\n    \\n    Returns a new sorted array without modifying the old one.\\n\\n\\n\"","gh-username":"btbytes","name":"sorted","created-at":1606206312},{"example":"(take 2 [1 -2 2 3 9 -10])  # (1 -2)","docstring":"\"\\n\\n    function\\n    boot.janet on line 976, column 1\\n\\n    (take n ind)\\n    \\n    Take first n elements in an indexed type. Returns new indexed\\n    instance.\\n\\n\\n\"","gh-username":"btbytes","name":"take","created-at":1606206194},{"example":"(math/atan 1)    # 0.785398\u000D\u000A(math/atan 0.5)  # 0.463648","docstring":"\"\\n\\n    cfunction\\n\\n    (math/atan x)\\n    \\n    Returns the arctangent of x.\\n\\n\\n\"","gh-username":"btbytes","name":"math/atan","created-at":1606205699},{"example":"# catch and propagate an error with fiber\u000D\u000A\u000D\u000A(try\u000D\u000A  (+ 1 nil)\u000D\u000A  ([err fib]\u000D\u000A   (propagate err fib)))","docstring":"\"\\n\\n    macro\\n    boot.janet on line 223, column 1\\n\\n    (try body catch)\\n    \\n    Try something and catch errors. Body is any expression, and catch\\n    should be a form with the first element a tuple. This tuple should\\n    contain a binding for errors and an optional binding for the fiber\\n    wrapping the body. Returns the result of body if no error, or the\\n    result of catch if an error.\\n\\n\\n\"","gh-username":"swlkr","name":"try","created-at":1605556163},{"example":"(compare> 1 0) # => true\u000D\u000A(compare> 10 9.9) # => true\u000D\u000A(compare> :a :b) # => false\u000D\u000A(compare> :b :a) # => true","docstring":"\"\\n\\n    function\\n    boot.janet on line 741, column 1\\n\\n    (compare> & xs)\\n    \\n    Equivalent of '>' but using compare function instead of primitive\\n    comparator\\n\\n\\n\"","gh-username":"swlkr","name":"compare>","created-at":1604702708},{"example":"(defn read-from-file [file-path]\u000D\u000A  (let [f (file/open file-path :r)\u000D\u000A        content  (file/read f :all)]\u000D\u000A    (file/close f)\u000D\u000A    content))\u000D\u000A\u000D\u000A### USAGE \u000D\u000A\u000D\u000A(read-from-file \"/path/to/file-read-example.janet\")\u000D\u000A# => @\"(defn read-from-file [file-path]\\n  (let [f (file/open file-path :r)\\n        content  (file/read f :all)]\\n    (file/close f)\\n    content))\\n\"","docstring":"\"\\n\\n    cfunction\\n\\n    (file/read f what &opt buf)\\n    \\n    Read a number of bytes from a file into a buffer. A buffer can be\\n    provided as an optional fourth argument, otherwise a new buffer is\\n    created. 'what' can either be an integer or a keyword. Returns the\\n    buffer with file contents. Values for 'what':\\n    \\n      :all - read the whole file\\n      :line - read up to and including the next newline character\\n      n (integer) - read up to n bytes from the file\\n\\n\\n\"","gh-username":"harryvederci","name":"file/read","created-at":1603558237},{"example":"(defn to-double-digit-string [digit]\u000D\u000A  (string/slice (string \"0\" digit) -3))\u000D\u000A\u000D\u000A(defn get-date-time-string [time]\u000D\u000A  (let [date (os/date time)\u000D\u000A        year (get date :year)\u000D\u000A        month (to-double-digit-string (get date :month))\u000D\u000A        day (to-double-digit-string (get date :month-day))\u000D\u000A        hours (to-double-digit-string (get date :hours))\u000D\u000A        minutes (to-double-digit-string (get date :minutes))\u000D\u000A        seconds (to-double-digit-string (get date :seconds))]\u000D\u000A    (string year \"-\" month \"-\" day \"__\" hours \":\" minutes \":\" seconds)))\u000D\u000A\u000D\u000A(defn get-current-date-time-string []\u000D\u000A  (get-date-time-string (os/time)))\u000D\u000A\u000D\u000A\u000D\u000A### USAGE\u000D\u000A\u000D\u000A(get-current-date-time-string)\u000D\u000A# => \"2020-09-23__17:20:00\"","docstring":"\"\\n\\n    cfunction\\n\\n    (os/date &opt time local)\\n    \\n    Returns the given time as a date struct, or the current time if no\\n    time is given. Returns a struct with following key values. Note that\\n    all numbers are 0-indexed. Date is given in UTC unless local is truthy,\\n    in which case the date is formatted for the local timezone.\\n    \\n      :seconds - number of seconds [0-61]\\n      :minutes - number of minutes [0-59]\\n      :hours - number of hours [0-23]\\n      :month-day - day of month [0-30]\\n      :month - month of year [0, 11]\\n      :year - years since year 0 (e.g. 2019)\\n      :week-day - day of the week [0-6]\\n      :year-day - day of the year [0-365]\\n      :dst - If Day Light Savings is in effect\\n\\n\\n\"","gh-username":"harryvederci","name":"os/date","created-at":1603557001},{"example":"# opens a file named filename for writing, and writes Hello World!\u000D\u000A(def f (file/open \"filename\" :w))\u000D\u000A(file/write f \"Hello World!\")\u000D\u000A(file/flush f)\u000D\u000A(file/close f)","docstring":"\"\\n\\n    cfunction\\n\\n    (file/write f bytes)\\n    \\n    Writes to a file. 'bytes' must be string, buffer, or symbol. Returns\\n    the file.\\n\\n\\n\"","gh-username":"terminalcommand","name":"file/write","created-at":1602881414},{"example":"(comment this is a\u000D\u000A         multiline line comment.\u000D\u000A         It won't do anything)","docstring":"\"\\n\\n    macro\\n    boot.janet on line 153, column 1\\n\\n    (comment &)\\n    \\n    Ignores the body of the comment.\\n\\n\\n\"","gh-username":"oz123","name":"comment","created-at":1602610011},{"example":"(defn ddup [ds ks val]\u000D\u000A  (update-in ds ks\u000D\u000A    (fn [x]\u000D\u000A      (if (= nil x)\u000D\u000A        @[val]\u000D\u000A        (array/push x val)))))\u000D\u000A\u000D\u000A(var a @{})\u000D\u000A(ddup a [:a] 1)\u000D\u000A(ddup a [:a] 2)\u000D\u000A(ddup a [:a] 3)\u000D\u000A# @{:a @[1 2 3]}\u000D\u000A\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1298, column 1\\n\\n    (update-in ds ks f & args)\\n    \\n    Update a value in a nested data structure by applying f to the current\\n    value. Looks into the data structure via a sequence of keys. Missing\\n    data structures will be replaced with tables. Returns the modified,\\n    original data structure.\\n\\n\\n\"","gh-username":"sbjaver","name":"update-in","created-at":1602463691},{"example":"(update-in @{:a @{:b 1}} [:a :b] (fn [x] (+ 1 x)))\u000D\u000A# @{:a @{:b 2}}\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1298, column 1\\n\\n    (update-in ds ks f & args)\\n    \\n    Update a value in a nested data structure by applying f to the current\\n    value. Looks into the data structure via a sequence of keys. Missing\\n    data structures will be replaced with tables. Returns the modified,\\n    original data structure.\\n\\n\\n\"","gh-username":"sbjaver","name":"update-in","created-at":1602463612},{"example":"(update-in @{:a 1} [:a] (fn [x] (+ 1 x)))\u000D\u000A# @{:a 2}\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1298, column 1\\n\\n    (update-in ds ks f & args)\\n    \\n    Update a value in a nested data structure by applying f to the current\\n    value. Looks into the data structure via a sequence of keys. Missing\\n    data structures will be replaced with tables. Returns the modified,\\n    original data structure.\\n\\n\\n\"","gh-username":"sbjaver","name":"update-in","created-at":1602463581},{"example":"(eval-string \"(+ 1 2 3 4)\") # -> 10\u000D\u000A(eval-string \")\") # -> parse error\u000D\u000A(eval-string \"(bloop)\") # -> compile error\u000D\u000A(eval-string \"(+ nil nil)\") # -> runtime error","docstring":"\"\\n\\n    function\\n    boot.janet on line 2198, column 1\\n\\n    (eval-string str)\\n    \\n    Evaluates a string in the current environment. If more control over\\n    the environment is needed, use run-context.\\n\\n\\n\"","gh-username":"swlkr","name":"eval-string","created-at":1602038987},{"example":"(if-let [x true \u000D\u000A         y (not (not x))]\u000D\u000A  :a\u000D\u000A  :b)\u000D\u000A# => :a\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 615, column 1\\n\\n    (if-let bindings tru &opt fal)\\n    \\n    Make multiple bindings, and if all are truthy, evaluate the tru form.\\n    If any are false or nil, evaluate the fal form. Bindings have the same\\n    syntax as the let macro.\\n\\n\\n\"","gh-username":"sogaiu","name":"if-let","created-at":1601013276},{"example":"(if-let [x true \u000D\u000A         y (not x)]\u000D\u000A  :a\u000D\u000A  :b)\u000D\u000A# => :b\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 615, column 1\\n\\n    (if-let bindings tru &opt fal)\\n    \\n    Make multiple bindings, and if all are truthy, evaluate the tru form.\\n    If any are false or nil, evaluate the fal form. Bindings have the same\\n    syntax as the let macro.\\n\\n\\n\"","gh-username":"sogaiu","name":"if-let","created-at":1601013237},{"example":"(partition 2 [:a 1 :b 2 :c 3])\u000D\u000A# => @[(:a 1) (:b 2) (:c 3)]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1468, column 1\\n\\n    (partition n ind)\\n    \\n    Partition an indexed data structure into tuples of size n. Returns a\\n    new array.\\n\\n\\n\"","gh-username":"sogaiu","name":"partition","created-at":1601013032},{"example":"(interleave [:a :b :c] \u000D\u000A            [1 2 3] \u000D\u000A            [\"x\" \"y\" \"z\"])\u000D\u000A# => @[:a 1 \"x\" :b 2 \"y\" :c 3 \"z\"]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1410, column 1\\n\\n    (interleave & cols)\\n    \\n    Returns an array of the first elements of each col, then the second,\\n    etc.\\n\\n\\n\"","gh-username":"sogaiu","name":"interleave","created-at":1601012972},{"example":"(invert {:a 1 :b 2 :c 3})\u000D\u000A# => @{3 :c 1 :a 2 :b}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1265, column 1\\n\\n    (invert ds)\\n    \\n    Returns a table where the keys of an associative data structure are\\n    the values, and the values of the keys. If multiple keys have the same\\n    value, one key will be ignored.\\n\\n\\n\"","gh-username":"sogaiu","name":"invert","created-at":1601011392},{"example":"(eachk [k v] {:a \"a val\" :b \"b val\" :c \"c val\"} (print k \" - \" v))\u000D\u000A# prints c - c val\u000D\u000A# prints a - a val\u000D\u000A# prints b - b val","docstring":"\"\\n\\n    macro\\n    boot.janet on line 504, column 1\\n\\n    (eachp x ds & body)\\n    \\n    Loop over each (key, value) pair in ds. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"eachp","created-at":1600080366},{"example":"(eachk k [1 2 3] (print k))\u000D\u000A# prints 0\u000D\u000A# prints 1\u000D\u000A# prints 2\u000D\u000A# for indexed collections indices are printed  ","docstring":"\"\\n\\n    macro\\n    boot.janet on line 499, column 1\\n\\n    (eachk x ds & body)\\n    \\n    Loop over each key in ds. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"eachk","created-at":1600080285},{"example":"(eachk k {:a \"a val\" :b \"b val\" :c \"c val\"} (print k))\u000D\u000A# prints c\u000D\u000A# prints a\u000D\u000A# prints b","docstring":"\"\\n\\n    macro\\n    boot.janet on line 499, column 1\\n\\n    (eachk x ds & body)\\n    \\n    Loop over each key in ds. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"eachk","created-at":1600080185},{"example":"(each item [1 2 3 4] (print item))\u000D\u000A# prints 1\u000D\u000A# prints 2\u000D\u000A# prints 3\u000D\u000A# prints 4\u000D\u000A# => nil","docstring":"\"\\n\\n    macro\\n    boot.janet on line 526, column 1\\n\\n    (each x ds & body)\\n    \\n    Loop over each value in ds. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"each","created-at":1600079745},{"example":"(let [len 8\u000D\u000A      rand-string (string/join (map |(string/format \"%02x\" $)\u000D\u000A                                    (os/cryptorand len)))]\u000D\u000A  (= (length rand-string) (* 2 len))) # => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/cryptorand n &opt buf)\\n    \\n    Get or append n bytes of good quality random data provided by the OS.\\n    Returns a new buffer or buf.\\n\\n\\n\"","gh-username":"sogaiu","name":"os/cryptorand","created-at":1598496767},{"example":"(os/execute\u000D\u000A  @(\"/usr/bin/bash\" \"-c\" \"set\")\u000D\u000A  :e\u000D\u000A  @{\"SOME\" \"value\"\u000D\u000A    \"OTHER\" \"one\"})\u000D\u000A# => 0\u000D\u000A\u000D\u000A# execute bash and prints environment variables\u000D\u000A# which contains SOME=value and Other=one","docstring":"\"\\n\\n    cfunction\\n\\n    (os/execute args &opts flags env)\\n    \\n    Execute a program on the system and pass it string arguments. Flags is\\n    a keyword that modifies how the program will execute.\\n    \\n      :e - enables passing an environment to the program. Without :e, the\\n    current environment is inherited.\\n      :p - allows searching the current PATH for the binary to execute.\\n    Without this flag, binaries must use absolute paths.\\n      :x - raise error if exit code is non-zero.\\n    env is a table or struct mapping environment variables to values. It\\n    can also contain the keys :in, :out, and :err, which allow redirecting\\n    stdio in the subprocess. These arguments should be core/file values.\\n    One can also pass in the :pipe keyword for these arguments to create\\n    files that will read (for :err and :out) or write (for :in) to the file\\n    descriptor of the subprocess. This is only useful in os/spawn, which\\n    takes the same parameters as os/execute, but will return an object that\\n    contains references to these files via (return-value :in),\\n    (return-value :out), and (return-value :err). Returns the exit status\\n    of the program.\\n\\n\\n\"","gh-username":"goldenHairDafo","name":"os/execute","created-at":1598467159},{"example":"(os/execute\u000D\u000A  @(\"python\" \"-c\" \"print('Hello Janet'\"))\u000D\u000A  :p) \u000D\u000A# => 0\u000D\u000A\u000D\u000A# execute python -c \"print('Hello Janet') while\u000D\u000A# searching path on the current path","docstring":"\"\\n\\n    cfunction\\n\\n    (os/execute args &opts flags env)\\n    \\n    Execute a program on the system and pass it string arguments. Flags is\\n    a keyword that modifies how the program will execute.\\n    \\n      :e - enables passing an environment to the program. Without :e, the\\n    current environment is inherited.\\n      :p - allows searching the current PATH for the binary to execute.\\n    Without this flag, binaries must use absolute paths.\\n      :x - raise error if exit code is non-zero.\\n    env is a table or struct mapping environment variables to values. It\\n    can also contain the keys :in, :out, and :err, which allow redirecting\\n    stdio in the subprocess. These arguments should be core/file values.\\n    One can also pass in the :pipe keyword for these arguments to create\\n    files that will read (for :err and :out) or write (for :in) to the file\\n    descriptor of the subprocess. This is only useful in os/spawn, which\\n    takes the same parameters as os/execute, but will return an object that\\n    contains references to these files via (return-value :in),\\n    (return-value :out), and (return-value :err). Returns the exit status\\n    of the program.\\n\\n\\n\"","gh-username":"goldenHairDafo","name":"os/execute","created-at":1598466977},{"example":"(defn output [x]\u000D\u000A  (case x\u000D\u000A    :a \"a\"\u000D\u000A    \"b\"))\u000D\u000A\u000D\u000A(output :a) # => \"a\"\u000D\u000A(output \"anything else\") # => \"b\"","docstring":"\"\\n\\n    macro\\n    boot.janet on line 187, column 1\\n\\n    (case dispatch & pairs)\\n    \\n    Select the body that equals the dispatch value. When pairs has an odd\\n    number of arguments, the last is the default expression. If no match is\\n    found, returns nil.\\n\\n\\n\"","gh-username":"swlkr","name":"case","created-at":1595980046},{"example":"(first [4 5 6])  # => 4","docstring":"\"\\n\\n    function\\n    boot.janet on line 692, column 1\\n\\n    (first xs)\\n    \\n    Get the first element from an indexed data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"first","created-at":1595968450},{"example":"(flatten [1 [2 3 [4]] 5])  # => @[1 2 3 4 5]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1441, column 1\\n\\n    (flatten xs)\\n    \\n    Takes a nested array (tree), and returns the depth first traversal of\\n    that array. Returns a new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"flatten","created-at":1595965683},{"example":"> (eprin \"there is a boo-boo on line \" 33 \"\\n\")\u000D\u000Athere is a boo-boo on line 33\u000D\u000Anil\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (eprin & xs)\\n    \\n    Same as prin, but uses (dyn :err stderr) instead of (dyn :out stdout).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"eprin","created-at":1595957432},{"example":"(update @[3 4 5] 1 dec)  # => @[3 3 5]\u000D\u000A(update (update @[3 4 5] 1 dec) 2 inc)  # => @[3 3 6]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1342, column 1\\n\\n    (update ds key func & args)\\n    \\n    Accepts a key argument and passes its associated value to a function.\\n    The key is the re-associated to the function's return value. Returns\\n    the updated data structure ds.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"update","created-at":1595957268},{"example":"(get @\"A\"                      0)  # => 65 (0b01000001)\u000D\u000A(get (buffer/bit-clear @\"A\" 0) 0)  # => 64 (0b01000000)\u000D\u000A(get (buffer/bit-clear @\"A\" 6) 0)  # =>  1 (0b00000001)\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/bit-clear buffer index)\\n    \\n    Clears the bit at the given bit-index. Returns the buffer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"buffer/bit-clear","created-at":1595956867},{"example":"(defn square [x] (* x x))\u000D\u000A(defn square-then-dec [x] ((comp dec square) x))\u000D\u000A(defn dec-then-square [x] ((comp square dec) x))\u000D\u000A(square-then-dec 3)  # => 8\u000D\u000A(dec-then-square 3)  # => 4\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 651, column 1\\n\\n    (comp & functions)\\n    \\n    Takes multiple functions and returns a function that is the\\n    composition of those functions.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"comp","created-at":1595956449},{"example":"(any? [false false nil]) => nil\u000D\u000A(any? [false false nil 1]) => 1\u000D\u000A(any? [false false nil true]) => true","docstring":"\"\\n\\n    function\\n    boot.janet on line 1230, column 1\\n\\n    (any? ind)\\n    \\n    Returns the first truthy value in ind, otherwise nil. falsey value.\\n\\n\\n\"","gh-username":"swlkr","name":"any?","created-at":1595527200},{"example":"(buffer/bit (buffer/new-filled 1 (chr \"0\")) 4)\u000D\u000A# => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/bit buffer index)\\n    \\n    Gets the bit at the given bit-index. Returns true if the bit is set,\\n    false if not.\\n\\n\\n\"","gh-username":"sogaiu","name":"buffer/bit","created-at":1595035493},{"example":"(buffer/bit (buffer/new-filled 1 48) 4)\u000D\u000A# => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/bit buffer index)\\n    \\n    Gets the bit at the given bit-index. Returns true if the bit is set,\\n    false if not.\\n\\n\\n\"","gh-username":"sogaiu","name":"buffer/bit","created-at":1595035467},{"example":"(buffer/bit @\"0\" 4)\u000D\u000A# => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/bit buffer index)\\n    \\n    Gets the bit at the given bit-index. Returns true if the bit is set,\\n    false if not.\\n\\n\\n\"","gh-username":"sogaiu","name":"buffer/bit","created-at":1595035246},{"example":"(buffer/bit @\"1\" 0)\u000D\u000A# => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/bit buffer index)\\n    \\n    Gets the bit at the given bit-index. Returns true if the bit is set,\\n    false if not.\\n\\n\\n\"","gh-username":"sogaiu","name":"buffer/bit","created-at":1595035122},{"example":"(buffer/format @\"0 - 1 = \" \"%d\" -1)\u000D\u000A# => @\"0 - 1 = -1\"","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/format buffer format & args)\\n    \\n    Snprintf like functionality for printing values into a buffer. Returns\\n    the modified buffer.\\n\\n\\n\"","gh-username":"sogaiu","name":"buffer/format","created-at":1595034970},{"example":"(put-in  @{:a @{:aa 5} :b @{:bb 6}}  [:c]          9)  # => @{:a @{:aa 5} :b @{:bb 6} :c 9}\u000D\u000A(put-in  @{:a @{:aa 5} :b @{:bb 6}}  [:a :aa]      9)  # => @{:a @{:aa 9} :b @{:bb 6}}\u000D\u000A(put-in  @{:a @{:aa 5} :b @{:bb 6}}  [:a :cc :ddd] 9)  # => @{:a @{:cc @{:ddd 9} :aa 5} :b @{:bb 6}}\u000D\u000A\u000D\u000A(put-in  @[:a :b @[:aa :bb :cc]]  [2 1] :zz )  # => @[:a :b @[:aa :zz :cc]]\u000D\u000A(put-in  @[:a :b @[:aa :bb :cc]]  [5]   :z  )  # => @[:a :b @[:aa :bb :cc] nil nil :z]\u000D\u000A\u000D\u000A(put-in  @[:a :b @[:aa :bb :cc]]  [4 0]   :zz )  # => @[:a :b @[:aa :bb :cc] nil @{0 :zz}]\u000D\u000A(put-in  @[:a :b @[:aa :bb :cc]]  [4 :yy] :zz )  # => @[:a :b @[:aa :bb :cc] nil @{:yy :zz}]\u000D\u000A\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1320, column 1\\n\\n    (put-in ds ks v)\\n    \\n    Put a value into a nested data structure. Looks into the data\\n    structure via a sequence of keys. Missing data structures will be\\n    replaced with tables. Returns the modified, original data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"put-in","created-at":1593914303},{"example":"(put  @{:a 4 :b 5}  :c 6         )  # => @{:a 4 :b 5 :c 6}\u000D\u000A(put  @{:a 4 :b 5}  :b nil       )  # => @{:a 4}\u000D\u000A(put  @{:a 4 :b 5}  :z nil       )  # => @{:a 4 :b 5}\u000D\u000A\u000D\u000A(put  @[:a :b :c]   0  :z        )  # => @[:z :b :c]\u000D\u000A(put  @[:a :b :c]   1  nil       )  # => @[:a nil :c]\u000D\u000A\u000D\u000A(put  @[:a :b :c]   5  :d        )  # => @[:a :b :c nil nil :d]\u000D\u000A\u000D\u000A(put  @\"hello\"      0  \"z\"       )  # error: can only put integers in buffers\u000D\u000A(defn ord [ch] (first (string/bytes ch)))\u000D\u000A(ord \"z\")  # => 122\u000D\u000A(put  @\"hello\"      0  122       )  # => @\"zello\"\u000D\u000A(put  @\"hello\"      0  (ord \"z\") )  # => @\"zello\"\u000D\u000A(put  @\"hello\"      8  (ord \"y\") )  # => @\"hello\\0\\0\\0y\"\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (put ds key value)\\n    \\n    Associate a key with a value in any mutable associative data\\n    structure. Indexed data structures (arrays and buffers) only accept\\n    non-negative integer keys, and will expand if an out of bounds value is\\n    provided. In an array, extra space will be filled with nils, and in a\\n    buffer, extra space will be filled with 0 bytes. In a table, putting a\\n    key that is contained in the table prototype will hide the association\\n    defined by the prototype, but will not mutate the prototype table.\\n    Putting a value nil into a table will remove the key from the table.\\n    Returns the data structure ds.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"put","created-at":1593913019},{"example":"(next  [4 5 6]    )  # => 0\u000D\u000A(next  [4 5 6]  0 )  # => 1\u000D\u000A(next  [4 5 6]  1 )  # => 2\u000D\u000A(next  [4 5 6]  2 )  # => nil\u000D\u000A\u000D\u000A# note that dictionary keys are not necessarily in the same order\u000D\u000A# as the corresponding literal.\u000D\u000A(next  {:a 5 :b 6 :c 7}     )  # => :a\u000D\u000A(next  {:a 5 :b 6 :c 7}  :a )  # => :c\u000D\u000A(next  {:a 5 :b 6 :c 7}  :c )  # => :b\u000D\u000A(next  {:a 5 :b 6 :c 7}  :b )  # => nil\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (next ds &opt key)\\n    \\n    Gets the next key in a data structure. Can be used to iterate through\\n    the keys of a data structure in an unspecified order. Keys are\\n    guaranteed to be seen only once per iteration if they data structure is\\n    not mutated during iteration. If key is nil, next returns the first\\n    key. If next returns nil, there are no more keys to iterate through.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"next","created-at":1593911557},{"example":"(or true)        # => true\u000D\u000A(or true true)   # => true\u000D\u000A(or true false)  # => true\u000D\u000A\u000D\u000A(or false 1 2)  # => 1\u000D\u000A(or false 2 1)  # => 2\u000D\u000A\u000D\u000A(or false nil)  # => nil\u000D\u000A(or nil false)  # => false\u000D\u000A\u000D\u000A# note that `or` does not behave as you might expect\u000D\u000A# when used with `apply` and `splice`:\u000D\u000A(or 1 2 3)             # => 1\u000D\u000A(or (splice [1 2 3]))  # => (1 2 3)\u000D\u000A(apply or [1 2 3])     # => (if 1 1 (if 2 2 3))\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 267, column 1\\n\\n    (or & forms)\\n    \\n    Evaluates to the last argument if all preceding elements are falsey,\\n    otherwise evaluates to the first truthy element.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"or","created-at":1593911207},{"example":"(map false? [ false nil   true  0     1     42    'a    :a    \"a\"   [97]  {:a 42} (fn []) ])\u000D\u000A# =>       @[ true  false false false false false false false false false false   false   ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 111, column 1\\n\\n    (false? x)\\n    \\n    Check if x is false.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"false?","created-at":1593910125},{"example":"(map true? [ true nil   false 0     1     42    'a    :a    \"a\"   [97]  {:a 42} (fn []) ])\u000D\u000A# =>      @[ true false false false false false false false false false false   false   ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 110, column 1\\n\\n    (true? x)\\n    \\n    Check if x is true.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"true?","created-at":1593909983},{"example":"(map bytes?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  true  true   true   false    false     false        false         ]\u000D\u000A\u000D\u000A(map symbol?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  false false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map keyword?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false true  false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map string?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false true   false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map buffer?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  true   false    false     false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 88, column 1\\n\\n    (string? x)\\n    \\n    Check if x is a string.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string?","created-at":1593893482},{"example":"(map bytes?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  true  true   true   false    false     false        false         ]\u000D\u000A\u000D\u000A(map symbol?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  false false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map keyword?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false true  false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map string?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false true   false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map buffer?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  true   false    false     false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 90, column 1\\n\\n    (keyword? x)\\n    \\n    Check if x is a keyword.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"keyword?","created-at":1593893475},{"example":"(map bytes?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  true  true   true   false    false     false        false         ]\u000D\u000A\u000D\u000A(map symbol?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  false false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map keyword?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false true  false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map string?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false true   false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map buffer?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  true   false    false     false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 89, column 1\\n\\n    (symbol? x)\\n    \\n    Check if x is a symbol.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"symbol?","created-at":1593893468},{"example":"(map  |($ {:a 7 :b 8} )   [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[:a :b]  @[7 8]    @[:a 7 :b 8]    @[(:a 7) (:b 8)]      ]\u000D\u000A\u000D\u000A(map  |($ [4 5 6] )       [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1 2]  @[4 5 6]  @[0 4 1 5 2 6]  @[(0 4) (1 5) (2 6)]  ]\u000D\u000A\u000D\u000A(map  |($ 'ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ :ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ \"ab\" )          [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1391, column 1\\n\\n    (pairs x)\\n    \\n    Get the values of an associative data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"pairs","created-at":1593890440},{"example":"(map  |($ {:a 7 :b 8} )   [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[:a :b]  @[7 8]    @[:a 7 :b 8]    @[(:a 7) (:b 8)]      ]\u000D\u000A\u000D\u000A(map  |($ [4 5 6] )       [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1 2]  @[4 5 6]  @[0 4 1 5 2 6]  @[(0 4) (1 5) (2 6)]  ]\u000D\u000A\u000D\u000A(map  |($ 'ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ :ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ \"ab\" )          [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1447, column 1\\n\\n    (kvs dict)\\n    \\n    Takes a table or struct and returns and array of key value pairs like\\n    @[k v k v ...]. Returns a new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"kvs","created-at":1593889782},{"example":"(map  |($ {:a 7 :b 8} )   [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[:a :b]  @[7 8]    @[:a 7 :b 8]    @[(:a 7) (:b 8)]      ]\u000D\u000A\u000D\u000A(map  |($ [4 5 6] )       [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1 2]  @[4 5 6]  @[0 4 1 5 2 6]  @[(0 4) (1 5) (2 6)]  ]\u000D\u000A\u000D\u000A(map  |($ 'ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ :ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ \"ab\" )          [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1381, column 1\\n\\n    (values x)\\n    \\n    Get the values of an associative data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"values","created-at":1593889631},{"example":"(map  |($ {:a 7 :b 8} )   [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[:a :b]  @[7 8]    @[:a 7 :b 8]    @[(:a 7) (:b 8)]      ]\u000D\u000A\u000D\u000A(map  |($ [4 5 6] )       [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1 2]  @[4 5 6]  @[0 4 1 5 2 6]  @[(0 4) (1 5) (2 6)]  ]\u000D\u000A\u000D\u000A(map  |($ 'ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ :ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ \"ab\" )          [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1371, column 1\\n\\n    (keys x)\\n    \\n    Get the keys of an associative data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"keys","created-at":1593889501},{"example":"(get-in  {:a {:cc 2} :b {:dd 3}}  [:a]     42)  # => {:cc 2}\u000D\u000A(get-in  {:a {:cc 2} :b {:dd 3}}  [:a :cc] 42)  # => 2\u000D\u000A\u000D\u000A(get-in  {:a {:cc 2} :b {:dd 3}}  [0]  42)  # => 42\u000D\u000A(get-in  {:a {:cc 2} :b {:dd 3}}  [:z] 42)  # => 42\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1290, column 1\\n\\n    (get-in ds ks &opt dflt)\\n    \\n    Access a value in a nested data structure. Looks into the data\\n    structure via a sequence of keys.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"get-in","created-at":1593889060},{"example":"(get-in  [[4 5] [6 7]]  [0]    42)  # => (4 5)\u000D\u000A(get-in  [[4 5] [6 7]]  [0 1]  42)  # => 5\u000D\u000A\u000D\u000A(get-in  [[4 5] [6 7]]  [-1]     42)  # => 42\u000D\u000A(get-in  [[4 5] [6 7]]  [9 9 9]  42)  # => 42\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1290, column 1\\n\\n    (get-in ds ks &opt dflt)\\n    \\n    Access a value in a nested data structure. Looks into the data\\n    structure via a sequence of keys.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"get-in","created-at":1593888962},{"example":"(get      [4 5 6]   -1     )  # => nil\u000D\u000A(in       [4 5 6]   -1  42 )  # error\u000D\u000A(get-in   [4 5 6]  [-1] 42 )  # => 42\u000D\u000A\u000D\u000A(get     {:a 1}   -1     )  # => nil\u000D\u000A(in      {:a 1}   -1  42 )  # => 42\u000D\u000A(get-in  {:a 1}  [-1] 42 )  # => 42\u000D\u000A\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (get ds key &opt dflt)\\n    \\n    Get the value mapped to key in data structure ds, and return dflt or\\n    nil if not found. Similar to in, but will not throw an error if the key\\n    is invalid for the data structure unless the data structure is an\\n    abstract type. In that case, the abstract type getter may throw an\\n    error.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"get","created-at":1593888604},{"example":"(get      [4 5 6]   -1     )  # => nil\u000D\u000A(in       [4 5 6]   -1  42 )  # error\u000D\u000A(get-in   [4 5 6]  [-1] 42 )  # => 42\u000D\u000A\u000D\u000A(get     {:a 1}   -1     )  # => nil\u000D\u000A(in      {:a 1}   -1  42 )  # => 42\u000D\u000A(get-in  {:a 1}  [-1] 42 )  # => 42","docstring":"\"\\n\\n    function\\n\\n    (in ds key &opt dflt)\\n    \\n    Get value in ds at key, works on associative data structures. Arrays,\\n    tuples, tables, structs, strings, symbols, and buffers are all\\n    associative and can be used. Arrays, tuples, strings, buffers, and\\n    symbols must use integer keys that are in bounds or an error is raised.\\n    Structs and tables can take any value as a key except nil and will\\n    return nil or dflt if not found.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"in","created-at":1593888594},{"example":"(in  [10 11 12 13]  0   42 )  # => 10\u000D\u000A(in  {:a 10 :b 20}  :a  42 )  # => 10\u000D\u000A\u000D\u000A(in  [10 11 12]  99 42 )  # error\u000D\u000A(in  [10 11 12]  -1 42 )  # error\u000D\u000A(in  [10 11 12]  -2 42 )  # error\u000D\u000A(in  {:a 1}      :z 42 )  # => 42\u000D\u000A\u000D\u000A(map  (fn [x] (in x 0 42))   [  'a  :a  \"a\"  [97]  @[97]  {0 97}  @{0 97}  {:a 1} ])\u000D\u000A# =>                        @[  97  97  97   97    97     97      97       42     ]\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (in ds key &opt dflt)\\n    \\n    Get value in ds at key, works on associative data structures. Arrays,\\n    tuples, tables, structs, strings, symbols, and buffers are all\\n    associative and can be used. Arrays, tuples, strings, buffers, and\\n    symbols must use integer keys that are in bounds or an error is raised.\\n    Structs and tables can take any value as a key except nil and will\\n    return nil or dflt if not found.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"in","created-at":1593888298},{"example":"(get  [10 11 12 13]  0  )  # => 10\u000D\u000A(get  {:a 10 :b 20}  :a )  # => 10\u000D\u000A\u000D\u000A(get  [10 11 12]  99  )  # => nil\u000D\u000A(get  [10 11 12]  -1  )  # => nil\u000D\u000A(get  [10 11 12]  -2  )  # => nil\u000D\u000A(get  {:a 1}      :z  )  # => nil\u000D\u000A\u000D\u000A(map  (fn [x] (get x 0))   [  'a  :a  \"a\"  [97]  @[97]  {0 97}  @{0 97}  ])\u000D\u000A# =>                      @[  97  97  97   97    97     97      97       ]\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (get ds key &opt dflt)\\n    \\n    Get the value mapped to key in data structure ds, and return dflt or\\n    nil if not found. Similar to in, but will not throw an error if the key\\n    is invalid for the data structure unless the data structure is an\\n    abstract type. In that case, the abstract type getter may throw an\\n    error.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"get","created-at":1593887208},{"example":"(map length  [  'a  :a  \"a\"  [97]  @[97]  {0 97}  @{0 97}  ])\u000D\u000A# =>        @[  1   1   1    1     1      1       1        ]\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (length ds)\\n    \\n    Returns the length or count of a data structure in constant time as an\\n    integer. For structs and tables, returns the number of key-value pairs\\n    in the data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"length","created-at":1593886794},{"example":"(int/u64 42)    # => <core/u64 42>\u000D\u000A(int/u64 42.1)  # => <core/u64 42>\u000D\u000A(int/u64 \"42\")  # => <core/u64 42>","docstring":"\"\\n\\n    cfunction\\n\\n    (int/u64 value)\\n    \\n    Create a boxed unsigned 64 bit integer from a string value.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"int/u64","created-at":1593886598},{"example":"(int/s64 42)    # => <core/s64 42>\u000D\u000A(int/s64 42.1)  # => <core/s64 42>\u000D\u000A(int/s64 \"42\")  # => <core/s64 42>\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (int/s64 value)\\n    \\n    Create a boxed signed 64 bit integer from a string value.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"int/s64","created-at":1593886543},{"example":"(abstract? (file/temp))  # => true\u000D\u000A(abstract? (int/s64 1))  # => true\u000D\u000A\u000D\u000A(map abstract?  [ nil true 97 'a :a \"a\" ])\u000D\u000A# => @[false false false false false false]\u000D\u000A\u000D\u000A(map abstract?  [ [97]  @[97]  {0 97}  @{0 97} ])\u000D\u000A# => @[false false false false]\u000D\u000A\u000D\u000A(map abstract?  [ even? loop file/open  (fn [])  ])\u000D\u000A# => @[false false false false]\u000D\u000A\u000D\u000A(map abstract?  [ (file/temp)  (fiber/new (fn []))  ])\u000D\u000A# => @[true false]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (abstract? x)\\n    \\n    Check if x is an abstract type.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"abstract?","created-at":1593886081},{"example":"(map idempotent?  [ nil  true 97   'a   :a   \"a\"  ])\u000D\u000A# =>             @[ true true true true true true ]\u000D\u000A\u000D\u000A(map idempotent?  [  [97]   @[97]  {0 97}  @{0 97}  ])\u000D\u000A# =>             @[  false  false  false   false    ]\u000D\u000A\u000D\u000A(map idempotent?  [  (fn [])  even?  loop  file/open  ])\u000D\u000A# =>             @[  true     true   true  true       ]\u000D\u000A\u000D\u000A(map idempotent?  [  (file/temp)  (fiber/new (fn []))  ])\u000D\u000A# =>             @[  true         true                 ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 115, column 1\\n\\n    (idempotent? x)\\n    \\n    Check if x is a value that evaluates to itself when compiled.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"idempotent?","created-at":1593885708},{"example":"(map dictionary? [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         true          ]\u000D\u000A\u000D\u000A(map struct?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         false         ]\u000D\u000A\u000D\u000A(map table?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     false        true          ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 103, column 1\\n\\n    (dictionary? x)\\n    \\n    Check if x a table or struct.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"dictionary?","created-at":1593885103},{"example":"(map indexed?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     true      false        false         ]\u000D\u000A\u000D\u000A(map tuple?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     false     false        false         ]\u000D\u000A\u000D\u000A(map array?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    true      false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 106, column 1\\n\\n    (indexed? x)\\n    \\n    Check if x is an array or tuple.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"indexed?","created-at":1593884977},{"example":"(map bytes?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  true  true   true   false    false     false        false         ]\u000D\u000A\u000D\u000A(map symbol?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  false false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map keyword?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false true  false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map string?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false true   false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map buffer?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  true   false    false     false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 100, column 1\\n\\n    (bytes? x)\\n    \\n    Check if x is a string, symbol, keyword, or buffer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"bytes?","created-at":1593884686},{"example":"(map dictionary? [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         true          ]\u000D\u000A\u000D\u000A(map struct?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         false         ]\u000D\u000A\u000D\u000A(map table?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     false        true          ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 95, column 1\\n\\n    (table? x)\\n    \\n    Check if x a table.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"table?","created-at":1593884559},{"example":"(map dictionary? [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         true          ]\u000D\u000A\u000D\u000A(map struct?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         false         ]\u000D\u000A\u000D\u000A(map table?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     false        true          ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 96, column 1\\n\\n    (struct? x)\\n    \\n    Check if x a struct.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"struct?","created-at":1593882359},{"example":"(map indexed?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     true      false        false         ]\u000D\u000A\u000D\u000A(map tuple?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     false     false        false         ]\u000D\u000A\u000D\u000A(map array?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    true      false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 98, column 1\\n\\n    (tuple? x)\\n    \\n    Check if x is a tuple.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"tuple?","created-at":1593882292},{"example":"(map bytes?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  true  true   true   false    false     false        false         ]\u000D\u000A\u000D\u000A(map symbol?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  false false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map keyword?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false true  false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map string?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false true   false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map buffer?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  true   false    false     false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 91, column 1\\n\\n    (buffer? x)\\n    \\n    Check if x is a buffer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"buffer?","created-at":1593882230},{"example":"(keyword? :a)   # => true\u000D\u000A(keyword? \"a\")  # => false","docstring":"\"\\n\\n    function\\n    boot.janet on line 90, column 1\\n\\n    (keyword? x)\\n    \\n    Check if x is a keyword.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"keyword?","created-at":1593882128},{"example":"(map cfunction? [ even?  (fn [])  |($)   file/read  ->    ])\u000D\u000A# =>           @[ false  false    false  true       false ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 94, column 1\\n\\n    (cfunction? x)\\n    \\n    Check if x a cfunction.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"cfunction?","created-at":1593882006},{"example":"(map function? [ even?  (fn [])  |($)  file/read  ->   ])\u000D\u000A# =>          @[ true   true     true  false      true ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 92, column 1\\n\\n    (function? x)\\n    \\n    Check if x is a function (not a cfunction).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"function?","created-at":1593881959},{"example":"(map int?  [ nil   true  0    1    3.14   (math/trunc 3.14)  (band 1.1 2.2) ])\u000D\u000A# =>      @[ false false true true false  true               true           ]","docstring":"\"\\n\\n    cfunction\\n\\n    (int? x)\\n    \\n    Check if x can be exactly represented as a 32 bit signed two's\\n    complement integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"int?","created-at":1593881753},{"example":"(map boolean? [true false nil   0     1    ])\u000D\u000A# =>         @[true true  false false false]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 99, column 1\\n\\n    (boolean? x)\\n    \\n    Check if x is a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"boolean?","created-at":1593881572},{"example":"(map nil? [nil  0     false []   ])\u000D\u000A# =>     @[true false false false]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 112, column 1\\n\\n    (nil? x)\\n    \\n    Check if x is nil.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"nil?","created-at":1593881515},{"example":"(map type [nil true 42 [] @[] {} @{} \"a\" @\"b\" 'c :d identity (fn [])])\u000D\u000A# => @[:nil :boolean :number :tuple :array :struct :table :string :buffer :symbol :keyword :function :function]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (type x)\\n    \\n    Returns the type of x as a keyword. x is one of\\n      :nil\\n      :boolean\\n      :number\\n      :array\\n      :tuple\\n      :table\\n      :struct\\n      :string\\n      :buffer\\n      :symbol\\n      :keyword\\n      :function\\n      :cfunction\\n    \\n    or another keyword for an abstract type.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"type","created-at":1593881446},{"example":"(os/shell \"echo bar > /tmp/foo\")\u000D\u000A(with\u000D\u000A  [file-handle\u000D\u000A   (file/open \"/tmp/foo\")\u000D\u000A   (fn [fd] (file/close fd))]\u000D\u000A  (file/read file-handle :all))  # => @\"bar\\n\"\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 354, column 1\\n\\n    (with [binding ctor dtor] & body)\\n    \\n    Evaluate body with some resource, which will be automatically cleaned\\n    up if there is an error in body. binding is bound to the expression\\n    ctor, and dtor is a function or callable that is passed the binding. If\\n    no destructor (dtor) is given, will call :close on the resource.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"with","created-at":1593880973},{"example":"(let [a 1 b 2 c 3] (+ a b c))  # => 6\u000D\u000A\u000D\u000A(let\u000D\u000A  [a 1\u000D\u000A   b (+ a 1)\u000D\u000A   c (+ b 1)]\u000D\u000A  (+ a b c))  # => 6\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 207, column 1\\n\\n    (let bindings & body)\\n    \\n    Create a scope and bind values to symbols. Each pair in bindings is\\n    assigned as if with def, and the body of the let form returns the last\\n    value.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"let","created-at":1593880576},{"example":"(map  (fn [x] (< x 10))    [8 9 10 11])  # => @[true true false false]\u000D\u000A(map  (short-fn (< $ 10))  [8 9 10 11])  # => @[true true false false]\u000D\u000A(map  |(< $ 10)            [8 9 10 11])  # => @[true true false false]\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1957, column 1\\n\\n    (short-fn arg)\\n    \\n    fn shorthand.\\n    \\n    usage:\\n    \\n      (short-fn (+ $ $)) - A function that double's its arguments.\\n      (short-fn (string $0 $1)) - accepting multiple args\\n      |(+ $ $) - use pipe reader macro for terse function literals\\n      |(+ $&) - variadic functions\\n\\n\\n\"","gh-username":"cellularmitosis","name":"short-fn","created-at":1593880398},{"example":"(string/trimr \" foo \")  # => \" foo\"\u000D\u000A(string/trimr \"_!_foo_!_\" \"_!\")  # => \"_!_foo\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/trimr str &opt set)\\n    \\n    Trim trailing whitespace from a byte sequence. If the argument set is\\n    provided, consider only characters in set to be whitespace.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/trimr","created-at":1593854866},{"example":"(string/triml \" foo \")  # => \"foo \"\u000D\u000A(string/triml \"_!_foo_!_\" \"_!\")  # => \"foo_!_\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/triml str &opt set)\\n    \\n    Trim leading whitespace from a byte sequence. If the argument set is\\n    provided, consider only characters in set to be whitespace.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/triml","created-at":1593854808},{"example":"(string/trim \" foo \")  # => \"foo\"\u000D\u000A(string/trim \"_!_foo_!_\" \"_!\")  # => \"foo\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/trim str &opt set)\\n    \\n    Trim leading and trailing whitespace from a byte sequence. If the\\n    argument set is provided, consider only characters in set to be\\n    whitespace.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/trim","created-at":1593854700},{"example":"(string/slice \"hello\")    # => \"hello\"\u000D\u000A\u000D\u000A(string/slice \"hello\" 0)  # => \"hello\"\u000D\u000A(string/slice \"hello\" 1)  # => \"ello\"\u000D\u000A(string/slice \"hello\" 4)  # => \"o\"\u000D\u000A(string/slice \"hello\" 5)  # => \"\"\u000D\u000A\u000D\u000A(string/slice \"hello\" -1)  # => \"\"\u000D\u000A(string/slice \"hello\" -2)  # => \"o\"\u000D\u000A(string/slice \"hello\" -5)  # => \"ello\"\u000D\u000A(string/slice \"hello\" -6)  # => \"hello\"\u000D\u000A\u000D\u000A(string/slice \"hello\" 1 1)  # => \"\"\u000D\u000A(string/slice \"hello\" 1 2)  # => \"e\"\u000D\u000A(string/slice \"hello\" 1 5)  # => \"ello\"\u000D\u000A\u000D\u000A(string/slice \"hello\" -5 -4)  # => \"e\"\u000D\u000A(string/slice \"hello\" -6 -4)  # => \"he\"\u000D\u000A\u000D\u000A(string/slice \"hello\"  2  1)  # => \"\"\u000D\u000A(string/slice \"hello\" -1 -2)  # => \"\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (string/slice bytes &opt start end)\\n    \\n    Returns a substring from a byte sequence. The substring is from index\\n    start inclusive to index end exclusive. All indexing is from 0. 'start'\\n    and 'end' can also be negative to indicate indexing from the end of the\\n    string. Note that index -1 is synonymous with index (length bytes) to\\n    allow a full negative slice range. \\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/slice","created-at":1593854572},{"example":"(string/repeat \"moshi\" 2)  # => \"moshimoshi\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/repeat bytes n)\\n    \\n    Returns a string that is n copies of bytes concatenated.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/repeat","created-at":1593854109},{"example":"(string/ascii-upper \"hello\")  # => \"HELLO\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/ascii-upper str)\\n    \\n    Returns a new string where all bytes are replaced with the uppercase\\n    version of themselves in ASCII. Does only a very simple case check,\\n    meaning no unicode support.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/ascii-upper","created-at":1593853715},{"example":"(not=        [1 1]   [1 1])  # => false\u000D\u000A(not=        [1 1]   [2 3])  # => true\u000D\u000A(not=        [1 1]  @[1 1])  # => true\u000D\u000A(not=        [1 1]  @[2 3])  # => true\u000D\u000A(not=       @[1 1]  @[1 1])  # => true\u000D\u000A(not=       @[1 1]  @[2 3])  # => true\u000D\u000A\u000D\u000A(deep-not=   [1 1]   [1 1])  # => nil\u000D\u000A(deep-not=   [1 1]   [2 3])  # => true\u000D\u000A(deep-not=   [1 1]  @[1 1])  # => true\u000D\u000A(deep-not=   [1 1]  @[2 3])  # => true\u000D\u000A(deep-not=  @[1 1]  @[1 1])  # => nil\u000D\u000A(deep-not=  @[1 1]  @[2 3])  # => true\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1874, column 1\\n\\n    (deep-not= x y)\\n    \\n    Like not=, but mutable types (arrays, tables, buffers) are considered\\n    equal if they have identical structure. Much slower than not=.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"deep-not=","created-at":1593843247},{"example":"(not=        [1 1]   [1 1])  # => false\u000D\u000A(not=        [1 1]   [2 3])  # => true\u000D\u000A(not=        [1 1]  @[1 1])  # => true\u000D\u000A(not=        [1 1]  @[2 3])  # => true\u000D\u000A(not=       @[1 1]  @[1 1])  # => true\u000D\u000A(not=       @[1 1]  @[2 3])  # => true\u000D\u000A\u000D\u000A(deep-not=   [1 1]   [1 1])  # => nil\u000D\u000A(deep-not=   [1 1]   [2 3])  # => true\u000D\u000A(deep-not=   [1 1]  @[1 1])  # => true\u000D\u000A(deep-not=   [1 1]  @[2 3])  # => true\u000D\u000A(deep-not=  @[1 1]  @[1 1])  # => nil\u000D\u000A(deep-not=  @[1 1]  @[2 3])  # => true","docstring":"\"\\n\\n    function\\n\\n    (not= & xs)\\n    \\n    Check if any values in xs are not equal. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"not=","created-at":1593843232},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(=       [1 1]   [1 1])  # => true\u000D\u000A(=       [1 1]   [2 3])  # => false\u000D\u000A(=       [1 1]  @[1 1])  # => false\u000D\u000A(=       [1 1]  @[2 3])  # => false\u000D\u000A(=      @[1 1]  @[1 1])  # => false\u000D\u000A(=      @[1 1]  @[2 3])  # => false\u000D\u000A\u000D\u000A(deep=   [1 1]   [1 1])  # => true\u000D\u000A(deep=   [1 1]   [2 3])  # => false\u000D\u000A(deep=   [1 1]  @[1 1])  # => false\u000D\u000A(deep=   [1 1]  @[2 3])  # => false\u000D\u000A(deep=  @[1 1]  @[1 1])  # => true\u000D\u000A(deep=  @[1 1]  @[2 3])  # => false\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1889, column 1\\n\\n    (deep= x y)\\n    \\n    Like =, but mutable types (arrays, tables, buffers) are considered\\n    equal if they have identical structure. Much slower than =.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"deep=","created-at":1593842910},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(=       [1 1]   [1 1])  # => true\u000D\u000A(=       [1 1]   [2 3])  # => false\u000D\u000A(=       [1 1]  @[1 1])  # => false\u000D\u000A(=       [1 1]  @[2 3])  # => false\u000D\u000A(=      @[1 1]  @[1 1])  # => false\u000D\u000A(=      @[1 1]  @[2 3])  # => false\u000D\u000A\u000D\u000A(deep=   [1 1]   [1 1])  # => true\u000D\u000A(deep=   [1 1]   [2 3])  # => false\u000D\u000A(deep=   [1 1]  @[1 1])  # => false\u000D\u000A(deep=   [1 1]  @[2 3])  # => false\u000D\u000A(deep=  @[1 1]  @[1 1])  # => true\u000D\u000A(deep=  @[1 1]  @[2 3])  # => false","docstring":"\"\\n\\n    function\\n\\n    (= & xs)\\n    \\n    Check if all values in xs are equal. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"=","created-at":1593842894},{"example":"(brshift 32 2)  # => 8","docstring":"\"\\n\\n    function\\n\\n    (brshift x & shifts)\\n    \\n    Returns the value of x bit shifted right by the sum of all values in\\n    shifts. x and each element in shift must be an integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"brshift","created-at":1593842712},{"example":"(blshift 8 2)  # => 32","docstring":"\"\\n\\n    function\\n\\n    (blshift x & shifts)\\n    \\n    Returns the value of x bit shifted left by the sum of all values in\\n    shifts. x and each element in shift must be an integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"blshift","created-at":1593842672},{"example":"(bxor 3 6)  # => 5\u000D\u000A\u000D\u000A#     011  (3)\u000D\u000A# xor 110  (6)\u000D\u000A# -------\u000D\u000A#     101  (5)\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (bxor & xs)\\n    \\n    Returns the bit-wise xor of all values in xs. Each in xs must be an\\n    integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"bxor","created-at":1593842405},{"example":"(bor 1 2 4)  # => 7\u000D\u000A(bor 7 12)  # => 15\u000D\u000A\u000D\u000A#    0111   (7)\u000D\u000A# or 1100  (12)\u000D\u000A# -------\u000D\u000A#    1111  (15)\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (bor & xs)\\n    \\n    Returns the bit-wise or of all values in xs. Each x in xs must be an\\n    integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"bor","created-at":1593842264},{"example":"(band 7 11)  # => 3\u000D\u000A\u000D\u000A#     0111  (7)\u000D\u000A# and 1011  (11)\u000D\u000A# --------\u000D\u000A#     0011  (3)\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (band & xs)\\n    \\n    Returns the bit-wise and of all values in xs. Each x in xs must be an\\n    integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"band","created-at":1593842028},{"example":"(bnot 255)  # => -256\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (bnot x)\\n    \\n    Returns the bit-wise inverse of integer x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"bnot","created-at":1593841824},{"example":"(map number? [nil   true  42   :a    \"a\"   []    {}    (fn []) ])\u000D\u000A# =>        @[false false true false false false false false   ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 86, column 1\\n\\n    (number? x)\\n    \\n    Check if x is a number.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"number?","created-at":1593841757},{"example":"(nan? 1)  # => false\u000D\u000A(nan? (/ 0 0))  # => true\u000D\u000A(nan? (sqrt -1))  # => true","docstring":"\"\\n\\n    function\\n    boot.janet on line 83, column 1\\n\\n    (nan? x)\\n    \\n    Check if x is NaN\\n\\n\\n\"","gh-username":"cellularmitosis","name":"nan?","created-at":1593841629},{"example":"(nat? 1)       # => true\u000D\u000A(nat? 3.14159) # => false\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (nat? x)\\n    \\n    Check if x can be exactly represented as a non-negative 32 bit signed\\n    two's complement integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"nat?","created-at":1593841557},{"example":"(neg? -42)  # => true\u000D\u000A(map neg? [-1 0 1])  # => @[true false false]","docstring":"\"\\n\\n    function\\n    boot.janet on line 753, column 1\\n\\n    (neg? x)\\n    \\n    Check if x is less than 0.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"neg?","created-at":1593841441},{"example":"(zero? 0)  # => true\u000D\u000A(map zero? [0 1 2])  # => @[true false false]","docstring":"\"\\n\\n    function\\n    boot.janet on line 751, column 1\\n\\n    (zero? x)\\n    \\n    Check if x is zero.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"zero?","created-at":1593841385},{"example":"(one? (math/next 1 math/inf))  # => false","docstring":"\"\\n\\n    cfunction\\n\\n    (math/next x y)\\n    \\n    Returns the next representable floating point value after x in the\\n    direction of y.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/next","created-at":1593841337},{"example":"(one? 1)  # => true\u000D\u000A(map one? [0 1 2])  # => @[false true false]\u000D\u000A\u000D\u000A(one? (math/next 1 math/inf))  # => false","docstring":"\"\\n\\n    function\\n    boot.janet on line 754, column 1\\n\\n    (one? x)\\n    \\n    Check if x is equal to 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"one?","created-at":1593841323},{"example":"(map odd? [1 2 3 4])  # => @[true false true false]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 85, column 1\\n\\n    (odd? x)\\n    \\n    Check if x is odd.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"odd?","created-at":1593841240},{"example":"(even? 1)  # => false\u000D\u000A(map even? [1 2 3 4])  # => @[false true false true]","docstring":"\"\\n\\n    function\\n    boot.janet on line 84, column 1\\n\\n    (even? x)\\n    \\n    Check if x is even.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"even?","created-at":1593841192},{"example":"(var a 2)\u000D\u000Aa        # => 2\u000D\u000A(dec a)  # => 1\u000D\u000Aa        # => 2\u000D\u000A(-- a)   # => 1\u000D\u000Aa        # => 1\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 130, column 1\\n\\n    (-- x)\\n    \\n    Decrements the var x by 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"--","created-at":1593841031},{"example":"(var a 1)\u000D\u000Aa        # => 1\u000D\u000A(inc a)  # => 2\u000D\u000Aa        # => 1\u000D\u000A(++ a)   # => 2\u000D\u000Aa        # => 2\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 129, column 1\\n\\n    (++ x)\\n    \\n    Increments the var x by 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"++","created-at":1593840970},{"example":"(math/log (* math/e math/e))  # => 2\u000D\u000A(math/log2 256)               # => 8\u000D\u000A(math/log10 1000)             # => 3\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/log10 x)\\n    \\n    Returns log base 10 of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/log10","created-at":1593840806},{"example":"(math/log (* math/e math/e))  # => 2\u000D\u000A(math/log2 256)               # => 8\u000D\u000A(math/log10 1000)             # => 3\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/log2 x)\\n    \\n    Returns log base 2 of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/log2","created-at":1593840797},{"example":"(math/log (* math/e math/e))  # => 2\u000D\u000A(math/log2 256)               # => 8\u000D\u000A(math/log10 1000)             # => 3\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/log x)\\n    \\n    Returns log base natural number of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/log","created-at":1593840786},{"example":"(math/pow 10 3)   # => 1000\u000D\u000A(math/cbrt 1000)  # => 10","docstring":"\"\\n\\n    cfunction\\n\\n    (math/cbrt x)\\n    \\n    Returns the cube root of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/cbrt","created-at":1593840461},{"example":"(math/sqrt 9)  # => 3","docstring":"\"\\n\\n    cfunction\\n\\n    (math/sqrt x)\\n    \\n    Returns the square root of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/sqrt","created-at":1593840317},{"example":"(math/pow 2 8)  # => 256","docstring":"\"\\n\\n    cfunction\\n\\n    (math/pow a x)\\n    \\n    Return a to the power of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/pow","created-at":1593840292},{"example":"(map math/abs   [-2.9 -2.1 2.1 2.9])  # => @[ 2.9  2.1  2.1  2.9 ]\u000D\u000A(map math/floor [-2.9 -2.1 2.1 2.9])  # => @[ -3   -3   2    2   ]\u000D\u000A(map math/ceil  [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   3    3   ]\u000D\u000A(map math/round [-2.9 -2.1 2.1 2.9])  # => @[ -3   -2   2    3   ]\u000D\u000A(map math/trunc [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   2    2   ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/trunc x)\\n    \\n    Returns the integer between x and 0 nearest to x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/trunc","created-at":1593840224},{"example":"(map math/abs   [-2.9 -2.1 2.1 2.9])  # => @[ 2.9  2.1  2.1  2.9 ]\u000D\u000A(map math/floor [-2.9 -2.1 2.1 2.9])  # => @[ -3   -3   2    2   ]\u000D\u000A(map math/ceil  [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   3    3   ]\u000D\u000A(map math/round [-2.9 -2.1 2.1 2.9])  # => @[ -3   -2   2    3   ]\u000D\u000A(map math/trunc [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   2    2   ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/round x)\\n    \\n    Returns the integer nearest to x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/round","created-at":1593840211},{"example":"(map math/abs   [-2.9 -2.1 2.1 2.9])  # => @[ 2.9  2.1  2.1  2.9 ]\u000D\u000A(map math/floor [-2.9 -2.1 2.1 2.9])  # => @[ -3   -3   2    2   ]\u000D\u000A(map math/ceil  [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   3    3   ]\u000D\u000A(map math/round [-2.9 -2.1 2.1 2.9])  # => @[ -3   -2   2    3   ]\u000D\u000A(map math/trunc [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   2    2   ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/ceil x)\\n    \\n    Returns the smallest integer value number that is not less than x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/ceil","created-at":1593840200},{"example":"(map math/abs   [-2.9 -2.1 2.1 2.9])  # => @[ 2.9  2.1  2.1  2.9 ]\u000D\u000A(map math/floor [-2.9 -2.1 2.1 2.9])  # => @[ -3   -3   2    2   ]\u000D\u000A(map math/ceil  [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   3    3   ]\u000D\u000A(map math/round [-2.9 -2.1 2.1 2.9])  # => @[ -3   -2   2    3   ]\u000D\u000A(map math/trunc [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   2    2   ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/floor x)\\n    \\n    Returns the largest integer value number that is not greater than x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/floor","created-at":1593840190},{"example":"(map math/abs   [-2.9 -2.1 2.1 2.9])  # => @[ 2.9  2.1  2.1  2.9 ]\u000D\u000A(map math/floor [-2.9 -2.1 2.1 2.9])  # => @[ -3   -3   2    2   ]\u000D\u000A(map math/ceil  [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   3    3   ]\u000D\u000A(map math/round [-2.9 -2.1 2.1 2.9])  # => @[ -3   -2   2    3   ]\u000D\u000A(map math/trunc [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   2    2   ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/abs x)\\n    \\n    Return the absolute value of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/abs","created-at":1593840175},{"example":"(math/round 1.1)  # => 1\u000D\u000A(map math/round [1.49 1.50 1.51])  # => @[1 2 2]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/round x)\\n    \\n    Returns the integer nearest to x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/round","created-at":1593839728},{"example":"(math/floor 1.1)  # => 1\u000D\u000A(map math/floor [1.1 1.2 1.3])  # => @[1 1 1]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/floor x)\\n    \\n    Returns the largest integer value number that is not greater than x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/floor","created-at":1593839626},{"example":"(math/ceil 1.1)  # => 2\u000D\u000A(map math/ceil [1.1 1.2 1.3])  # => @[2 2 2]","docstring":"\"\\n\\n    cfunction\\n\\n    (math/ceil x)\\n    \\n    Returns the smallest integer value number that is not less than x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/ceil","created-at":1593839598},{"example":"(math/abs -42)  # => 42\u000D\u000A(map math/abs [-1 0 1])  # => @[1 0 1]","docstring":"\"\\n\\n    cfunction\\n\\n    (math/abs x)\\n    \\n    Return the absolute value of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/abs","created-at":1593839464},{"example":"(dec 42)  # => 41\u000D\u000A(map dec [1 2 3])  # => @[0 1 2]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 128, column 1\\n\\n    (dec x)\\n    \\n    Returns x - 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"dec","created-at":1593839424},{"example":"(inc 42)  # => 43\u000D\u000A(map inc [1 2 3])  # => @[2 3 4]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 127, column 1\\n\\n    (inc x)\\n    \\n    Returns x + 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"inc","created-at":1593839400},{"example":"(mean [1 10 100])  # => 37\u000D\u000A(mean [])          # => nan","docstring":"\"\\n\\n    function\\n    boot.janet on line 603, column 1\\n\\n    (mean xs)\\n    \\n    Returns the mean of xs. If empty, returns NaN.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"mean","created-at":1593839338},{"example":"(min 1 2 3)             # => 1\u000D\u000A(min (splice [1 2 3]))  # => 1\u000D\u000A(min ;[1 2 3])          # => 1\u000D\u000A(apply min [1 2 3])     # => 1","docstring":"\"\\n\\n    function\\n    boot.janet on line 688, column 1\\n\\n    (min & args)\\n    \\n    Returns the numeric minimum of the arguments.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"min","created-at":1593839271},{"example":"(max 1 2 3)             # => 3\u000D\u000A(max (splice [1 2 3]))  # => 3\u000D\u000A(max ;[1 2 3])          # => 3\u000D\u000A(apply max [1 2 3])     # => 3\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 684, column 1\\n\\n    (max & args)\\n    \\n    Returns the numeric maximum of the arguments.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"max","created-at":1593839213},{"example":"(* 3 4 5)          # => 60\u000D\u000A(product [3 4 5])  # => 60","docstring":"\"\\n\\n    function\\n    boot.janet on line 608, column 1\\n\\n    (product xs)\\n    \\n    Returns the product of xs. If xs is empty, returns 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"product","created-at":1593839123},{"example":"(+ 1 2 3)      # => 6\u000D\u000A(sum [1 2 3])  # => 6","docstring":"\"\\n\\n    function\\n    boot.janet on line 596, column 1\\n\\n    (sum xs)\\n    \\n    Returns the sum of xs. If xs is empty, returns 0.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"sum","created-at":1593839075},{"example":"(map hash [nil true false -1 0 3.14 :a \"foo\" [1 2 3] {:a 1} (fn [])])\u000D\u000A# => @[0 1 0 -1074790400 0 1244950043 -2107123988 -1254832049 -2021739803 -1395744911 53378043]","docstring":"\"\\n\\n    cfunction\\n\\n    (hash value)\\n    \\n    Gets a hash for any value. The hash is an integer can be used as a\\n    cheap hash function for all values. If two values are strictly equal,\\n    then they will have the same hash value.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"hash","created-at":1593838998},{"example":"# Note: the numbers may appear the same, but this is only due to printing truncation.\u000D\u000A1                             # => 1\u000D\u000A(math/next 1 math/inf)        # => 1\u000D\u000A(< 1 1)                       # => false\u000D\u000A(< 1 (math/next 1 math/inf))  # => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/next x y)\\n    \\n    Returns the next representable floating point value after x in the\\n    direction of y.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/next","created-at":1593838919},{"example":"(math/exp2 8)  # => 256\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/exp2 x)\\n    \\n    Returns 2 to the power of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/exp2","created-at":1593838757},{"example":"(math/exp 1)  # => 2.71828\u000D\u000Amath/e        # => 2.71828","docstring":"\"\\n\\n    cfunction\\n\\n    (math/exp x)\\n    \\n    Returns e to the power of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/exp","created-at":1593838710},{"example":"(math/hypot 1 1)  # => 1.41421\u000D\u000A(math/sqrt 2)     # => 1.41421\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/hypot a b)\\n    \\n    Returns the c from the equation c^2 = a^2 + b^2\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/hypot","created-at":1593838611},{"example":"(os/time)  # => 1593838384\u000D\u000A(os/date)  # => {:month 6 :dst false :year-day 185 :seconds 8 :minutes 53 :week-day 6 :year 2020 :hours 4 :month-day 3}\u000D\u000A(os/mktime (os/date))  # => 1593838390\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/mktime date-struct &opt local)\\n    \\n    Get the broken down date-struct time expressed as the number of\\n    seconds since January 1, 1970, the Unix epoch. Returns a real number.\\n    Date is given in UTC unless local is truthy, in which case the date is\\n    computed for the local timezone.\\n    \\n    Inverse function to os/date.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/mktime","created-at":1593838432},{"example":"(os/sleep 1)    # => nil\u000D\u000A(os/sleep 0.1)  # => nil\u000D\u000A(os/sleep 0)    # => nil\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/sleep nsec)\\n    \\n    Suspend the program for nsec seconds. 'nsec' can be a real number.\\n    Returns nil.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/sleep","created-at":1593838322},{"example":"(os/date)\u000D\u000A# => {:month 6 :dst false :year-day 185 :seconds 38 :minutes 44 :week-day 6 :year 2020 :hours 4 :month-day 3}","docstring":"\"\\n\\n    cfunction\\n\\n    (os/date &opt time local)\\n    \\n    Returns the given time as a date struct, or the current time if no\\n    time is given. Returns a struct with following key values. Note that\\n    all numbers are 0-indexed. Date is given in UTC unless local is truthy,\\n    in which case the date is formatted for the local timezone.\\n    \\n      :seconds - number of seconds [0-61]\\n      :minutes - number of minutes [0-59]\\n      :hours - number of hours [0-23]\\n      :month-day - day of month [0-30]\\n      :month - month of year [0, 11]\\n      :year - years since year 0 (e.g. 2019)\\n      :week-day - day of the week [0-6]\\n      :year-day - day of the year [0-365]\\n      :dst - If Day Light Savings is in effect\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/date","created-at":1593838228},{"example":"(def time (os/time))  # => 1593838001\u000D\u000A\u000D\u000A(os/date t)\u000D\u000A# => {:month 6 :dst false :year-day 185 :seconds 41 :minutes 46 :week-day 6 :year 2020 :hours 4 :month-day 3}\u000D\u000A(os/date t false)\u000D\u000A# => {:month 6 :dst false :year-day 185 :seconds 41 :minutes 46 :week-day 6 :year 2020 :hours 4 :month-day 3}\u000D\u000A\u000D\u000A(os/date t true)\u000D\u000A# => {:month 6 :dst true :year-day 184 :seconds 41 :minutes 46 :week-day 5 :year 2020 :hours 23 :month-day 2}\u000D\u000A(os/date t :local)\u000D\u000A# => {:month 6 :dst true :year-day 184 :seconds 41 :minutes 46 :week-day 5 :year 2020 :hours 23 :month-day 2}\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/date &opt time local)\\n    \\n    Returns the given time as a date struct, or the current time if no\\n    time is given. Returns a struct with following key values. Note that\\n    all numbers are 0-indexed. Date is given in UTC unless local is truthy,\\n    in which case the date is formatted for the local timezone.\\n    \\n      :seconds - number of seconds [0-61]\\n      :minutes - number of minutes [0-59]\\n      :hours - number of hours [0-23]\\n      :month-day - day of month [0-30]\\n      :month - month of year [0, 11]\\n      :year - years since year 0 (e.g. 2019)\\n      :week-day - day of the week [0-6]\\n      :year-day - day of the year [0-365]\\n      :dst - If Day Light Savings is in effect\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/date","created-at":1593838176},{"example":"$ janet -e '(os/exit 42)' ; echo $?\u000D\u000A42\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/exit &opt x)\\n    \\n    Exit from janet with an exit code equal to x. If x is not an integer,\\n    the exit with status equal the hash of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/exit","created-at":1593837847},{"example":"(os/cryptorand 1)  # => @\"\\n\"\u000D\u000A(os/cryptorand 1)  # => @\"<\"\u000D\u000A(os/cryptorand 1)  # => @\"\\xC0\"\u000D\u000A(os/cryptorand 1)  # => @\"\\x89\"\u000D\u000A\u000D\u000A(os/cryptorand 8)  # => @\"\\x87\\x13\\x99\\x95\\x10su\\e\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/cryptorand n &opt buf)\\n    \\n    Get or append n bytes of good quality random data provided by the OS.\\n    Returns a new buffer or buf.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/cryptorand","created-at":1593837735},{"example":"(os/which)  # => :macos","docstring":"\"\\n\\n    cfunction\\n\\n    (os/which)\\n    \\n    Check the current operating system. Returns one of:\\n    \\n      :windows\\n      :macos\\n      :web - Web assembly (emscripten)\\n      :linux\\n      :freebsd\\n      :openbsd\\n      :netbsd\\n      :posix - A POSIX compatible system (default)\\n    \\n    May also return a custom keyword specified at build time.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/which","created-at":1593837646},{"example":"(os/clock)  # => 1.59384e+09","docstring":"\"\\n\\n    cfunction\\n\\n    (os/clock)\\n    \\n    Return the number of seconds since some fixed point in time. The clock\\n    is guaranteed to be non decreasing in real time.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/clock","created-at":1593837602},{"example":"(os/time)  # => 1593837535","docstring":"\"\\n\\n    cfunction\\n\\n    (os/time)\\n    \\n    Get the current time expressed as the number of seconds since January\\n    1, 1970, the Unix epoch. Returns a real number.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/time","created-at":1593837547},{"example":"(defn recent-mods\u000D\u000A  \"List the files in the current directory which have changed within the last hour.\"\u000D\u000A  []\u000D\u000A  (filter\u000D\u000A    (fn [fname]\u000D\u000A      (<\u000D\u000A        (- (os/time) 3600)\u000D\u000A        (os/stat fname :modified)))\u000D\u000A    (os/dir \".\")))\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/stat path &opt tab|key)\\n    \\n    Gets information about a file or directory. Returns a table If the\\n    third argument is a keyword, returns only that information from stat.\\n    If the file or directory does not exist, returns nil. The keys are\\n    \\n      :dev - the device that the file is on\\n      :mode - the type of file, one of :file, :directory, :block,\\n    :character, :fifo, :socket, :link, or :other\\n      :int-permissions - A Unix permission integer like 8r744\\n      :permissions - A Unix permission string like \\\"rwxr--r--\\\"\\n      :uid - File uid\\n      :gid - File gid\\n      :nlink - number of links to file\\n      :rdev - Real device of file. 0 on windows.\\n      :size - size of file in bytes\\n      :blocks - number of blocks in file. 0 on windows\\n      :blocksize - size of blocks in file. 0 on windows\\n      :accessed - timestamp when file last accessed\\n      :changed - timestamp when file last changed (permissions changed)\\n      :modified - timestamp when file last modified (content changed)\\n    \\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/stat","created-at":1593837408},{"example":"(defn ls-sockets\u000D\u000A  \"List the sockets in the current directory.\"\u000D\u000A  []\u000D\u000A  (filter\u000D\u000A    (fn [fname] (= :socket (os/stat fname :mode)))\u000D\u000A    (os/dir \".\")))\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/stat path &opt tab|key)\\n    \\n    Gets information about a file or directory. Returns a table If the\\n    third argument is a keyword, returns only that information from stat.\\n    If the file or directory does not exist, returns nil. The keys are\\n    \\n      :dev - the device that the file is on\\n      :mode - the type of file, one of :file, :directory, :block,\\n    :character, :fifo, :socket, :link, or :other\\n      :int-permissions - A Unix permission integer like 8r744\\n      :permissions - A Unix permission string like \\\"rwxr--r--\\\"\\n      :uid - File uid\\n      :gid - File gid\\n      :nlink - number of links to file\\n      :rdev - Real device of file. 0 on windows.\\n      :size - size of file in bytes\\n      :blocks - number of blocks in file. 0 on windows\\n      :blocksize - size of blocks in file. 0 on windows\\n      :accessed - timestamp when file last accessed\\n      :changed - timestamp when file last changed (permissions changed)\\n      :modified - timestamp when file last modified (content changed)\\n    \\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/stat","created-at":1593837163},{"example":"(os/perm-string 420)    # => \"rw-r--r--\"\u000D\u000A(os/perm-string 8r644)  # => \"rw-r--r--\"\u000D\u000A(os/perm-string 493)    # => \"rwxr-xr-x\"\u000D\u000A(os/perm-string 8r755)  # => \"rwxr-xr-x\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/perm-string int)\\n    \\n    Convert a Unix octal permission value from a permission integer as\\n    returned by os/stat to a human readable string, that follows the\\n    formatting of unix tools like ls. Returns the string as a 9 character\\n    string of r, w, x and - characters. Does not include the\\n    file/directory/symlink character as rendered by `ls`.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/perm-string","created-at":1593836476},{"example":"(os/perm-int \"rw-r--r--\")  # => 420\u000D\u000A(os/perm-int \"rwxr-xr-x\")  # => 493\u000D\u000A\u000D\u000A# note:\u000D\u000A8r644  # => 420\u000D\u000A8r755  # => 493\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/perm-int bytes)\\n    \\n    Parse a 9 character permission string and return an integer that can\\n    be used by chmod.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/perm-int","created-at":1593836300},{"example":"(spit \"/tmp/hello.sh\" \"#!/bin/bash\\necho 'Hello from Bash!'\\n\")\u000D\u000A(os/chmod \"/tmp/hello.sh\" \"rwx------\")\u000D\u000A(os/setenv \"PATH\" (string (os/getenv \"PATH\") \":/tmp\"))\u000D\u000A(os/shell \"hello.sh\")","docstring":"\"\\n\\n    cfunction\\n\\n    (os/chmod path mode)\\n    \\n    Change file permissions, where mode is a permission string as returned\\n    by os/perm-string, or an integer as returned by os/perm-int. When mode\\n    is an integer, it is interpreted as a Unix permission value, best\\n    specified in octal, like 8r666 or 8r400. Windows will not differentiate\\n    between user, group, and other permissions, and thus will combine all\\n    of these permissions. Returns nil.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/chmod","created-at":1593836181},{"example":"(os/shell \"touch foo\")\u000D\u000A(os/stat \"foo\" :modified)  # => 1593836002\u000D\u000A(os/touch \"foo\")\u000D\u000A(os/stat \"foo\" :modified)  # => 1593836013","docstring":"\"\\n\\n    cfunction\\n\\n    (os/stat path &opt tab|key)\\n    \\n    Gets information about a file or directory. Returns a table If the\\n    third argument is a keyword, returns only that information from stat.\\n    If the file or directory does not exist, returns nil. The keys are\\n    \\n      :dev - the device that the file is on\\n      :mode - the type of file, one of :file, :directory, :block,\\n    :character, :fifo, :socket, :link, or :other\\n      :int-permissions - A Unix permission integer like 8r744\\n      :permissions - A Unix permission string like \\\"rwxr--r--\\\"\\n      :uid - File uid\\n      :gid - File gid\\n      :nlink - number of links to file\\n      :rdev - Real device of file. 0 on windows.\\n      :size - size of file in bytes\\n      :blocks - number of blocks in file. 0 on windows\\n      :blocksize - size of blocks in file. 0 on windows\\n      :accessed - timestamp when file last accessed\\n      :changed - timestamp when file last changed (permissions changed)\\n      :modified - timestamp when file last modified (content changed)\\n    \\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/stat","created-at":1593836066},{"example":"(os/shell \"touch foo\")\u000D\u000A(os/stat \"foo\" :modified)  # => 1593836002\u000D\u000A(os/touch \"foo\")\u000D\u000A(os/stat \"foo\" :modified)  # => 1593836013","docstring":"\"\\n\\n    cfunction\\n\\n    (os/touch path &opt actime modtime)\\n    \\n    Update the access time and modification times for a file. By default,\\n    sets times to the current time.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/touch","created-at":1593836029},{"example":"# note that os/touch does not create a file if it does not yet exist.\u000D\u000A(os/touch \"foo\")\u000D\u000Aerror: No such file or directory\u000D\u000A  in os/touch\u000D\u000A  in _thunk [repl] (tailcall) on line 2, column 1\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/touch path &opt actime modtime)\\n    \\n    Update the access time and modification times for a file. By default,\\n    sets times to the current time.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/touch","created-at":1593835730},{"example":"(os/dir \".\")              # => @[\"foo\" \"bar\"]\u000D\u000A(os/rename \"bar\" \"bar2\")  # => nil\u000D\u000A(os/dir \".\")              # => @[\"bar2\" \"foo\"]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/rename oldname newname)\\n    \\n    Rename a file on disk to a new path. Returns nil.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/rename","created-at":1593835155},{"example":"(os/dir \"./\")                   # => @[]\u000D\u000A(os/shell \"touch foo bar baz\")  # => nil\u000D\u000A(os/dir \"./\")                   # => @[\"foo\" \"bar\" \"baz\"]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/dir dir &opt array)\\n    \\n    Iterate over files and subdirectories in a directory. Returns an array\\n    of paths parts, with only the file name or directory name and no\\n    prefix.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/dir","created-at":1593834910},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A# note that os/cd does not appear to update PWD in the shell's environment.\u000D\u000A(os/cwd)           # => \"/Users/cell/tmp\"\u000D\u000A(os/getenv \"PWD\")  # => \"/Users/cell/tmp\"\u000D\u000A(os/cd \"/tmp\")     # => nil\u000D\u000A(os/cwd)           # => \"/private/tmp\"  (on Apple, /tmp is actually /private/tmp)\u000D\u000A(os/getenv \"PWD\")  # => \"/Users/cell/tmp\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/cd path)\\n    \\n    Change current directory to path. Returns nil on success, errors on\\n    failure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/cd","created-at":1593834258},{"example":"(os/cwd)  # => \"/Users/cell/tmp\"\u000D\u000A(os/getenv \"PWD\")  # => \"/Users/cell/tmp\"\u000D\u000A(get (os/environ) \"PWD\")  # => \"/Users/cell/tmp\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/cwd)\\n    \\n    Returns the current working directory.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/cwd","created-at":1593833973},{"example":"(os/shell \"uptime > /tmp/uptime.txt\")  # => 0\u000D\u000A(slurp \"/tmp/uptime.txt\")\u000D\u000A# => @\"22:33  up 5 days,  9:34, 15 users, load averages: 1.93 1.74 1.59\\n\"\u000D\u000A(os/rm \"/tmp/uptime.txt\")  # => nil","docstring":"\"\\n\\n    cfunction\\n\\n    (os/readlink path)\\n    \\n    Read the contents of a symbolic link. Does not work on Windows.\\n    \\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/readlink","created-at":1593833794},{"example":"(os/shell \"uptime > /tmp/uptime.txt\")  # => 0\u000D\u000A(slurp \"/tmp/uptime.txt\")\u000D\u000A# => @\"22:33  up 5 days,  9:34, 15 users, load averages: 1.93 1.74 1.59\\n\"\u000D\u000A(os/rm \"/tmp/uptime.txt\")  # => nil","docstring":"\"\\n\\n    cfunction\\n\\n    (os/shell str)\\n    \\n    Pass a command string str directly to the system shell.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/shell","created-at":1593833702},{"example":"(os/shell \"uptime\")  # => 0\u000D\u000A# printed to the console:\u000D\u000A22:30  up 5 days,  9:31, 15 users, load averages: 1.48 1.50 1.49\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/shell str)\\n    \\n    Pass a command string str directly to the system shell.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/shell","created-at":1593833495},{"example":"(spit \"/tmp/hello.sh\" \"#!/bin/bash\\necho 'Hello from Bash!'\\n\")\u000D\u000A(os/chmod \"/tmp/hello.sh\" \"rwx------\")\u000D\u000A(os/setenv \"PATH\" (string (os/getenv \"PATH\") \":/tmp\"))\u000D\u000A(os/shell \"hello.sh\")\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/setenv variable value)\\n    \\n    Set an environment variable.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/setenv","created-at":1593833227},{"example":"(get (os/environ) \"HOME\")  # => \"/Users/cell\"\u000D\u000A(os/getenv \"HOME\")  # => \"/Users/cell\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/environ)\\n    \\n    Get a copy of the os environment table.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/environ","created-at":1593832465},{"example":"# on a Core i5-4590:\u000D\u000A(os/arch)  # => :x64\u000D\u000A\u000D\u000A# on an Intel Atom N270:\u000D\u000A(os/arch)  # => :x86\u000D\u000A\u000D\u000A# on a raspberry pi:\u000D\u000A(os/arch)  # => :arm","docstring":"\"\\n\\n    cfunction\\n\\n    (os/arch)\\n    \\n    Check the ISA that janet was compiled for. Returns one of:\\n    \\n      :x86\\n      :x86-64\\n      :arm\\n      :aarch64\\n      :sparc\\n      :wasm\\n      :unknown\\n    \\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/arch","created-at":1593832312},{"example":"# in a terminal:\u000D\u000A# $ while true; do date | nc 0.0.0.0 1234 -w 1; sleep 1; done\u000D\u000A\u000D\u000A# in a janet repl:\u000D\u000A(net/server \"0.0.0.0\" 1234\u000D\u000A  (fn [conn]\u000D\u000A    (prin (net/read conn 4096))\u000D\u000A    (net/close conn)))\u000D\u000A# note: output doesn't actually start until you (quit) your repl's fiber:\u000D\u000A(quit)\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (net/read stream nbytes &opt buf)\\n    \\n    Read up to n bytes from a stream, suspending the current fiber until\\n    the bytes are available. If less than n bytes are available (and more\\n    than 0), will push those bytes and return early. Returns a buffer with\\n    up to n more bytes in it, or raises an error if the read failed.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"net/read","created-at":1593831884},{"example":"# note, if running a server from the repl, you need to (quit) your repl.\u000D\u000A\u000D\u000A# in a terminal:\u000D\u000A# $ while true; do date | nc 0.0.0.0 1234 -w 1; sleep 1; done\u000D\u000A\u000D\u000A# in a janet repl:\u000D\u000A(net/server \"0.0.0.0\" 1234\u000D\u000A  (fn [conn]\u000D\u000A    (prin (net/read conn 4096))\u000D\u000A    (net/close conn)))\u000D\u000A# output doesn't actually start until you (quit) your repl's fiber:\u000D\u000A(quit)\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (net/server host port handler)\\n    \\n    Start a TCP server. handler is a function that will be called with a\\n    stream on each connection to the server. Returns a new stream that is\\n    neither readable nor writeable.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"net/server","created-at":1593831829},{"example":"$ # trivial server which echo's to the console.\u000D\u000A$ cat > srv.janet << EOF\u000D\u000A#!/usr/bin/env janet\u000D\u000A\u000D\u000A(defn handle-conn [conn]\u000D\u000A  (print \"new connection\")\u000D\u000A  (while true\u000D\u000A    (def data (net/read conn 4096))\u000D\u000A    (if (not data) (break))\u000D\u000A    (prin data))\u000D\u000A  (net/close conn)\u000D\u000A  (print \"connection closed\"))\u000D\u000A\u000D\u000A(print \"starting server on 0.0.0.0:1234\")\u000D\u000A(net/server \"0.0.0.0\" 1234 handle-conn)\u000D\u000AEOF\u000D\u000A$ chmod +x srv.janet\u000D\u000A$ ./srv.janet\u000D\u000A\u000D\u000A----\u000D\u000A\u000D\u000A$ # in another terminal:\u000D\u000A$ echo hello | nc 0.0.0.0 1234\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (net/server host port handler)\\n    \\n    Start a TCP server. handler is a function that will be called with a\\n    stream on each connection to the server. Returns a new stream that is\\n    neither readable nor writeable.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"net/server","created-at":1593831081},{"example":"#!/usr/bin/env janet\u000D\u000A# echo stdin to stdout.\u000D\u000A(file/write stdout (file/read stdin :all))\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (file/write f bytes)\\n    \\n    Writes to a file. 'bytes' must be string, buffer, or symbol. Returns\\n    the file.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"file/write","created-at":1593798053},{"example":"#!/usr/bin/env janet\u000D\u000A# echo stdin to stdout.\u000D\u000A(file/write stdout (file/read stdin :all))\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (file/read f what &opt buf)\\n    \\n    Read a number of bytes from a file into a buffer. A buffer can be\\n    provided as an optional fourth argument, otherwise a new buffer is\\n    created. 'what' can either be an integer or a keyword. Returns the\\n    buffer with file contents. Values for 'what':\\n    \\n      :all - read the whole file\\n      :line - read up to and including the next newline character\\n      n (integer) - read up to n bytes from the file\\n\\n\\n\"","gh-username":"cellularmitosis","name":"file/read","created-at":1593798040},{"example":"(defn spit-lines [path lines]\u000D\u000A  (spit path (string/join lines \"\\n\")))","docstring":"\"\\n\\n    cfunction\\n\\n    (string/join parts &opt sep)\\n    \\n    Joins an array of strings into one string, optionally separated by a\\n    separator string sep.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/join","created-at":1593797308},{"example":"(defn slurp-lines [path]\u000D\u000A  (string/split \"\\n\" (slurp path)))","docstring":"\"\\n\\n    cfunction\\n\\n    (string/split delim str &opt start limit)\\n    \\n    Splits a string str with delimiter delim and returns an array of\\n    substrings. The substrings will not contain the delimiter delim. If\\n    delim is not found, the returned array will have one element. Will\\n    start searching for delim at the index start (if provided), and return\\n    up to a maximum of limit results (if provided).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/split","created-at":1593797280},{"example":"# foo.txt is a file with contents \"hello\\nworld\\n\".\u000D\u000A(slurp \"foo.txt\")  # => @\"hello\\nworld\\n\"\u000D\u000A(string/split \"\\n\" (slurp \"foo.txt\"))  # => @[\"hello\" \"world\" \"\"]\u000D\u000A\u000D\u000A(defn slurp-lines [path]\u000D\u000A  (string/split \"\\n\" (slurp path)))\u000D\u000A\u000D\u000A(slurp-lines \"foo.txt\")  # => @[\"hello\" \"world\" \"\"]\u000D\u000A\u000D\u000A(string/join @[\"hello\" \"world\" \"\"] \"\\n\")  # => \"hello\\nworld\\n\"\u000D\u000A(spit \"foo2.txt\" (string/join @[\"hello\" \"world\" \"\"] \"\\n\"))\u000D\u000A# The contents of foo.txt and foo2.txt are now identical.\u000D\u000A\u000D\u000A(defn spit-lines [path lines]\u000D\u000A  (spit path (string/join lines \"\\n\")))\u000D\u000A\u000D\u000A(spit-lines \"foo3.txt\" (slurp-lines \"foo.txt\"))\u000D\u000A# The contents of foo.txt and foo3.txt are now identical.\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1499, column 1\\n\\n    (spit path contents &opt mode)\\n    \\n    Write contents to a file at path. Can optionally append to the file.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"spit","created-at":1593797216},{"example":"# foo.txt is a file with contents \"hello\\nworld\\n\".\u000D\u000A(slurp \"foo.txt\")  # => @\"hello\\nworld\\n\"\u000D\u000A(string/split \"\\n\" (slurp \"foo.txt\"))  # => @[\"hello\" \"world\" \"\"]\u000D\u000A\u000D\u000A(defn slurp-lines [path]\u000D\u000A  (string/split \"\\n\" (slurp path)))\u000D\u000A\u000D\u000A(slurp-lines \"foo.txt\")  # => @[\"hello\" \"world\" \"\"]\u000D\u000A\u000D\u000A(string/join @[\"hello\" \"world\" \"\"] \"\\n\")  # => \"hello\\nworld\\n\"\u000D\u000A(spit \"foo2.txt\" (string/join @[\"hello\" \"world\" \"\"] \"\\n\"))\u000D\u000A# The contents of foo.txt and foo2.txt are now identical.\u000D\u000A\u000D\u000A(defn spit-lines [path lines]\u000D\u000A  (spit path (string/join lines \"\\n\")))\u000D\u000A\u000D\u000A(spit-lines \"foo3.txt\" (slurp-lines \"foo.txt\"))\u000D\u000A# The contents of foo.txt and foo3.txt are now identical.\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1489, column 1\\n\\n    (slurp path)\\n    \\n    Read all data from a file with name path and then close the file.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"slurp","created-at":1593797178},{"example":"# './foo.janet' is a file with contents '(def bar 42)'.\u000D\u000A(use foo)\u000D\u000Abar  # => 42","docstring":"\"\\n\\n    macro\\n    boot.janet on line 2487, column 1\\n\\n    (use & modules)\\n    \\n    Similar to import, but imported bindings are not prefixed with a\\n    namespace identifier. Can also import multiple modules in one shot.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"use","created-at":1593795827},{"example":"(extreme < [1 2 3])  # => 1\u000D\u000A(extreme > [1 2 3])  # => 3\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 675, column 1\\n\\n    (extreme order args)\\n    \\n    Returns the most extreme value in args based on the function order.\\n    order should take two values and return true or false (a comparison).\\n    Returns nil if args is empty.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"extreme","created-at":1593744407},{"example":"(distinct [1 1 2 3])  # => @[1 2 3]\u000D\u000A\u000D\u000A(distinct \"hello\")  # => @[104 101 108 111]\u000D\u000A(string/from-bytes (splice (distinct \"hello\")))  # => \"helo\"\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1423, column 1\\n\\n    (distinct xs)\\n    \\n    Returns an array of the deduplicated values in xs.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"distinct","created-at":1593744060},{"example":"(chr \"a\")  # => 97","docstring":"\"\\n\\n    macro\\n    boot.janet on line 334, column 1\\n\\n    (chr c)\\n    \\n    Convert a string of length 1 to its byte (ascii) value at compile\\n    time.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"chr","created-at":1593743441},{"example":"(string/bytes \"foo\")  # => (102 111 111)\u000D\u000A(string/from-bytes 102 111 111)  # => \"foo\"\u000D\u000A(string/from-bytes (splice (string/bytes \"foo\")))  # => \"foo\"\u000D\u000A\u000D\u000A(map (fn [x] x)        \"foo\")  # => @[102 111 111]\u000D\u000A(map string/from-bytes \"foo\")  # => @[\"f\" \"o\" \"o\"]\u000D\u000A\u000D\u000A(defn string/explode [s] (map string/from-bytes s))\u000D\u000A(string/explode \"foo\")  # => @[\"f\" \"o\" \"o\"]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (string/from-bytes & byte-vals)\\n    \\n    Creates a string from integer parameters with byte values. All\\n    integers will be coerced to the range of 1 byte 0-255.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/from-bytes","created-at":1593743252},{"example":"(filter  even?                     [1 2 3 4 5])  # => @[2 4]\u000D\u000A(filter  odd?                      [1 2 3 4 5])  # => @[1 3 5]\u000D\u000A(filter  (fn [x] (not (even? x)))  [1 2 3 4 5])  # => @[1 3 5]\u000D\u000A(filter  (complement even?)        [1 2 3 4 5])  # => @[1 3 5]\u000D\u000A\u000D\u000A(def fns [even? odd?])\u000D\u000A(map  (fn [f] (filter f [-2 -1 0 1 2]))  fns)  # => @[ @[-2 0 2] @[-1 1]   ]\u000D\u000A(def fns (map complement fns))\u000D\u000A(map  (fn [f] (filter f [-2 -1 0 1 2]))  fns)  # => @[ @[-1 1]   @[-2 0 2] ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 670, column 1\\n\\n    (complement f)\\n    \\n    Returns a function that is the complement to the argument.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"complement","created-at":1593741016},{"example":"(count even? [1 2 3 4 5])  # => 2\u000D\u000A\u000D\u000A(count  (fn [x] (> x 3))  [1 2 3 4 5])  # => 2\u000D\u000A(count         |(> $ 3)   [1 2 3 4 5])  # => 2\u000D\u000A\u000D\u000A(count  (fn [x] (truthy? x))  [nil false true 42 :a \"foo\"])  # => 4\u000D\u000A(count         |(truthy? $)   [nil false true 42 :a \"foo\"])  # => 4\u000D\u000A\u000D\u000A(var f even?)\u000D\u000A(count f [1 2 3 4 5])  # => 2\u000D\u000A(set f odd?)\u000D\u000A(count f [1 2 3 4 5])  # => 3\u000D\u000A\u000D\u000A(map  (fn [f] (count f [1 2 3 4 5]))  [even? odd?])  # => @[2 3]\u000D\u000A(map         |(count $ [1 2 3 4 5])   [even? odd?])  # => @[2 3]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 901, column 1\\n\\n    (count pred ind)\\n    \\n    Count the number of items in ind for which (pred item) is true.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"count","created-at":1593739967},{"example":"[1 2 3]               # => (1 2 3)\u000D\u000A(tuple/type [1 2 3])  # => :parens\u000D\u000A\u000D\u000A(tuple/brackets 1 2 3)               # => [1 2 3]\u000D\u000A(tuple/type (tuple/brackets 1 2 3))  # => :brackets\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (tuple/type tup)\\n    \\n    Checks how the tuple was constructed. Will return the keyword\\n    :brackets if the tuple was parsed with brackets, and :parens otherwise.\\n    The two types of tuples will behave the same most of the time, but will\\n    print differently and be treated differently by the compiler.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"tuple/type","created-at":1593723063},{"example":"[1 2 3]                  # => (1 2 3)\u000D\u000A(tuple 1 2 3)            # => (1 2 3)\u000D\u000A(tuple (splice [1 2 3])  # => (1 2 3)\u000D\u000A(tuple ;[1 2 3])         # => (1 2 3)\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (tuple & items)\\n    \\n    Creates a new tuple that contains items. Returns the new tuple.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"tuple","created-at":1593722474},{"example":"(array 1 2.3 :a \"foo\" true nil [] {} (fn []))\u000D\u000A# => @[1 2.3 :a \"foo\" true nil () {} <function 0x7FB2A3F02170>]","docstring":"\"\\n\\n    cfunction\\n\\n    (array & items)\\n    \\n    Create a new array that contains items. Returns the new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array","created-at":1593722142},{"example":"(tuple 1 2.3 :a \"foo\" true nil [] {} (fn []))\u000D\u000A# =>  (1 2.3 :a \"foo\" true nil () {} <function 0x7FB2A3D030B0>)\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (tuple & items)\\n    \\n    Creates a new tuple that contains items. Returns the new tuple.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"tuple","created-at":1593722084},{"example":"(tuple/slice [:a :b :c :d])  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(tuple/slice [:a :b :c :d] 0)  # => (:a :b :c :d)\u000D\u000A(tuple/slice [:a :b :c :d] 1)  # => (:b :c :d)\u000D\u000A(tuple/slice [:a :b :c :d] 3)  # => (:d)\u000D\u000A(tuple/slice [:a :b :c :d] 4)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] 5)  # error: index out of range\u000D\u000A\u000D\u000A(tuple/slice [:a :b :c :d] -1)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] -2)  # => (:d)\u000D\u000A(tuple/slice [:a :b :c :d] -4)  # => (:b :c :d)\u000D\u000A(tuple/slice [:a :b :c :d] -5)  # => (:a :b :c :d)\u000D\u000A(tuple/slice [:a :b :c :d] -6)  # error: index out of range\u000D\u000A\u000D\u000A(tuple/slice [:a :b :c :d] 0 0)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] 0 1)  # => (:a)\u000D\u000A(tuple/slice [:a :b :c :d] 0 4)  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(tuple/slice [:a :b :c :d] -1 -1)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] -2 -1)  # => (:d)\u000D\u000A(tuple/slice [:a :b :c :d] -5 -1)  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(tuple/slice [:a :b :c :d] 1 0)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] 4 0)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] -1 -2)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] -1 -5)  # => ()","docstring":"\"\\n\\n    cfunction\\n\\n    (tuple/slice arrtup [,start=0 [,end=(length arrtup)]])\\n    \\n    Take a sub sequence of an array or tuple from index start inclusive to\\n    index end exclusive. If start or end are not provided, they default to\\n    0 and the length of arrtup respectively. 'start' and 'end' can also be\\n    negative to indicate indexing from the end of the input. Note that\\n    index -1 is synonymous with index '(length arrtup)' to allow a full\\n    negative slice range. Returns the new tuple.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"tuple/slice","created-at":1593721826},{"example":"(slice [:a :b :c :d])  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(slice [:a :b :c :d] 0)  # => (:a :b :c :d)\u000D\u000A(slice [:a :b :c :d] 1)  # => (:b :c :d)\u000D\u000A(slice [:a :b :c :d] 3)  # => (:d)\u000D\u000A(slice [:a :b :c :d] 4)  # => ()\u000D\u000A(slice [:a :b :c :d] 5)  # error: index out of range\u000D\u000A\u000D\u000A(slice [:a :b :c :d] -1)  # => ()\u000D\u000A(slice [:a :b :c :d] -2)  # => (:d)\u000D\u000A(slice [:a :b :c :d] -4)  # => (:b :c :d)\u000D\u000A(slice [:a :b :c :d] -5)  # => (:a :b :c :d)\u000D\u000A(slice [:a :b :c :d] -6)  # error: index out of range\u000D\u000A\u000D\u000A(slice [:a :b :c :d] 0 0)  # => ()\u000D\u000A(slice [:a :b :c :d] 0 1)  # => (:a)\u000D\u000A(slice [:a :b :c :d] 0 4)  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(slice [:a :b :c :d] -1 -1)  # => ()\u000D\u000A(slice [:a :b :c :d] -2 -1)  # => (:d)\u000D\u000A(slice [:a :b :c :d] -5 -1)  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(slice [:a :b :c :d] 1 0)  # => ()\u000D\u000A(slice [:a :b :c :d] 4 0)  # => ()\u000D\u000A(slice [:a :b :c :d] -1 -2)  # => ()\u000D\u000A(slice [:a :b :c :d] -1 -5)  # => ()\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (slice x &opt start end)\\n    \\n    Extract a sub-range of an indexed data structure or byte sequence.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"slice","created-at":1593721330},{"example":"(string \"hello\" nil true 42 :bar)  # => \"helloniltrue42bar\"\u000D\u000A(string :a :b :c)  # => \"abc\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (string & parts)\\n    \\n    Creates a string by concatenating values together. Values are\\n    converted to bytes via describe if they are not byte sequences. Returns\\n    the new string.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string","created-at":1593719381},{"example":"(string? \"hello\")   # => true\u000D\u000A(string? @\"hello\")  # => false\u000D\u000A(string? :hello)    # => false\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 88, column 1\\n\\n    (string? x)\\n    \\n    Check if x is a string.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string?","created-at":1593719302},{"example":"(symbol \"foo\")  # => foo\u000D\u000A\u000D\u000A(def a \"foo\")\u000D\u000A(symbol a)         # => foo\u000D\u000A(symbol a 42 nil)  # => foo42nil\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (symbol & xs)\\n    \\n    Creates a symbol by concatenating values together. Values are\\n    converted to bytes via describe if they are not byte sequences. Returns\\n    the new symbol.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"symbol","created-at":1593719018},{"example":"(symbol? sum)          # => false\u000D\u000A(symbol? (quote sum))  # => true\u000D\u000A(symbol? 'sum)         # => true\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 89, column 1\\n\\n    (symbol? x)\\n    \\n    Check if x is a symbol.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"symbol?","created-at":1593718739},{"example":"(array/slice @[1 2 3] 0 0)  # => @[]\u000D\u000A(array/slice @[1 2 3] 0 1)  # => @[1]\u000D\u000A(array/slice @[1 2 3] 0 2)  # => @[1 2]\u000D\u000A(array/slice @[1 2 3] 0 3)  # => @[1 2 3]\u000D\u000A(array/slice @[1 2 3] 0 4)  # error: index out of range\u000D\u000A\u000D\u000A(array/slice @[1 2 3] 1 1)  # => @[]\u000D\u000A(array/slice @[1 2 3] 1 2)  # => @[2]\u000D\u000A\u000D\u000A(array/slice @[1 2 3] 0 -1)  # => @[1 2 3]\u000D\u000A(array/slice @[1 2 3] 0 -2)  # => @[1 2]\u000D\u000A(array/slice @[1 2 3] 0 -3)  # => @[1]\u000D\u000A(array/slice @[1 2 3] 0 -4)  # => @[]\u000D\u000A(array/slice @[1 2 3] 0 -5)  # error: index out of range\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/slice arrtup &opt start end)\\n    \\n    Takes a slice of array or tuple from start to end. The range is half\\n    open, [start, end). Indexes can also be negative, indicating indexing\\n    from the end of the end of the array. By default, start is 0 and end is\\n    the length of the array. Note that index -1 is synonymous with index\\n    (length arrtup) to allow a full negative slice range. Returns a new\\n    array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/slice","created-at":1593646470},{"example":"(map indexed?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     true      false        false         ]\u000D\u000A\u000D\u000A(map tuple?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     false     false        false         ]\u000D\u000A\u000D\u000A(map array?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    true      false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 97, column 1\\n\\n    (array? x)\\n    \\n    Check if x is an array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array?","created-at":1593645898},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(array/remove @[1 2 3] 0)  # => @[2 3]\u000D\u000A(array/remove @[1 2 3] 1)  # => @[1 3]\u000D\u000A(array/remove @[1 2 3] 2)  # => @[1 2]\u000D\u000A(array/remove @[1 2 3] 3)  # => @[1 2 3]\u000D\u000A(array/remove @[1 2 3] 4)  # error: index out of range\u000D\u000A\u000D\u000A(array/remove @[1 2 3] -1)  # => @[1 2 3]\u000D\u000A(array/remove @[1 2 3] -2)  # => @[1 2]\u000D\u000A(array/remove @[1 2 3] -3)  # => @[1 3]\u000D\u000A(array/remove @[1 2 3] -4)  # => @[2 3]\u000D\u000A(array/remove @[1 2 3] -5)  # error: index out of range\u000D\u000A\u000D\u000A(array/remove @[1 2 3 4] 1 1)   # => @[1 3 4]\u000D\u000A(array/remove @[1 2 3 4] 1 2)   # => @[1 4]\u000D\u000A(array/remove @[1 2 3 4] 1 3)   # => @[1]\u000D\u000A(array/remove @[1 2 3 4] 1 4)   # => @[1]\u000D\u000A(array/remove @[1 2 3 4] 1 99)  # => @[1]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/remove arr at &opt n)\\n    \\n    Remove up to n elements starting at index at in array arr. at can\\n    index from the end of the array with a negative index, and n must be a\\n    non-negative integer. By default, n is 1. Returns the array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/remove","created-at":1593645607},{"example":"(def a @[])\u000D\u000A(array/push a 1)  # => @[1]\u000D\u000Aa                 # => @[1]\u000D\u000A(array/push a 2)  # => @[1 2]\u000D\u000Aa                 # => @[1 2]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/push arr x)\\n    \\n    Insert an element in the end of an array. Modifies the input array and\\n    returns it.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/push","created-at":1593644174},{"example":"(def a @[1 2])\u000D\u000A(array/pop a)  # => 2\u000D\u000Aa              # => @[1]\u000D\u000A(array/pop a)  # => 1\u000D\u000Aa              # => @[]\u000D\u000A(array/pop a)  # => nil\u000D\u000Aa              # => @[]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/pop arr)\\n    \\n    Remove the last element of the array and return it. If the array is\\n    empty, will return nil. Modifies the input array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/pop","created-at":1593644073},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(array/peek @[])     # => nil\u000D\u000A(array/peek @[1])    # => 1\u000D\u000A(array/peek @[1 2])  # => 2\u000D\u000A\u000D\u000A(array/peek [1 2])           # error: expected array, got tuple\u000D\u000A(array/peek (array [1 2]))   # => (1 2)\u000D\u000A(array/peek (array ;[1 2]))  # => 2\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/peek arr)\\n    \\n    Returns the last element of the array. Does not modify the array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/peek","created-at":1593643949},{"example":"(parse \"[:a :b :c]\") # => [:a :b :c]","docstring":"\"\\n\\n    function\\n    boot.janet on line 2232, column 1\\n\\n    (parse str)\\n    \\n    Parse a string and return the first value. For complex parsing, such\\n    as for a repl with error handling, use the parser api.\\n\\n\\n\"","gh-username":"sogaiu","name":"parse","created-at":1593643939},{"example":"# note that 'not' works as an implementation of 'falsey?'\u000D\u000A(map not     [ nil   false true  0     1     'a    :a    \"a\"   []    {}    (fn []) ])\u000D\u000A# =>        @[ true  true  false false false false false false false false false   ]\u000D\u000A\u000D\u000A(map truthy? [ nil   false true  0     1     'a    :a    \"a\"   []    {}    (fn []) ])\u000D\u000A# =>        @[ false false true  true  true  true  true  true  true  true  true    ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (not x)\\n    \\n    Returns the boolean inverse of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"not","created-at":1593643547},{"example":"(array/new-filled 3)     # => @[nil nil nil]\u000D\u000A(array/new-filled 3 :a)  # => @[:a :a :a]","docstring":"\"\\n\\n    cfunction\\n\\n    (array/new-filled count &opt value)\\n    \\n    Creates a new array of count elements, all set to value, which\\n    defaults to nil. Returns the new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/new-filled","created-at":1593643089},{"example":"(def a @[])\u000D\u000A(array/insert a  1 :a)  # error: index out of range\u000D\u000A(array/insert a -2 :a)  # error: index out of range\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/insert arr at & xs)\\n    \\n    Insert all xs into array arr at index at. at should be an integer\\n    between 0 and the length of the array. A negative value for at will\\n    index backwards from the end of the array, such that inserting at -1\\n    appends to the array. Returns the array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/insert","created-at":1593642907},{"example":"(def a @[1 6])                     # => @[1 6]\u000D\u000A(array/insert a 1 (splice [2 3]))  # => @[1 2 3 6]\u000D\u000A(array/insert a 3 ;[4 5])          # => @[1 2 3 4 5 6]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/insert arr at & xs)\\n    \\n    Insert all xs into array arr at index at. at should be an integer\\n    between 0 and the length of the array. A negative value for at will\\n    index backwards from the end of the array, such that inserting at -1\\n    appends to the array. Returns the array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/insert","created-at":1593642759},{"example":"(def a @[11 12])              # => @[11 12]\u000D\u000A(array/insert a 0 10)         # => @[10 11 12]\u000D\u000A(array/insert a 3 13)         # => @[10 11 12 13]\u000D\u000A(array/insert a -1 14)        # => @[10 11 12 13 14]\u000D\u000A(array/insert a -1 15 16 17)  # => @[10 11 12 13 14 15 16 17]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/insert arr at & xs)\\n    \\n    Insert all xs into array arr at index at. at should be an integer\\n    between 0 and the length of the array. A negative value for at will\\n    index backwards from the end of the array, such that inserting at -1\\n    appends to the array. Returns the array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/insert","created-at":1593642103},{"example":"(def a @[1 2])           # => @[1 2]\u000D\u000A(array/fill a @[3 4 5])  # => @[@[3 4 5] @[3 4 5]]\u000D\u000A(array/concat (0 a) 6)   # => @[3 4 5 6]\u000D\u000Aa                        # => @[@[3 4 5 6] @[3 4 5 6]]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/fill arr &opt value)\\n    \\n    Replace all elements of an array with value (defaulting to nil)\\n    without changing the length of the array. Returns the modified array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/fill","created-at":1593641392},{"example":"(def a @[1 2 3])\u000D\u000A(array/fill a 17)   # => @[17 17 17]\u000D\u000A(array/fill a \"n\")  # => @[\"b\" \"b\" \"b\"]\u000D\u000A(array/fill a)      # => @[nil nil nil]\u000D\u000Aa                   # => @[nil nil nil]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/fill arr &opt value)\\n    \\n    Replace all elements of an array with value (defaulting to nil)\\n    without changing the length of the array. Returns the modified array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/fill","created-at":1593641042},{"example":"(def a @[1 2])\u000D\u000A(def b @[1 2])\u000D\u000A(= a b)  # => false\u000D\u000A\u000D\u000A(def a @[1 2])\u000D\u000A(def b (array/concat a 3))\u000D\u000Aa        # => @[1 2 3]\u000D\u000Ab        # => @[1 2 3]\u000D\u000A(= a b)  # => true\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (= & xs)\\n    \\n    Check if all values in xs are equal. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"=","created-at":1593640605},{"example":"(def a @[1 2])\u000D\u000A(def b @[1 2])\u000D\u000A(= a b)  # => false\u000D\u000A\u000D\u000A(def a @[1 2])\u000D\u000A(def b (array/concat a 3))\u000D\u000Aa        # => @[1 2 3]\u000D\u000Ab        # => @[1 2 3]\u000D\u000A(= a b)  # => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/concat arr & parts)\\n    \\n    Concatenates a variable number of arrays (and tuples) into the first\\n    argument which must be an array. If any of the parts are arrays or\\n    tuples, their elements will be inserted into the array. Otherwise, each\\n    part in parts will be appended to arr in order. Return the modified\\n    array arr.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/concat","created-at":1593640565},{"example":"(def a @[1 2])\u000D\u000A(array/concat a 3 [4 5] @[6 7] [] @[] 8)\u000D\u000Aa  # => @[1 2 3 4 5 6 7 8]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/concat arr & parts)\\n    \\n    Concatenates a variable number of arrays (and tuples) into the first\\n    argument which must be an array. If any of the parts are arrays or\\n    tuples, their elements will be inserted into the array. Otherwise, each\\n    part in parts will be appended to arr in order. Return the modified\\n    array arr.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/concat","created-at":1593640280},{"example":"(map truthy? [ nil   false true  0     1     'a    :a    \"a\"   []    {}    (fn []) ])\u000D\u000A# =>        @[ false false true  true  true  true  true  true  true  true  true    ]\u000D\u000A\u000D\u000A# note that 'not' works as an implementation of 'falsey?'\u000D\u000A(map not     [ nil   false true  0     1     'a    :a    \"a\"   []    {}    (fn []) ])\u000D\u000A# =>        @[ true  true  false false false false false false false false false   ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 109, column 1\\n\\n    (truthy? x)\\n    \\n    Check if x is truthy.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"truthy?","created-at":1593639748},{"example":"@[1 2 3]                 # -> @[1 2 3]\u000D\u000A(array 1 2 3)            # -> @[1 2 3]\u000D\u000A(array (splice [1 2 3])  # -> @[1 2 3]\u000D\u000A(array ;[1 2 3])         # -> @[1 2 3]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array & items)\\n    \\n    Create a new array that contains items. Returns the new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array","created-at":1593639479},{"example":"(filter (partial string/has-prefix? \"z\") (all-bindings))  # => @[zero? zipcoll]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1644, column 1\\n\\n    (all-bindings &opt env local)\\n    \\n    Get all symbols available in an environment. Defaults to the current\\n    fiber's environment. If local is truthy, will not show inherited\\n    bindings (from prototype tables).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"all-bindings","created-at":1593639245},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(all pos? [1 2 3])     # => true\u000D\u000A(all pos? [1 2 3 -4])  # => false\u000D\u000A(all pos? [1 2 3 0])   # => false\u000D\u000A\u000D\u000A(all (partial string/has-prefix? \"a\") [\"aa\" \"ab\"])       # => true\u000D\u000A(all (partial string/has-prefix? \"a\") [\"aa\" \"ab\" \"bb\"])  # => false\u000D\u000A\u000D\u000A(all truthy? [1 2])              # => true\u000D\u000A(all truthy? [1 2 3])            # => true\u000D\u000A(all truthy? [1 2 nil 3])        # => false\u000D\u000A(all truthy? [1 false 2 nil 3])  # => false\u000D\u000A\u000D\u000A(all (fn [x] x) [1 2])              # => 2\u000D\u000A(all (fn [x] x) [1 2 3])            # => 3\u000D\u000A(all (fn [x] x) [1 2 nil 3])        # => nil\u000D\u000A(all (fn [x] x) [1 false 2 nil 3])  # => false\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1858, column 1\\n\\n    (all pred xs)\\n    \\n    Returns true if all xs are truthy, otherwise the result of first\\n    falsey predicate value, (pred x).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"all","created-at":1593638840},{"example":"(reduce2     + [1 2 3])  # -> 6\u000D\u000A(accumulate2 + [1 2 3])  # -> @[1 3 6]","docstring":"\"\\n\\n    function\\n    boot.janet on line 844, column 1\\n\\n    (accumulate2 f ind)\\n    \\n    The 2 argument version of accumulate that does not take an\\n    initialization value.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"accumulate2","created-at":1593637830},{"example":"(reduce     + 1 [2 3 4])  # -> 10\u000D\u000A(accumulate + 1 [2 3 4])  # -> @[3 6 10]","docstring":"\"\\n\\n    function\\n    boot.janet on line 833, column 1\\n\\n    (accumulate f init ind)\\n    \\n    Similar to reduce, but accumulates intermediate values into an array.\\n    The last element in the array is what would be the return value from\\n    reduce. The init value is not added to the array. Returns a new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"accumulate","created-at":1593637726},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(= :a :a)    # => true\u000D\u000A(= :a \"a\")   # => false\u000D\u000A(= :a \":a\")  # => false\u000D\u000A\u000D\u000A(= \"a\" \"a\")    # => true\u000D\u000A(= \"a\" @\"a\")   # => false\u000D\u000A(= @\"a\" @\"a\")  # => false\u000D\u000A\u000D\u000A(= [1 2] [1 2])    # => true\u000D\u000A(= [1 2] @[1 2])   # => false\u000D\u000A(= @[1 2] @[1 2])  # => false\u000D\u000A\u000D\u000A(= {:a 1} {:a 1})    # => true\u000D\u000A(= {:a 1} @{:a 1})   # => false\u000D\u000A(= @{:a 1} @{:a 1})  # => false\u000D\u000A\u000D\u000A(= (fn []) (fn []))  # => false\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (= & xs)\\n    \\n    Check if all values in xs are equal. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"=","created-at":1593634329},{"example":"(= 1 1)  # => true\u000D\u000A(= 1 2)  # => false\u000D\u000A\u000D\u000A(= 1.1 1.1)  # => true\u000D\u000A(= 1.1 1.2)  # => false\u000D\u000A\u000D\u000A(= 1 1.0)  # => true\u000D\u000A\u000D\u000A# these are representations of two different IEEE-754 64-bit buckets:\u000D\u000A(= \u000D\u000A 1.0000000000000001\u000D\u000A 1.0000000000000002)  # => false\u000D\u000A\u000D\u000A# these are two representations of the same IEEE-754 64-bit bucket:\u000D\u000A(= \u000D\u000A 1.00000000000000001\u000D\u000A 1.00000000000000002)  # => true\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (= & xs)\\n    \\n    Check if all values in xs are equal. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"=","created-at":1593633612},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A# non-numeric values appear to always be greater than numeric values\u000D\u000A(< math/inf nil)      # -> true\u000D\u000A(< math/inf true)     # -> true\u000D\u000A(< math/inf false)    # -> true\u000D\u000A(< math/inf \"hello\")  # -> true\u000D\u000A(< math/inf :heyo)    # -> true\u000D\u000A(< math/inf (fn []))  # -> true\u000D\u000A(< math/inf {:a 1})   # -> true\u000D\u000A\u000D\u000A# non-numeric values also follow an ordering.\u000D\u000A# rearranging any of these values turns the result false:\u000D\u000A(< nil false true \"a\" \"b\" :a :b [] [1] [1 1] [2] {} {:a 1} (fn []))  # -> true\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (< & xs)\\n    \\n    Check if xs is in ascending order. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"<","created-at":1593633243},{"example":"(<)        # -> true\u000D\u000A(< 1)      # -> true\u000D\u000A(< 1 2)    # -> true\u000D\u000A(< 2 1)    # -> false\u000D\u000A(< 1 2 3)  # -> true\u000D\u000A(< 1 3 2)  # -> false\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (< & xs)\\n    \\n    Check if xs is in ascending order. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"<","created-at":1593632564},{"example":"(defn return-nil [x] nil)\u000D\u000A(-?> 1 inc)                     # -> 2\u000D\u000A(-?> 1 inc inc)                 # -> 3\u000D\u000A(-?> 1 inc inc return-nil)      # -> nil\u000D\u000A(-?> 1 inc inc return-nil inc)  # -> nil\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1090, column 1\\n\\n    (-?> x & forms)\\n    \\n    Short circuit threading macro. Inserts x as the second value in the\\n    first form in forms, and inserts the modified first form into the\\n    second form in the same manner, and so on. The pipeline will return nil\\n    if an intermediate value is nil. Useful for expressing pipelines of\\n    data.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"-?>","created-at":1593632409},{"example":"(->  1 (< 2))   # -> true\u000D\u000A(->> 1 (< 2))   # -> false","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1077, column 1\\n\\n    (->> x & forms)\\n    \\n    Threading macro. Inserts x as the last value in the first form in\\n    forms, and inserts the modified first form into the second form in the\\n    same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"->>","created-at":1593631838},{"example":"(->  1 (< 2))   # -> true\u000D\u000A(->> 1 (< 2))   # -> false","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1064, column 1\\n\\n    (-> x & forms)\\n    \\n    Threading macro. Inserts x as the second value in the first form in\\n    forms, and inserts the modified first form into the second form in the\\n    same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"->","created-at":1593631775},{"example":"(-> 1 (+ 2) (+ 3))  # -> 6","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1064, column 1\\n\\n    (-> x & forms)\\n    \\n    Threading macro. Inserts x as the second value in the first form in\\n    forms, and inserts the modified first form into the second form in the\\n    same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"->","created-at":1593631692},{"example":"(defn add17 (partial + 17))\u000D\u000A(add17 3)            # -> 20\u000D\u000A(add17 3 4)          # -> 24\u000D\u000A(map add17 [1 2 3])  # -> @[18 19 20]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1215, column 1\\n\\n    (partial f & more)\\n    \\n    Partial function application.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"partial","created-at":1593631246},{"example":"(defn inc [x] (+ x 1))\u000D\u000A(defn inv [x] (* x -1))\u000D\u000A(defn sq  [x] (* x x))\u000D\u000A\u000D\u000A(-> 2 inc)             # -> 3\u000D\u000A(-> 2 inc inc)         # -> 4\u000D\u000A(-> 2 inc inc inv)     # -> -4\u000D\u000A(-> 2 inc inc inv sq)  # -> 16\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1064, column 1\\n\\n    (-> x & forms)\\n    \\n    Threading macro. Inserts x as the second value in the first form in\\n    forms, and inserts the modified first form into the second form in the\\n    same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"->","created-at":1593630897},{"example":"(* 2 3)      # -> 6\u000D\u000A(* 2 3.3)    # -> 6.6\u000D\u000A(* 2.2 3.3)  # -> 7.26\u000D\u000A\u000D\u000A(def pi 3.14159)\u000D\u000A(* 2 pi)  # -> 6.28318\u000D\u000A\u000D\u000A(* 2)  # -> 2\u000D\u000A(*)    # -> 1\u000D\u000A\u000D\u000A(* 2 3 4)             # -> 24\u000D\u000A(apply * [2 3 4])     # -> 24\u000D\u000A(* (splice [2 3 4]))  # -> 24\u000D\u000A(* ;[2 3 4])          # -> 24\u000D\u000A(def a [2 3 4])\u000D\u000A(* ;a)                # -> 24\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (* & xs)\\n    \\n    Returns the product of all elements in xs. If xs is empty, returns 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"*","created-at":1593630224},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(pos? 1)      # => true\u000D\u000A(pos? 1.618)  # => true\u000D\u000A\u000D\u000A(pos? 0)      # => false\u000D\u000A(pos? -1)     # => false\u000D\u000A\u000D\u000A(def pi 3.14159)\u000D\u000A(pos? pi)       # => true\u000D\u000A\u000D\u000A(pos? nil)      # => true\u000D\u000A(pos? false)    # => true\u000D\u000A(pos? \"hello\")  # => true\u000D\u000A(pos? :heyo)    # => true\u000D\u000A(pos? [-1])     # => true\u000D\u000A(pos? {:a 1})   # => true\u000D\u000A(pos? (fn []))  # => true\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 752, column 1\\n\\n    (pos? x)\\n    \\n    Check if x is greater than 0.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"pos?","created-at":1593629576},{"example":"(and true true)   # => true\u000D\u000A(and true false)  # => false\u000D\u000A\u000D\u000A(and true false nil)  # => false\u000D\u000A(and true nil false)  # => nil\u000D\u000A\u000D\u000A(and)       # => true\u000D\u000A(and true)  # => true\u000D\u000A\u000D\u000A(and 1)                  # => 1\u000D\u000A(and 1 \"hello\")          # => \"hello\"\u000D\u000A(and [false] 1 \"world\")  # => \"world\"\u000D\u000A\u000D\u000A# note that `and` does not behave as you might expect\u000D\u000A# when used with `apply` and `splice`:\u000D\u000A(and 1 2 3)                 # => 3\u000D\u000A(and (splice [1 2 3]))      # => (1 2 3)\u000D\u000A(apply and [1 2 3])         # => (if 1 (if 2 3 2) 1)\u000D\u000A(eval (apply and [1 2 3]))  # => 3\u000D\u000A\u000D\u000A# if you need an `and` which you can feed to `apply`,\u000D\u000A# you can use a reduce-based implementation:\u000D\u000A(defn and2 [& xs]\u000D\u000A  (reduce\u000D\u000A    (fn [a b] (if (not a) a b))\u000D\u000A    true xs))\u000D\u000A\u000D\u000A# however, note that `and2` does not implement short-circuiting:\u000D\u000A# janet:23:> (and false (do (print \"hello\") true))\u000D\u000A# false\u000D\u000A# janet:24:> (and2 false (do (print \"hello\") true))\u000D\u000A# hello\u000D\u000A# false\u000D\u000A\u000D\u000A# alternatively, you can use `all` for this case.\u000D\u000A(all truthy?  [true 0 1     'a :a \"a\" [] {}])  # => true\u000D\u000A(all truthy?  [true 0 nil   'a :a \"a\" [] {}])  # => nil\u000D\u000A(all truthy?  [true 0 false 'a :a \"a\" [] {}])  # => false\u000D\u000A(apply (partial all truthy?) [[true 0 1 'a :a \"a\" [] {}]])  # => true\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 249, column 1\\n\\n    (and & forms)\\n    \\n    Evaluates to the last argument if all preceding elements are truthy,\\n    otherwise evaluates to the first falsey argument.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"and","created-at":1593627905},{"example":"(apply * [1 2 3])     # -> 6\u000D\u000A(* (splice [1 2 3]))  # -> 6\u000D\u000A(* ;[1 2 3])          # -> 6\u000D\u000A(* 1 2 3)             # -> 6","docstring":"\"\\n\\n    function\\n\\n    (apply f & args)\\n    \\n    Applies a function to a variable number of arguments. Each element in\\n    args is used as an argument to f, except the last element in args,\\n    which is expected to be an array-like. Each element in this last\\n    argument is then also pushed as an argument to f. For example:\\n    \\n      (apply + 1000 (range 10))\\n    \\n    sums the first 10 integers and 1000.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"apply","created-at":1593627335},{"example":"(defn fizzbuzz [n]\u000D\u000A  (cond \u000D\u000A    (and\u000D\u000A      (= 0 (% n 3))\u000D\u000A      (= 0 (% n 5))) \"fizzbuzz\"\u000D\u000A    (= 0 (% n 3)) \"fizz\"\u000D\u000A    (= 0 (% n 5)) \"buzz\"\u000D\u000A    :else n))\u000D\u000A\u000D\u000A(fizzbuzz 1)   # 1\u000D\u000A(fizzbuzz 3)   # \"fizz\"\u000D\u000A(fizzbuzz 5)   # \"buzz\"\u000D\u000A(fizzbuzz 15)  # \"fizzbuzz\"","docstring":"\"\\n\\n    function\\n\\n    (% dividend divisor)\\n    \\n    Returns the remainder of dividend / divisor.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"%","created-at":1593620745},{"example":"(freeze @{:a @[1 2] \u000D\u000A          :b @{:x @[8 9] \u000D\u000A               :y :smile}})\u000D\u000A# => {:a (1 2) :b {:x (8 9) :y :smile}}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1895, column 1\\n\\n    (freeze x)\\n    \\n    Freeze an object (make it immutable) and do a deep copy, making child\\n    values also immutable. Closures, fibers, and abstract types will not be\\n    recursively frozen, but all other types will.\\n\\n\\n\"","gh-username":"sogaiu","name":"freeze","created-at":1593595309},{"example":"(string/reverse \"hello\") # => \"olleh\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/reverse str)\\n    \\n    Returns a string that is the reversed version of str.\\n\\n\\n\"","gh-username":"swlkr","name":"string/reverse","created-at":1593203788},{"example":"(describe :a) # => \":a\"","docstring":"\"\\n\\n    cfunction\\n\\n    (describe x)\\n    \\n    Returns a string that is a human readable description of a value x.\\n\\n\\n\"","gh-username":"sogaiu","name":"describe","created-at":1592981947},{"example":"(put (table) :a 1) # => @{:a 1}\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (put ds key value)\\n    \\n    Associate a key with a value in any mutable associative data\\n    structure. Indexed data structures (arrays and buffers) only accept\\n    non-negative integer keys, and will expand if an out of bounds value is\\n    provided. In an array, extra space will be filled with nils, and in a\\n    buffer, extra space will be filled with 0 bytes. In a table, putting a\\n    key that is contained in the table prototype will hide the association\\n    defined by the prototype, but will not mutate the prototype table.\\n    Putting a value nil into a table will remove the key from the table.\\n    Returns the data structure ds.\\n\\n\\n\"","gh-username":"sogaiu","name":"put","created-at":1592184591},{"example":"(struct :a 1 :b 2) # => {:a 1 :b 2}","docstring":"\"\\n\\n    cfunction\\n\\n    (struct & kvs)\\n    \\n    Create a new struct from a sequence of key value pairs. kvs is a\\n    sequence k1, v1, k2, v2, k3, v3, ... If kvs has an odd number of\\n    elements, an error will be thrown. Returns the new struct.\\n\\n\\n\"","gh-username":"sogaiu","name":"struct","created-at":1592184261},{"example":"(kvs (struct :a 1 :b 2))\u000D\u000A# => @[:a 1 :b 2]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1447, column 1\\n\\n    (kvs dict)\\n    \\n    Takes a table or struct and returns and array of key value pairs like\\n    @[k v k v ...]. Returns a new array.\\n\\n\\n\"","gh-username":"sogaiu","name":"kvs","created-at":1592184205},{"example":"(table ;(kvs (struct :a 1 :b 2)))\u000D\u000A# => @{:a 1 :b 2}","docstring":"\"\\n\\n    cfunction\\n\\n    (table & kvs)\\n    \\n    Creates a new table from a variadic number of keys and values. kvs is\\n    a sequence k1, v1, k2, v2, k3, v3, ... If kvs has an odd number of\\n    elements, an error will be thrown. Returns the new table.\\n\\n\\n\"","gh-username":"sogaiu","name":"table","created-at":1592184132},{"example":"(table ;[:a 1 :b 2 :c 3])\u000D\u000A# => @{:a 1 :b 2 :c 3}\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (table & kvs)\\n    \\n    Creates a new table from a variadic number of keys and values. kvs is\\n    a sequence k1, v1, k2, v2, k3, v3, ... If kvs has an odd number of\\n    elements, an error will be thrown. Returns the new table.\\n\\n\\n\"","gh-username":"sogaiu","name":"table","created-at":1591861586},{"example":"(string/check-set \"0123456789abcdef\" \"deadbeef\") # => true","docstring":"\"\\n\\n    cfunction\\n\\n    (string/check-set set str)\\n    \\n    Checks that the string str only contains bytes that appear in the\\n    string set. Returns true if all bytes in str appear in set, false if\\n    some bytes in str do not appear in set.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/check-set","created-at":1590982975},{"example":"(string/split \",\" \"bruce,scott,tiger,woods\") # => @[\"bruce\" \"scott\" \"tiger\" \"woods\"]","docstring":"\"\\n\\n    cfunction\\n\\n    (string/split delim str &opt start limit)\\n    \\n    Splits a string str with delimiter delim and returns an array of\\n    substrings. The substrings will not contain the delimiter delim. If\\n    delim is not found, the returned array will have one element. Will\\n    start searching for delim at the index start (if provided), and return\\n    up to a maximum of limit results (if provided).\\n\\n\\n\"","gh-username":"sogaiu","name":"string/split","created-at":1590982860},{"example":"(string/find-all \"duck\" \"duck duck duck goose!\") # => @[0 5 10]","docstring":"\"\\n\\n    cfunction\\n\\n    (string/find-all patt str)\\n    \\n    Searches for all instances of pattern patt in string str. Returns an\\n    array of all indices of found patterns. Overlapping instances of the\\n    pattern are not counted, meaning a byte in string will only contribute\\n    to finding at most on occurrence of pattern. If no occurrences are\\n    found, will return an empty array.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/find-all","created-at":1590982389},{"example":"(string/find \"needle\" \"hay hay hay needle hay\") # => 12","docstring":"\"\\n\\n    cfunction\\n\\n    (string/find patt str)\\n    \\n    Searches for the first instance of pattern patt in string str. Returns\\n    the index of the first character in patt if found, otherwise returns\\n    nil.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/find","created-at":1590982200},{"example":"(string/has-prefix? \"project.\" \"project.janet\") # => true","docstring":"\"\\n\\n    cfunction\\n\\n    (string/has-prefix? pfx str)\\n    \\n    Tests whether str starts with pfx.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/has-prefix?","created-at":1590981654},{"example":"(string/has-suffix? \".janet\" \"code.janet\") # => true","docstring":"\"\\n\\n    cfunction\\n\\n    (string/has-suffix? sfx str)\\n    \\n    Tests whether str ends with sfx.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/has-suffix?","created-at":1590981563},{"example":"(string/replace-all \"e\" \"o\" \"feed\") # => \"food\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/replace-all patt subst str)\\n    \\n    Replace all instances of patt with subst in the string str. Will\\n    return the new string if patt is found, otherwise returns str.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/replace-all","created-at":1590981470},{"example":"(string/replace \"+\" \"-\" \"ctrl+c\") # => \"ctrl-c\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/replace patt subst str)\\n    \\n    Replace the first occurrence of patt with subst in the string str.\\n    Will return the new string if patt is found, otherwise returns str.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/replace","created-at":1590981422},{"example":"(string/join @[\"alice\" \"bob\" \"eve\"] \"\\t\") # => \"alice\\tbob\\teve\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/join parts &opt sep)\\n    \\n    Joins an array of strings into one string, optionally separated by a\\n    separator string sep.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/join","created-at":1590981019},{"example":"(def request {:params {:id 1}}) # => {:params {:id 1}}\u000D\u000A\u000D\u000A(get-in request [:params :id]) # => 1\u000D\u000A\u000D\u000A(get-in request [:params :name]) # => nil\u000D\u000A\u000D\u000A(get-in request [:params :name] \"N/A\") # => \"N/A\"","docstring":"\"\\n\\n    function\\n    boot.janet on line 1290, column 1\\n\\n    (get-in ds ks &opt dflt)\\n    \\n    Access a value in a nested data structure. Looks into the data\\n    structure via a sequence of keys.\\n\\n\\n\"","gh-username":"inchingforward","name":"get-in","created-at":1590337493},{"example":"(def a-tuple-1 [:number 10])\u000D\u000A(def a-tuple-2 [:string \"Hello there!\"])\u000D\u000A(defn show [what]\u000D\u000A  (match what\u000D\u000A    [:number n] (printf \"It's a number! %d\" n)\u000D\u000A    [:string s] (printf \"Here's a string: %s\" s)\u000D\u000A    _ (printf \"I dunno what this is: %q\" what)))\u000D\u000A\u000D\u000A(show a-tuple-1)\u000D\u000A(show a-tuple-2)\u000D\u000A(show [:array @[]])","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1599, column 1\\n\\n    (match x & cases)\\n    \\n    Pattern matching. Match an expression x against any number of cases.\\n    Each case is a pattern to match against, followed by an expression to\\n    evaluate to if that case is matched. A pattern that is a symbol will\\n    match anything, binding x's value to that symbol. An array will match\\n    only if all of it's elements match the corresponding elements in x. A\\n    table or struct will match if all values match with the corresponding\\n    values in x. A tuple pattern will match if it's first element matches,\\n    and the following elements are treated as predicates and are true. The\\n    last special case is the '_ symbol, which is a wildcard that will match\\n    any value without creating a binding. Any other value pattern will only\\n    match if it is equal to x.\\n\\n\\n\"","gh-username":"roobie","name":"match","created-at":1590253873},{"example":"(loop [x :range [1 10]\u000D\u000A       :let [square (* x x)]\u000D\u000A       :until (> square 9)\u000D\u000A       :before (print \"before\")\u000D\u000A       :after (print \"after\")\u000D\u000A       :repeat 2]\u000D\u000A  (print (string \"square: \" square)))\u000D\u000A\u000D\u000A# before\u000D\u000A# square: 1\u000D\u000A# square: 1\u000D\u000A# after\u000D\u000A# before\u000D\u000A# square: 4\u000D\u000A# square: 4\u000D\u000A# after\u000D\u000A# before\u000D\u000A# square: 9\u000D\u000A# square: 9\u000D\u000A# after\u000D\u000A\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 531, column 1\\n\\n    (loop head & body)\\n    \\n    A general purpose loop macro. This macro is similar to the Common Lisp\\n    loop macro, although intentionally much smaller in scope. The head of\\n    the loop should be a tuple that contains a sequence of either bindings\\n    or conditionals. A binding is a sequence of three values that define\\n    something to loop over. They are formatted like:\\n    \\n      binding :verb object/expression\\n    \\n    Where binding is a binding as passed to def, :verb is one of a set of\\n    keywords, and object is any expression. The available verbs are:\\n    \\n      :iterate - repeatedly evaluate and bind to the expression while it\\n    is truthy.\\n      :range - loop over a range. The object should be two element tuple\\n    with a start and end value, and an optional positive step. The range is\\n    half open, [start, end).\\n      :range-to - same as :range, but the range is inclusive [start, end].\\n      :down - loop over a range, stepping downwards. The object should be\\n    two element tuple with a start and (exclusive) end value, and an\\n    optional (positive!) step size.\\n      :down-to - same :as down, but the range is inclusive [start, end].\\n      :keys - iterate over the keys in a data structure.\\n      :pairs - iterate over the keys value pairs as tuples in a data\\n    structure.\\n      :in - iterate over the values in a data structure.\\n      :generate - iterate over values yielded from a fiber. Can be paired\\n    with the generator function for the producer/consumer pattern.\\n    \\n    loop also accepts conditionals to refine the looping further.\\n    Conditionals are of the form:\\n    \\n      :modifier argument\\n    \\n    where :modifier is one of a set of keywords, and argument is keyword\\n    dependent. :modifier can be one of:\\n    \\n      :while expression - breaks from the loop if expression is falsey.\\n      :until expression - breaks from the loop if expression is truthy.\\n      :let bindings - defines bindings inside the loop as passed to the\\n    let macro.\\n      :before form - evaluates a form for a side effect before of the next\\n    inner loop.\\n      :after form - same as :before, but the side effect happens after the\\n    next inner loop.\\n      :repeat n - repeats the next inner loop n times.\\n      :when condition - only evaluates the loop body when condition is\\n    true.\\n    \\n    The loop macro always evaluates to nil.\\n\\n\\n\"","gh-username":"staab","name":"loop","created-at":1590252293},{"example":"# Suppose you have a fiber that yields chunks of paginated api results:\u000D\u000A(def api-results (fiber/new (fn [] (yield [1 2 3]) (yield [4 5 6]))))\u000D\u000A\u000D\u000A# Using :iterate, the right side of the binding is evaluated each time the loop is run,\u000D\u000A# which allows for running a side-effecting expression that may be different each time.\u000D\u000A(loop [_ :iterate (fiber/can-resume? api-results)] (pp (resume api-results)))\u000D\u000A\u000D\u000A# This example can be simplified using :generate\u000D\u000A(loop [chunk :generate api-results] (pp chunk))\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 531, column 1\\n\\n    (loop head & body)\\n    \\n    A general purpose loop macro. This macro is similar to the Common Lisp\\n    loop macro, although intentionally much smaller in scope. The head of\\n    the loop should be a tuple that contains a sequence of either bindings\\n    or conditionals. A binding is a sequence of three values that define\\n    something to loop over. They are formatted like:\\n    \\n      binding :verb object/expression\\n    \\n    Where binding is a binding as passed to def, :verb is one of a set of\\n    keywords, and object is any expression. The available verbs are:\\n    \\n      :iterate - repeatedly evaluate and bind to the expression while it\\n    is truthy.\\n      :range - loop over a range. The object should be two element tuple\\n    with a start and end value, and an optional positive step. The range is\\n    half open, [start, end).\\n      :range-to - same as :range, but the range is inclusive [start, end].\\n      :down - loop over a range, stepping downwards. The object should be\\n    two element tuple with a start and (exclusive) end value, and an\\n    optional (positive!) step size.\\n      :down-to - same :as down, but the range is inclusive [start, end].\\n      :keys - iterate over the keys in a data structure.\\n      :pairs - iterate over the keys value pairs as tuples in a data\\n    structure.\\n      :in - iterate over the values in a data structure.\\n      :generate - iterate over values yielded from a fiber. Can be paired\\n    with the generator function for the producer/consumer pattern.\\n    \\n    loop also accepts conditionals to refine the looping further.\\n    Conditionals are of the form:\\n    \\n      :modifier argument\\n    \\n    where :modifier is one of a set of keywords, and argument is keyword\\n    dependent. :modifier can be one of:\\n    \\n      :while expression - breaks from the loop if expression is falsey.\\n      :until expression - breaks from the loop if expression is truthy.\\n      :let bindings - defines bindings inside the loop as passed to the\\n    let macro.\\n      :before form - evaluates a form for a side effect before of the next\\n    inner loop.\\n      :after form - same as :before, but the side effect happens after the\\n    next inner loop.\\n      :repeat n - repeats the next inner loop n times.\\n      :when condition - only evaluates the loop body when condition is\\n    true.\\n    \\n    The loop macro always evaluates to nil.\\n\\n\\n\"","gh-username":"staab","name":"loop","created-at":1590210711},{"example":"(peg/match ~{:main (capture (some :S))}\u000D\u000A           \"hello world\")              # => @[\"hello\"]","docstring":"\"\\n\\n    cfunction\\n\\n    (peg/match peg text &opt start & args)\\n    \\n    Match a Parsing Expression Grammar to a byte string and return an\\n    array of captured values. Returns nil if text does not match the\\n    language defined by peg. The syntax of PEGs is documented on the Janet\\n    website.\\n\\n\\n\"","gh-username":"sogaiu","name":"peg/match","created-at":1590207813},{"example":"(def h [\"a\" \"b\" :c]) # => (\"a\" \"b\" :c)\u000D\u000A\u000D\u000A(find (fn [a] (= \"a\" a)) h) # => \"a\"","docstring":"\"\\n\\n    function\\n    boot.janet on line 956, column 1\\n\\n    (find pred ind)\\n    \\n    Find the first value in an indexed collection that satisfies a\\n    predicate. Returns nil if not found. Note there is no way to\\n    differentiate a nil from the indexed collection and a not found.\\n    Consider find-index if this is an issue.\\n\\n\\n\"","gh-username":"faywong","name":"find","created-at":1590197194},{"example":"(odd? 2) # => false\u000D\u000A(odd? nil) # throws an error\u000D\u000A(odd? 1) # => true\u000D\u000A(odd? \"a\") # => throws an error","docstring":"\"\\n\\n    function\\n    boot.janet on line 85, column 1\\n\\n    (odd? x)\\n    \\n    Check if x is odd.\\n\\n\\n\"","gh-username":"swlkr","name":"odd?","created-at":1590111804},{"example":"(string/bytes \"hello\") # => (104 101 108 108 111)","docstring":"\"\\n\\n    cfunction\\n\\n    (string/bytes str)\\n    \\n    Returns an array of integers that are the byte values of the string.\\n\\n\\n\"","gh-username":"swlkr","name":"string/bytes","created-at":1590100275},{"example":"# There is a list of formatters here: https://janet-lang.org/capi/writing-c-functions.html\u000D\u000A\u000D\u000A\u000D\u000A(string/format \"With terminal colors: %M\" [:array {:key-in \"struct\"}]) # => \"With terminal colors: (\\e[33m:array\\e[0m {\\e[33m:key-in\\e[0m \\e[35m\\\"struct\\\"\\e[0m})\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (string/format format & values)\\n    \\n    Similar to snprintf, but specialized for operating with Janet values.\\n    Returns a new string.\\n\\n\\n\"","gh-username":"roobie","name":"string/format","created-at":1590093029},{"example":"(map |(+ $0 $1) [1 2 3] [4 5 6]) # @[5 7 9] - uses the fn shorthand","docstring":"\"\\n\\n    function\\n    boot.janet on line 859, column 1\\n\\n    (map f & inds)\\n    \\n    Map a function over every element in an indexed data structure and\\n    return an array of the results.\\n\\n\\n\"","gh-username":"ahungry","name":"map","created-at":1590038055},{"example":"## Quadratic Formula\u000D\u000A\u000D\u000A(defn qform\u000D\u000A  \"Use the quadratic formula to solve for x. Returns all real solutions.\"\u000D\u000A  [a b c]\u000D\u000A  (def det (- (* b b) (* 4 a c)))\u000D\u000A  (def factor (/ 0.5 a))\u000D\u000A  (cond\u000D\u000A    (neg? det) []\u000D\u000A    (zero? det) [(* factor (- b))]\u000D\u000A    (let [root-det (math/sqrt det)]\u000D\u000A        [(* factor (- (- b) root-det)) (* factor (+ (- b) root-det))])))\u000D\u000A\u000D\u000A    (qform 1 4 3) # -> (-3 -1)\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 12, column 1\\n\\n    (defn name & more)\\n    \\n    Define a function. Equivalent to (def name (fn name [args] ...)).\\n\\n\\n\"","gh-username":"bakpakin","name":"defn","created-at":1590032837},{"example":"(map string/from-bytes \"Hello, world!\")  # => @[\"H\" \"e\" \"l\" \"l\" \"o\" \",\" \" \" \"w\" \"o\" \"r\" \"l\" \"d\" \"!\"]","docstring":"\"\\n\\n    function\\n    boot.janet on line 859, column 1\\n\\n    (map f & inds)\\n    \\n    Map a function over every element in an indexed data structure and\\n    return an array of the results.\\n\\n\\n\"","gh-username":"GrayJack","name":"map","created-at":1590021354},{"example":"(os/getenv \"TERM\") # => \"xterm-256color\"","docstring":"\"\\n\\n    cfunction\\n\\n    (os/getenv variable &opt dflt)\\n    \\n    Get the string value of an environment variable.\\n\\n\\n\"","gh-username":"sogaiu","name":"os/getenv","created-at":1590018185},{"example":"janet:2:> (all true? [true true false])\u000D\u000Afalse\u000D\u000Ajanet:3:> (all even? [2 4 6 7])\u000D\u000Afalse\u000D\u000Ajanet:5:> (all even? [2 4 6])\u000D\u000Atrue","docstring":"\"\\n\\n    function\\n    boot.janet on line 1858, column 1\\n\\n    (all pred xs)\\n    \\n    Returns true if all xs are truthy, otherwise the result of first\\n    falsey predicate value, (pred x).\\n\\n\\n\"","gh-username":"swlkr","name":"all","created-at":1590006608},{"example":"(string/ascii-lower \"HELLO\") #=> \"hello\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/ascii-lower str)\\n    \\n    Returns a new string where all bytes are replaced with the lowercase\\n    version of themselves in ASCII. Does only a very simple case check,\\n    meaning no unicode support.\\n\\n\\n\"","gh-username":"swlkr","name":"string/ascii-lower","created-at":1590006451},{"example":"Example usage\u000D\u000A\u000D\u000A\u000D\u000Ajanet:1:> (def buf @\"ABCDE\")\u000D\u000A@\"ABCDE\"\u000D\u000Ajanet:2:> (buffer/slice 0)\u000D\u000Aerror: bad slot #0, expected string|symbol|keyword|buffer, got 0\u000D\u000A  in buffer/slice\u000D\u000A  in _thunk [repl] (tailcall) on line 2, column 1\u000D\u000Ajanet:3:> (buffer/slice buf 0)\u000D\u000A@\"ABCDE\"\u000D\u000Ajanet:4:> (buffer/slice buf 0 1)\u000D\u000A@\"A\"\u000D\u000Ajanet:5:> (buffer/slice buf 0 -1)\u000D\u000A@\"ABCDE\"\u000D\u000Ajanet:6:> (buffer/slice buf 1 3)\u000D\u000A@\"BC\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/slice bytes &opt start end)\\n    \\n    Takes a slice of a byte sequence from start to end. The range is half\\n    open, [start, end). Indexes can also be negative, indicating indexing\\n    from the end of the end of the array. By default, start is 0 and end is\\n    the length of the buffer. Returns a new buffer.\\n\\n\\n\"","gh-username":"roobie","name":"buffer/slice","created-at":1589999785},{"example":"(scan-number \"123\") # => 123\u000D\u000A(scan-number \"f\") # => nil\u000D\u000A\u000D\u000A(scan-number 123) # =>\u000D\u000A# error: bad slot #0, expected string|symbol|keyword|buffer, got 123\u000D\u000A#   in scan-number\u000D\u000A#   in _thunk [repl] (tailcall) on line 1, column 1","docstring":"\"\\n\\n    cfunction\\n\\n    (scan-number str)\\n    \\n    Parse a number from a byte sequence an return that number, either and\\n    integer or a real. The number must be in the same format as numbers in\\n    janet source code. Will return nil on an invalid number.\\n\\n\\n\"","gh-username":"swlkr","name":"scan-number","created-at":1589997888},{"example":"(string \"hello \" \"world\") # => \"hello world\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (string & parts)\\n    \\n    Creates a string by concatenating values together. Values are\\n    converted to bytes via describe if they are not byte sequences. Returns\\n    the new string.\\n\\n\\n\"","gh-username":"swlkr","name":"string","created-at":1589997117},{"example":"You can see janet datastructure values by typing:\u000D\u000A\u000D\u000A(string/format \"%q\" {:a 1 :b 2}) # => {:a 1 :b 2} ","docstring":"\"\\n\\n    cfunction\\n\\n    (string/format format & values)\\n    \\n    Similar to snprintf, but specialized for operating with Janet values.\\n    Returns a new string.\\n\\n\\n\"","gh-username":"swlkr","name":"string/format","created-at":1589995467}]