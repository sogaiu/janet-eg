[{"example":"(string/split \"\\n\" @\"works\\nfor\\nbuffers\\ntoo\")\u000D\u000A# => @[\"works\" \"for\" \"buffers\" \"too\"]","docstring":"\"\\n\\n    cfunction\\n\\n    (string/split delim str &opt start limit)\\n\\n    Splits a string str with delimiter delim and returns an array of\\n    substrings. The substrings will not contain the delimiter delim. If\\n    delim is not found, the returned array will have one element. Will\\n    start searching for delim at the index start (if provided), and\\n    return up to a maximum of limit results (if provided).\\n\\n\\n\"","gh-username":"sogaiu","name":"string/split","created-at":1613281059},{"example":"(def a @[[42 \"c\"] [68 \"b\"] [31 \"d\"] [27 \"a\"]])\u000D\u000A(sort a (fn [a b]\u000D\u000A          (< (a 1) (b 1))))\u000D\u000A(pp a) # @[(27 \"a\") (68 \"b\") (42 \"c\") (31 \"d\")]","docstring":"\"\\n\\n    function\\n    boot.janet on line 794, column 1\\n\\n    (sort a &opt by)\\n\\n    Sort an array in-place. Uses quick-sort and is not a stable sort.\\n\\n\\n\"","gh-username":"uvtc","name":"sort","created-at":1613167912},{"example":"(zipcoll [:a :b :c] [1 2 3])  #=> @{:c 3 :a 1 :b 2}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1334, column 1\\n\\n    (zipcoll ks vs)\\n\\n    Creates a table from two arrays/tuples. Returns a new table.\\n\\n\\n\"","gh-username":"uvtc","name":"zipcoll","created-at":1613007432},{"example":"(do\u000D\u000A  (var coll @[])\u000D\u000A  (loop [i :down-to [10 1]]\u000D\u000A    (array/push coll i))\u000D\u000A  coll)\u000D\u000A# => @[10 9 8 7 6 5 4 3 2 1]","docstring":"\"\\n\\n    macro\\n    boot.janet on line 522, column 1\\n\\n    (loop head & body)\\n\\n    A general purpose loop macro. This macro is similar to the Common\\n    Lisp loop macro, although intentionally much smaller in scope. The\\n    head of the loop should be a tuple that contains a sequence of either\\n    bindings or conditionals. A binding is a sequence of three values\\n    that define something to loop over. They are formatted like:\\n\\n        binding :verb object/expression\\n\\n    Where `binding` is a binding as passed to def, `:verb` is one of a\\n    set of keywords, and `object` is any expression. The available verbs\\n    are:\\n\\n    * :iterate -- repeatedly evaluate and bind to the expression while it\\n      is truthy.\\n\\n    * :range -- loop over a range. The object should be a two-element\\n      tuple with a start and end value, and an optional positive step.\\n      The range is half open, [start, end).\\n\\n    * :range-to -- same as :range, but the range is inclusive [start,\\n      end].\\n\\n    * :down -- loop over a range, stepping downwards. The object should\\n      be a two-element tuple with a start and (exclusive) end value, and\\n      an optional (positive!) step size.\\n\\n    * :down-to -- same as :down, but the range is inclusive [start, end].\\n\\n    * :keys -- iterate over the keys in a data structure.\\n\\n    * :pairs -- iterate over the key-value pairs as tuples in a data\\n      structure.\\n\\n    * :in -- iterate over the values in a data structure or fiber.\\n\\n    `loop` also accepts conditionals to refine the looping further.\\n    Conditionals are of the form:\\n\\n        :modifier argument\\n\\n    where `:modifier` is one of a set of keywords, and `argument` is\\n    keyword-dependent. `:modifier` can be one of:\\n\\n    * `:while expression` - breaks from the loop if `expression` is\\n      falsey.\\n\\n    * `:until expression` - breaks from the loop if `expression` is\\n      truthy.\\n\\n    * `:let bindings` - defines bindings inside the loop as passed to the\\n      `let` macro.\\n\\n    * `:before form` - evaluates a form for a side effect before the next\\n      inner loop.\\n\\n    * `:after form` - same as `:before`, but the side effect happens\\n      after the next inner loop.\\n\\n    * `:repeat n` - repeats the next inner loop `n` times.\\n\\n    * `:when condition` - only evaluates the loop body when condition is\\n      true.\\n\\n    The `loop` macro always evaluates to nil.\\n\\n\\n\"","gh-username":"sogaiu","name":"loop","created-at":1612708004},{"example":"(do\u000D\u000A  (var coll @[])\u000D\u000A  (forv i 0 9\u000D\u000A    (array/push coll i)\u000D\u000A    (+= i 2))\u000D\u000A  coll)\u000D\u000A# => @[0 3 6]\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 485, column 1\\n\\n    (forv i start stop & body)\\n\\n    Do a C-style for-loop for side effects. The iteration variable `i`\\n    can be mutated in the loop, unlike normal `for`. Returns nil.\\n\\n\\n\"","gh-username":"sogaiu","name":"forv","created-at":1612699952},{"example":"(label result\u000D\u000A  (each x [0 1 2 3]\u000D\u000A    (when (= x 3)\u000D\u000A      (print \"reached the end\"))\u000D\u000A    (when (= x 2)\u000D\u000A      (return result 8))))\u000D\u000A# => 8","docstring":"\"\\n\\n    function\\n    boot.janet on line 358, column 1\\n\\n    (return to &opt value)\\n\\n    Return to a prompt point.\\n\\n\\n\"","gh-username":"sogaiu","name":"return","created-at":1612694619},{"example":"(label result\u000D\u000A  (each x [0 1 2 3]\u000D\u000A    (when (= x 3)\u000D\u000A      (print \"reached the end\"))\u000D\u000A    (when (= x 2)\u000D\u000A      (return result 8))))\u000D\u000A# => 8","docstring":"\"\\n\\n    macro\\n    boot.janet on line 350, column 1\\n\\n    (label name & body)\\n\\n    Set a label point that is lexically scoped. Name should be a symbol\\n    that will be bound to the label.\\n\\n\\n\"","gh-username":"sogaiu","name":"label","created-at":1612693858},{"example":"(parse \"(+ 4 5)\") # => (+ 4 5)\u000D\u000A(type (parse \"(+ 4 5)\")) # => :tuple","docstring":"\"\\n\\n    function\\n    boot.janet on line 2595, column 1\\n\\n    (parse str)\\n\\n    Parse a string and return the first value. For complex parsing, such\\n    as for a repl with error handling, use the parser api.\\n\\n\\n\"","gh-username":"skuzzymiglet","name":"parse","created-at":1612290196},{"example":"# Find all bindings (in the current environment) with \"push\" in the name.\u000D\u000A(doc \"push\")\u000D\u000A\u000D\u000A#    Bindings:\u000D\u000A#\u000D\u000A#    array/push buffer/push buffer/push-byte buffer/push-string\u000D\u000A#    buffer/push-word\u000D\u000A#\u000D\u000A#    Dynamics:\u000D\u000A#\u000D\u000A#\u000D\u000A#\u000D\u000A#    Use (doc sym) for more information on a binding.","docstring":"\"\\n\\n    macro\\n    boot.janet on line 2060, column 1\\n\\n    (doc &opt sym)\\n\\n    Shows documentation for the given symbol, or can show a list of\\n    available bindings. If sym is a symbol, will look for documentation\\n    for that symbol. If sym is a string or is not provided, will show all\\n    lexical and dynamic bindings in the current environment with that\\n    prefix (all bindings will be shown if no prefix is given).\\n\\n\\n\"","gh-username":"uvtc","name":"doc","created-at":1612151086},{"example":"(def b @\"\")\u000D\u000A(def v (* 1000 (math/random)))\u000D\u000A# => 912.753 can differ for you\u000D\u000A(xprintf b \"Value reached level %f\" v)\u000D\u000A# => nil\u000D\u000Ab\u000D\u000A# => @\"Value reached level 912.752790\\n\"","docstring":"\"\\n\\n    cfunction\\n\\n    (xprint to fmt & xs)\\n\\n    Like printf but prints to an explicit file or value to. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"xprintf","created-at":1612082655},{"example":"(def b @\"\")\u000D\u000A(def v (* 1000 (math/random)))\u000D\u000A# => 487.181 your number can differ\u000D\u000A(xprinf b \"Value reached level %f\" v)\u000D\u000A# => nil\u000D\u000Ab\u000D\u000A# => @\"Value reached level 487.181188\"","docstring":"\"\\n\\n    cfunction\\n\\n    (xprin to fmt & xs)\\n\\n    Like prinf but prints to an explicit file or value to. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"xprinf","created-at":1612082487},{"example":"(def b @\"\")\u000D\u000A(xprin b \"HOHOHO\")\u000D\u000A# => nil\u000D\u000Ab\u000D\u000A# => \"HOHOHO\"","docstring":"\"\\n\\n    cfunction\\n\\n    (xprin to & xs)\\n\\n    Print to a file or other value explicitly (no dynamic bindings). The\\n    value to print to is the first argument, and is otherwise the same as\\n    prin. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"xprin","created-at":1612082104},{"example":"(def b @\"\")\u000D\u000A(xprint b \"HOHOHO\")\u000D\u000A# => nil\u000D\u000Ab\u000D\u000A# => @\"HOHOHO\\n\"","docstring":"\"\\n\\n    cfunction\\n\\n    (xprint to & xs)\\n\\n    Print to a file or other value explicitly (no dynamic bindings) with\\n    a trailing newline character. The value to print to is the first\\n    argument, and is otherwise the same as print. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"xprint","created-at":1612082037},{"example":"# Walk from the API is defined using a case \u000D\u000A\u000D\u000A(defn walk\u000D\u000A  `Iterate over the values in ast and apply f\u000D\u000A  to them. Collect the results in a data structure. If ast is not a\u000D\u000A  table, struct, array, or tuple,\u000D\u000A  returns form.`\u000D\u000A  [f form]\u000D\u000A  (case (type form)\u000D\u000A    :table (walk-dict f form)\u000D\u000A    :struct (table/to-struct (walk-dict f form))\u000D\u000A    :array (walk-ind f form)\u000D\u000A    :tuple (let [x (walk-ind f form)]\u000D\u000A             (if (= :parens (tuple/type form))\u000D\u000A               (tuple/slice x)\u000D\u000A               (tuple/brackets ;x)))\u000D\u000A    form))","docstring":"\"\\n\\n    macro\\n    boot.janet on line 196, column 1\\n\\n    (case dispatch & pairs)\\n\\n    Select the body that equals the dispatch value. When pairs has an odd\\n    number of arguments, the last is the default expression. If no match\\n    is found, returns nil.\\n\\n\\n\"","gh-username":"pingiun","name":"case","created-at":1612020724},{"example":"(pp (all-bindings))\u000D\u000A# => prints @[% %= * ... yield zero? zipcoll]\u000D\u000A\u000D\u000A(def a \"A\")\u000D\u000A(pp (all-bindings (curenv) true))\u000D\u000A# => prints @[_ a] - only local bindings are listed","docstring":"\"\\n\\n    function\\n    boot.janet on line 1766, column 1\\n\\n    (all-bindings &opt env local)\\n\\n    Get all symbols available in an environment. Defaults to the current\\n    fiber's environment. If local is truthy, will not show inherited\\n    bindings (from prototype tables).\\n\\n\\n\"","gh-username":"pepe","name":"all-bindings","created-at":1611852015},{"example":"(peg/replace-all '(set \"aiou\") \"e\" \"The quick brown fox jumps over the lazy dog\")\u000D\u000A# returns The qeeck brewn fex jemps ever the lezy deg","docstring":"\"\\n\\n    cfunction\\n\\n    (peg/replace-all peg repl text &opt start & args)\\n\\n    Replace all matches of peg in text with repl, returning a new buffer.\\n    The peg does not need to make captures to do replacement.\\n\\n\\n\"","gh-username":"pepe","name":"peg/replace-all","created-at":1611736323},{"example":"(keyword/slice \"some crazy keyword\" 11 -1)\u000D\u000A# returns :keyword ","docstring":"\"\\n\\n    cfunction\\n\\n    (keyword/slice bytes &opt start end)\\n\\n    Same a string/slice, but returns a keyword.\\n\\n\\n\"","gh-username":"pepe","name":"keyword/slice","created-at":1611734400},{"example":"(all-dynamics)\u000D\u000A# => @[:args :err-color :executable :peg-grammar :pretty-format :syspath]\u000D\u000A\u000D\u000A(setdyn :fixed true)\u000D\u000A(all-dynamics)\u000D\u000A# => @[:args :err-color :executable :fixed :peg-grammar :pretty-format :syspath]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1773, column 1\\n\\n    (all-dynamics &opt env local)\\n\\n    Get all dynamic bindings in an environment. Defaults to the current\\n    fiber's environment. If local is truthy, will not show inherited\\n    bindings (from prototype tables).\\n\\n\\n\"","gh-username":"pepe","name":"all-dynamics","created-at":1611734251},{"example":"(when-with [f (file/open \"nofile.exists\")] \u000D\u000A  (print \"Realy?\"))\u000D\u000A# it just returns nil ","docstring":"\"\\n\\n    macro\\n    boot.janet on line 373, column 1\\n\\n    (when-with [binding ctor dtor] & body)\\n\\n    Similar to with, but if binding is false or nil, returns nil without\\n    evaluating the body. Otherwise, the same as with.\\n\\n\\n\"","gh-username":"pepe","name":"when-with","created-at":1611733957},{"example":"(def kvpairs [[:x 1] [:y 2]])\u000D\u000A\u000D\u000A(table ;(flatten kvpairs)) # => @{:x 1 :y 2}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1499, column 1\\n\\n    (flatten xs)\\n\\n    Takes a nested array (tree), and returns the depth first traversal of\\n    that array. Returns a new array.\\n\\n\\n\"","gh-username":"yumaikas","name":"flatten","created-at":1611459838},{"example":"(def kvpairs [[:x 1] [:y 2]])\u000D\u000A\u000D\u000A(table ;(flatten kvpairs)) => @{:x 1 :y 2}","docstring":"\"\\n\\n    cfunction\\n\\n    (table & kvs)\\n\\n    Creates a new table from a variadic number of keys and values. kvs is\\n    a sequence k1, v1, k2, v2, k3, v3, ... If kvs has an odd number of\\n    elements, an error will be thrown. Returns the new table.\\n\\n\\n\"","gh-username":"yumaikas","name":"table","created-at":1611459819},{"example":"(def f (ev/go (coro \"world\"))) # coro is great for fast fiber creating\u000D\u000A(ev/sleep 0.0001) # give ev a chance in the REPL, remove in file\u000D\u000A(fiber/last-value f) # \"world\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (ev/go fiber &opt value supervisor)\\n\\n    Put a fiber on the event loop to be resumed later. Optionally pass a\\n    value to resume with, otherwise resumes with nil. Returns the fiber.\\n    An optional `core/channel` can be provided as well as a supervisor.\\n    When various events occur in the newly scheduled fiber, an event will\\n    be pushed to the supervisor. If not provided, the new fiber will\\n    inherit the current supervisor.\\n\\n\\n\"","gh-username":"pepe","name":"ev/go","created-at":1611418166},{"example":"(peg/find ':d \"Battery temperature: 40 \u00B0C\")\u000D\u000A# => 21 index of the first number","docstring":"\"\\n\\n    cfunction\\n\\n    (peg/find peg text &opt start & args)\\n\\n    Find first index where the peg matches in text. Returns an integer,\\n    or nil if not found.\\n\\n\\n\"","gh-username":"pepe","name":"peg/find","created-at":1611417877},{"example":"(os/mkdir \"templates\")\u000D\u000A# => creates ./templates directory","docstring":"\"\\n\\n    cfunction\\n\\n    (os/mkdir path)\\n\\n    Create a new directory. The path will be relative to the current\\n    directory if relative, otherwise it will be an absolute path. Returns\\n    true if the directory was created, false if the directory already\\n    exists, and errors otherwise.\\n\\n\\n\"","gh-username":"pepe","name":"os/mkdir","created-at":1611417573},{"example":"(var a false)\u000D\u000A(defer (set a 42) \u000D\u000A  (set a true)\u000D\u000A  (error \"Oh no!\"))\u000D\u000A# error: Oh no!\u000D\u000A\u000D\u000A(pp a) # => prints 42","docstring":"\"\\n\\n    macro\\n    boot.janet on line 305, column 1\\n\\n    (defer form & body)\\n\\n    Run form unconditionally after body, even if the body throws an\\n    error. Will also run form if a user signal 0-4 is received.\\n\\n\\n\"","gh-username":"pepe","name":"defer","created-at":1611416131},{"example":"(def a @[23 42])\u000D\u000A(array/clear a)\u000D\u000A(pp a)\u000D\u000A# => prints @[]","docstring":"\"\\n\\n    cfunction\\n\\n    (array/clear arr)\\n\\n    Empties an array, setting it's count to 0 but does not free the\\n    backing capacity. Returns the modified array.\\n\\n\\n\"","gh-username":"pepe","name":"array/clear","created-at":1611415970},{"example":"(def ast '(print novar))\u000D\u000A(def es (compile ast))\u000D\u000A# => @{:column 11 :line 12 :error \"unknown symbol novar\"} returns struct with error on invalid ast","docstring":"\"\\n\\n    cfunction\\n\\n    (compile ast &opt env source)\\n\\n    Compiles an Abstract Syntax Tree (ast) into a function. Pair the\\n    compile function with parsing functionality to implement eval.\\n    Returns a new function and does not modify ast. Returns an error\\n    struct with keys :line, :column, and :error if compilation fails.\\n\\n\\n\"","gh-username":"pepe","name":"compile","created-at":1611415835},{"example":"(def cc (compile '(print \"Janet\"))) # => <function _thunk> on success returns function\u000D\u000A(cc) # => prints Janet","docstring":"\"\\n\\n    cfunction\\n\\n    (compile ast &opt env source)\\n\\n    Compiles an Abstract Syntax Tree (ast) into a function. Pair the\\n    compile function with parsing functionality to implement eval.\\n    Returns a new function and does not modify ast. Returns an error\\n    struct with keys :line, :column, and :error if compilation fails.\\n\\n\\n\"","gh-username":"pepe","name":"compile","created-at":1611415719},{"example":"(fiber/root) # => <fiber 0x562FF22F10A0> your hex number will differ","docstring":"\"\\n\\n    cfunction\\n\\n    (fiber/root)\\n\\n    Returns the current root fiber. The root fiber is the oldest ancestor\\n    that does not have a parent.\\n\\n\\n\"","gh-username":"pepe","name":"fiber/root","created-at":1611415539},{"example":"(var a 0)\u000D\u000A(assert (pos? a) \"A is definitely not positive\")\u000D\u000A# error: A is definitely not positive\u000D\u000A#  in assert [boot.janet] on line 149, column 11\u000D\u000A#  in _thunk [repl] (tailcall) on line 3, column 1","docstring":"\"\\n\\n    function\\n    boot.janet on line 146, column 1\\n\\n    (assert x &opt err)\\n\\n    Throw an error if x is not truthy.\\n\\n\\n\"","gh-username":"pepe","name":"assert","created-at":1611415210},{"example":"(seq [i :range [0 10] :when (odd? i)] (math/pow 2 i))\u000D\u000A\u000D\u000A# => @[2 8 32 128 512]\u000D\u000A# array with 2 to the power of all odd numbers smaller than 10\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 570, column 1\\n\\n    (seq head & body)\\n\\n    Similar to loop, but accumulates the loop body into an array and\\n    returns that. See loop for details.\\n\\n\\n\"","gh-username":"pepe","name":"seq","created-at":1611415079},{"example":"(def p (os/spawn [\"ls\"] :p {:in :pipe :out :pipe})) # define core/process with selfpipe\u000D\u000A(pp (:read (p :out) :all)) # => prints the ls output\u000D\u000A(pp (:wait p)) # => waits for the process to finish, prints 0 if succesful ","docstring":"\"\\n\\n    cfunction\\n\\n    (os/spawn args &opts flags env)\\n\\n    Execute a program on the system and return a handle to the process.\\n    Otherwise, the same arguments as os/execute. Does not wait for the\\n    process.\\n\\n\\n\"","gh-username":"pepe","name":"os/spawn","created-at":1611414499},{"example":"# Setup\u000D\u000A(spit \"poem.txt\" \"I\u2019ve decided to tackle it\\nIt\u2019s going to get done\")\u000D\u000A\u000D\u000A# A version of head -n 1, but entirely in Janet\u000D\u000A# Note, that because files in Janet support :close as a method\u000D\u000A# we don't have to define a dtor. \u000D\u000A# There might be other closing work to do, of course\u000D\u000A(with [f (file/open \"poem.txt\")] (print (:read f :line))) # => \"I've decided to tackle it\"","docstring":"\"\\n\\n    macro\\n    boot.janet on line 363, column 1\\n\\n    (with [binding ctor dtor] & body)\\n\\n    Evaluate body with some resource, which will be automatically cleaned\\n    up if there is an error in body. binding is bound to the expression\\n    ctor, and dtor is a function or callable that is passed the binding.\\n    If no destructor (dtor) is given, will call :close on the resource.\\n\\n\\n\"","gh-username":"yumaikas","name":"with","created-at":1611295415},{"example":"(def chan (ev/chan))\u000D\u000A(def f (ev/go (coro (yield \"world\")) nil chan))\u000D\u000A(def [sig fib] (ev/take chan))\u000D\u000A(pp sig) # => prints :yield\u000D\u000A(pp (fiber/last-value fib)) # => prints world\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (ev/chan &opt capacity)\\n\\n    Create a new channel. capacity is the number of values to queue\\n    before blocking writers, defaults to 0 if not provided. Returns a new\\n    channel.\\n\\n\\n\"","gh-username":"pepe","name":"ev/chan","created-at":1611174505},{"example":"(defn worker [m]\u000D\u000A  (thread/send m \"Hello function\")\u000D\u000A  (:send m \"Hello method\"))\u000D\u000A\u000D\u000A(thread/new worker)\u000D\u000A(pp (thread/receive)) # => prints Hello function\u000D\u000A(pp (thread/receive)) # => prints Hello method\u000D\u000A\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (thread/receive &opt timeout)\\n\\n    Get a message sent to this thread. If timeout (in seconds) is\\n    provided, an error will be thrown after the timeout has elapsed but\\n    no messages are received. The default timeout is 1 second, and\\n    math/inf cam be passed to turn off the timeout.\\n\\n\\n\"","gh-username":"pepe","name":"thread/receive","created-at":1611174193},{"example":"(def t @{:a 1 :b 2 :c @[1 2 3]})\u000D\u000A(def ct (table/clone t))\u000D\u000A\u000D\u000A(put ct :a 3) # => @{:c @[1 2 3] :a 3 :b 2}\u000D\u000A(pp t) # => @{:c @[1 2 3] :a 1 :b 2}\u000D\u000A\u000D\u000A(update ct :c array/concat 4) # => @{:c @[1 2 3 4] :a 3 :b 2}\u000D\u000A(pp t) # => @{:c @[1 2 3 4] :a 3 :b 2}\u000D\u000A# array under key :c is shared between tables!\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (table/clone tab)\\n\\n    Create a copy of a table. Updates to the new table will not change\\n    the old table, and vice versa.\\n\\n\\n\"","gh-username":"pepe","name":"table/clone","created-at":1611173917},{"example":"(protect\u000D\u000A  (if (> (math/random) 0.42)\u000D\u000A    (error \"Good luck\")\u000D\u000A    \"Bad luck\"))\u000D\u000A# => randomly returns:\u000D\u000A# (false \"Good luck\")\u000D\u000A# or\u000D\u000A# (true \"Bad luck\")","docstring":"\"\\n\\n    macro\\n    boot.janet on line 248, column 1\\n\\n    (protect & body)\\n\\n    Evaluate expressions, while capturing any errors. Evaluates to a\\n    tuple of two elements. The first element is true if successful, false\\n    if an error, and the second is the return value or error.\\n\\n\\n\"","gh-username":"pepe","name":"protect","created-at":1611170616},{"example":"(repeat 3 (print \"HO\"))\u000D\u000A# => prints\u000D\u000A# HO\u000D\u000A# HO\u000D\u000A# HO\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 506, column 1\\n\\n    (repeat n & body)\\n\\n    Evaluate body n times. If n is negative, body will be evaluated 0\\n    times. Evaluates to nil.\\n\\n\\n\"","gh-username":"pepe","name":"repeat","created-at":1611170276},{"example":"(defn worker [m]\u000D\u000A  (thread/send m \"Hello function\")\u000D\u000A  (:send m \"Hello method\"))\u000D\u000A\u000D\u000A(thread/new worker)\u000D\u000A(pp (thread/receive)) # => prints Hello function\u000D\u000A(pp (thread/receive)) # => prints Hello method\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (thread/send thread msgi &opt timeout)\\n\\n    Send a message to the thread. By default, the timeout is 1 second,\\n    but an optional timeout in seconds can be provided. Use math/inf for\\n    no timeout. Will throw an error if there is a problem sending the\\n    message.\\n\\n\\n\"","gh-username":"pepe","name":"thread/send","created-at":1611170138},{"example":"(ev/call print 10)\u000D\u000A(ev/sleep 0.0001) # give ev a chance in the REPL, remove in file\u000D\u000A# => prints 10\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 3150, column 3\\n\\n    (ev/call f & args)\\n\\n    run the function.\\n\\n\\n\"","gh-username":"pepe","name":"ev/call","created-at":1611169850},{"example":"(seq [v :in (coro\u000D\u000A                (yield :hi)\u000D\u000A                (yield :bye))]\u000D\u000A    v)\u000D\u000A# => @[:hi :bye]","docstring":"\"\\n\\n    macro\\n    boot.janet on line 583, column 1\\n\\n    (coro & body)\\n\\n    A wrapper for making fibers. Same as (fiber/new (fn [] ;body) :yi).\\n\\n\\n\"","gh-username":"pepe","name":"coro","created-at":1611167513},{"example":"(def chan (ev/chan))\u000D\u000A(def f (ev/go (coro (ev/give-supervisor :msg \"Hello\")) nil chan))\u000D\u000A(pp (ev/take chan)) # => (:msg \"Hello\")\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (ev/give-supervsior tag & payload)\\n\\n    Send a message to the current supervior channel if there is one. The\\n    message will be a tuple of all of the arguments combined into a\\n    single message, where the first element is tag. By convention, tag\\n    should be a keyword indicating the type of message. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"ev/give-supervisor","created-at":1611167269},{"example":"(def f (ev/spawn 4))\u000D\u000A(ev/sleep 0.0001) # give ev a chance in the REPL, remove in file\u000D\u000A(fiber/last-value f) # => 4\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (fiber/last-value\\n\\n    Get the last value returned or signaled from the fiber.\\n\\n\\n\"","gh-username":"pepe","name":"fiber/last-value","created-at":1611164241},{"example":"(def f (fiber/new (fn [] (yield 2) 3)))\u000D\u000A(pp (resume f)) # => 2\u000D\u000A(resume f)\u000D\u000A(pp (fiber/last-value f)) # => 3\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (fiber/last-value\\n\\n    Get the last value returned or signaled from the fiber.\\n\\n\\n\"","gh-username":"pepe","name":"fiber/last-value","created-at":1611163947},{"example":"(forever\u000D\u000A  (print (os/time))\u000D\u000A  (ev/sleep 1))\u000D\u000A\u000D\u000A# => epoch clocks, prints epoch timestamp every second","docstring":"\"\\n\\n    macro\\n    boot.janet on line 512, column 1\\n\\n    (forever & body)\\n\\n    Evaluate body forever in a loop, or until a break statement.\\n\\n\\n\"","gh-username":"pepe","name":"forever","created-at":1611162685},{"example":"(freeze @\"Ho\") #=> \"Ho\"\u000D\u000A(freeze @(\"Ho\")) #=> (\"Ho\")\u000D\u000A(freeze @[\"Ho\"]) #=> (\"Ho\")\u000D\u000A(freeze @{\"Ho\" \"Ho\"}) #=> {\"Ho\" \"Ho\"}\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 2232, column 1\\n\\n    (freeze x)\\n\\n    Freeze an object (make it immutable) and do a deep copy, making child\\n    values also immutable. Closures, fibers, and abstract types will not\\n    be recursively frozen, but all other types will.\\n\\n\\n\"","gh-username":"pepe","name":"freeze","created-at":1611161419},{"example":"(in :yo 0)\u000D\u000A# => 121\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (in ds key &opt dflt)\\n\\n    Get value in ds at key, works on associative data structures. Arrays,\\n    tuples, tables, structs, strings, symbols, and buffers are all\\n    associative and can be used. Arrays, tuples, strings, buffers, and\\n    symbols must use integer keys that are in bounds or an error is\\n    raised. Structs and tables can take any value as a key except nil and\\n    will return nil or dflt if not found.\\n\\n\\n\"","gh-username":"sogaiu","name":"in","created-at":1611141580},{"example":"(in \"yo\" 0)\u000D\u000A# => 121\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (in ds key &opt dflt)\\n\\n    Get value in ds at key, works on associative data structures. Arrays,\\n    tuples, tables, structs, strings, symbols, and buffers are all\\n    associative and can be used. Arrays, tuples, strings, buffers, and\\n    symbols must use integer keys that are in bounds or an error is\\n    raised. Structs and tables can take any value as a key except nil and\\n    will return nil or dflt if not found.\\n\\n\\n\"","gh-username":"sogaiu","name":"in","created-at":1611141564},{"example":"(invert :yo)\u000D\u000A# => @{121 0 111 1}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1324, column 1\\n\\n    (invert ds)\\n\\n    Returns a table where the keys of an associative data structure are\\n    the values, and the values of the keys. If multiple keys have the\\n    same value, one key will be ignored.\\n\\n\\n\"","gh-username":"sogaiu","name":"invert","created-at":1611141495},{"example":"(invert \"yo\")\u000D\u000A# => @{121 0 111 1}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1324, column 1\\n\\n    (invert ds)\\n\\n    Returns a table where the keys of an associative data structure are\\n    the values, and the values of the keys. If multiple keys have the\\n    same value, one key will be ignored.\\n\\n\\n\"","gh-username":"sogaiu","name":"invert","created-at":1611141453},{"example":"(invert [:ant :bee :elephant :fox :penguin])\u000D\u000A# => @{:bee 1 :fox 3 :elephant 2 :ant 0 :penguin 4}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1324, column 1\\n\\n    (invert ds)\\n\\n    Returns a table where the keys of an associative data structure are\\n    the values, and the values of the keys. If multiple keys have the\\n    same value, one key will be ignored.\\n\\n\\n\"","gh-username":"sogaiu","name":"invert","created-at":1611122133},{"example":"(string/join @[\"1\" \"2\" \"3\"]) # => \"123\"\u000D\u000A# The esp argument is optional, and defaults to empty string","docstring":"\"\\n\\n    cfunction\\n\\n    (string/join parts &opt sep)\\n\\n    Joins an array of strings into one string, optionally separated by a\\n    separator string sep.\\n\\n\\n\"","gh-username":"yumaikas","name":"string/join","created-at":1611120056},{"example":"(doc-of file/read) # => file/read docs are shown\u000D\u000A\u000D\u000A(def tmpfile (file/temp))\u000D\u000A\u000D\u000A(doc-of (tmpfile :read)) # => also shows the file/read docs. \u000D\u000A# Note that we didn't have to use the file/read symbol here to get docs.","docstring":"\"\\n\\n    function\\n    boot.janet on line 2068, column 1\\n\\n    (doc-of x)\\n\\n    Searches all loaded modules in module/cache for a given binding and\\n    prints out its documentation. This does a search by value instead of\\n    by name. Returns nil.\\n\\n\\n\"","gh-username":"yumaikas","name":"doc-of","created-at":1611119925},{"example":"# Reading a file line by line, using loop's :iterate verb, and adding the line lengths\u000D\u000A\u000D\u000A(with [fl (file/open \"filepath\")]\u000D\u000A  (var sm 0)\u000D\u000A  (loop [line :iterate (file/read fl :line)]\u000D\u000A    (+= sm (length line)))\u000D\u000A   sm) \u000D\u000A \u000D\u000A\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (file/read f what &opt buf)\\n\\n    Read a number of bytes from a file `f` into a buffer. A buffer `buf`\\n    can be provided as an optional third argument, otherwise a new buffer\\n    is created. `what` can either be an integer or a keyword. Returns the\\n    buffer with file contents. Values for `what`:\\n\\n    * :all - read the whole file\\n\\n    * :line - read up to and including the next newline character\\n\\n    * n (integer) - read up to n bytes from the file\\n\\n\\n\"","gh-username":"MikeBeller","name":"file/read","created-at":1611069844},{"example":"# Convert an array of k/v pairs into a table\u000D\u000A\u000D\u000A(def kvp @[[:foo 1] [:bar 2]])\u000D\u000A(table ;(mapcat identity kvp))  # => @{:foo 1 :bar 2}","docstring":"\"\\n\\n    function\\n    boot.janet on line 927, column 1\\n\\n    (mapcat f ind)\\n\\n    Map a function over every element in an array or tuple and use array\\n    to concatenate the results.\\n\\n\\n\"","gh-username":"MikeBeller","name":"mapcat","created-at":1610574255},{"example":"(def u8s (tarray/new :uint8 10))\u000D\u000A(def i8s (tarray/new :int8 10))\u000D\u000A(def u16s (tarray/new :uint16 10))\u000D\u000A(def i16s (tarray/new :int16 10))\u000D\u000A(def u32s (tarray/new :uint32 10))\u000D\u000A(def i32s (tarray/new :int32 10))\u000D\u000A(def u64s (tarray/new :uint64 10))\u000D\u000A(def i64s (tarray/new :int64 10))\u000D\u000A(def f32s (tarray/new :float32 10))\u000D\u000A(def f64s (tarray/new :float64 10))\u000D\u000A\u000D\u000A(def f64s-every-other (tarray/new :float64 5 2 0 (tarray/buffer f64s))) # size 5, stride 2, offset 0\u000D\u000A\u000D\u000A(eachk x f64s (put f64s x x))\u000D\u000A(eachp x f64s-every-other (pp x))\u000D\u000A#->\u000D\u000A# (0 0)\u000D\u000A# (1 2)\u000D\u000A# (2 4)\u000D\u000A# (3 6)\u000D\u000A# (4 8)\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (tarray/new type size &opt stride offset tarray|buffer)\\n\\n    Create new typed array.\\n\\n\\n\"","gh-username":"Nananas","name":"tarray/new","created-at":1610535268},{"example":"# removes a file in the current directory\u000D\u000A(os/rm \"hello.txt\")","docstring":"\"\\n\\n    cfunction\\n\\n    (os/rm path)\\n\\n    Delete a file. Returns nil.\\n\\n\\n\"","gh-username":"swlkr","name":"os/rm","created-at":1610401015},{"example":"# create new file with content \"text\"\u000D\u000A(spit \"file.txt\" \"text\")\u000D\u000A\u000D\u000A# append to file\u000D\u000A(spit \"file.txt\" \"text\" :a)","docstring":"\"\\n\\n    function\\n    boot.janet on line 1557, column 1\\n\\n    (spit path contents &opt mode)\\n\\n    Write contents to a file at path. Can optionally append to the file.\\n\\n\\n\"","gh-username":"Krasjet","name":"spit","created-at":1610353395},{"example":"(<= 1 2 3) # => true\u000D\u000A(<= 1 2 1) # => false","docstring":"\"\\n\\n    function\\n\\n    (<= & xs)\\n\\n    Check if xs is in non-descending order. Returns a boolean.\\n\\n\\n\"","gh-username":"pepe","name":"<=","created-at":1610103630},{"example":"(peg/find-all ':d \"hi 1 bye 2\") # => @[3 9]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (peg/find-all peg text &opt start & args)\\n\\n    Find all indexes where the peg matches in text. Returns an array of\\n    integers.\\n\\n\\n\"","gh-username":"pepe","name":"peg/find-all","created-at":1610103212},{"example":"(ev/spawn (os/sleep 1) (print \"Hard work is done!\"))\u000D\u000A\u000D\u000A# prints \"Hard work is done!\" after one second\u000D\u000A# this is the easiest way to put some forms on the event loop\u000D\u000A# but do not forget REPL is blocking, for now, so run the example with `janet -e`","docstring":"\"\\n\\n    macro\\n    boot.janet on line 3156, column 3\\n\\n    (ev/spawn & body)\\n\\n    Run some code in a new fiber. This is shorthand for (ev/call (fn []\\n    ;body)).\\n\\n\\n\"","gh-username":"pepe","name":"ev/spawn","created-at":1610102867},{"example":"(def p1 (os/spawn [\"echo\" \"hello\"] :p {:out :pipe}))\u000D\u000A(def p2 (os/spawn [\"grep\" \"hello\"] :p {:in (p1 :out)}))\u000D\u000A\u000D\u000A(:wait p2)\u000D\u000A# Creates a pipeline (e.g. echo hello | grep hello)","docstring":"\"\\n\\n    cfunction\\n\\n    (os/spawn args &opts flags env)\\n\\n    Execute a program on the system and return a handle to the process.\\n    Otherwise, the same arguments as os/execute. Does not wait for the\\n    process.\\n\\n\\n\"","gh-username":"bakpakin","name":"os/spawn","created-at":1610039436},{"example":"(def a @[1 2 3])\u000D\u000A(def b (array/slice a))\u000D\u000A\u000D\u000A#=> good way to clone array, a and b are different arrays","docstring":"\"\\n\\n    cfunction\\n\\n    (array/slice arrtup &opt start end)\\n\\n    Takes a slice of array or tuple from start to end. The range is half\\n    open, [start, end). Indexes can also be negative, indicating indexing\\n    from the end of the end of the array. By default, start is 0 and end\\n    is the length of the array. Note that index -1 is synonymous with\\n    index (length arrtup) to allow a full negative slice range. Returns a\\n    new array.\\n\\n\\n\"","gh-username":"pepe","name":"array/slice","created-at":1609778546},{"example":"(array/slice [1 2 3])\u000D\u000A\u000D\u000A#=> @[1 2 3]\u000D\u000A# good way to convert tuple to array","docstring":"\"\\n\\n    cfunction\\n\\n    (array/slice arrtup &opt start end)\\n\\n    Takes a slice of array or tuple from start to end. The range is half\\n    open, [start, end). Indexes can also be negative, indicating indexing\\n    from the end of the end of the array. By default, start is 0 and end\\n    is the length of the array. Note that index -1 is synonymous with\\n    index (length arrtup) to allow a full negative slice range. Returns a\\n    new array.\\n\\n\\n\"","gh-username":"pepe","name":"array/slice","created-at":1609778402},{"example":"(merge {:a 1 :b 2})\u000D\u000A\u000D\u000A#=> @{:a 1 :b 2} \u000D\u000A# good way to convert struct to table","docstring":"\"\\n\\n    function\\n    boot.janet on line 1419, column 1\\n\\n    (merge & colls)\\n\\n    Merges multiple tables/structs to one. If a key appears in more than\\n    one collection, then later values replace any previous ones. Returns\\n    a new table.\\n\\n\\n\"","gh-username":"pepe","name":"merge","created-at":1609778337},{"example":"(table/to-struct @{:a 1}) # => {:a 1}","docstring":"\"\\n\\n    cfunction\\n\\n    (table/to-struct tab)\\n\\n    Convert a table to a struct. Returns a new struct. This function does\\n    not take into account prototype tables.\\n\\n\\n\"","gh-username":"swlkr","name":"table/to-struct","created-at":1609372608},{"example":"(dyn 'defn)\u000D\u000A# => @{:source-map (\"boot.janet\" 12 1) :value <function defn> :doc \"(defn name & more)\\n\\nDefine a function. Equivalent to (def name (fn name [args] ...)).\" :macro true}\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (dyn key &opt default)\\n\\n    Get a dynamic binding. Returns the default value (or nil) if no\\n    binding found.\\n\\n\\n\"","gh-username":"sogaiu","name":"dyn","created-at":1608465320},{"example":"(dyn :pretty-format)\u000D\u000A# => \"%.20Q\"","docstring":"\"\\n\\n    cfunction\\n\\n    (dyn key &opt default)\\n\\n    Get a dynamic binding. Returns the default value (or nil) if no\\n    binding found.\\n\\n\\n\"","gh-username":"sogaiu","name":"dyn","created-at":1608465247},{"example":"(varglobal \"smile\" false)\u000D\u000A# => nil\u000D\u000A\u000D\u000Asmile\u000D\u000A# => false\u000D\u000A\u000D\u000A(set smile true)\u000D\u000A# => smile\u000D\u000A\u000D\u000Asmile\u000D\u000A# => true\u000D\u000A\u000D\u000A(dyn 'smile)\u000D\u000A# => @{:ref @[true]}\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 79, column 1\\n\\n    (varglobal name init)\\n\\n    Dynamically create a global var.\\n\\n\\n\"","gh-username":"sogaiu","name":"varglobal","created-at":1608465209},{"example":"(some odd? [2 4 6 8 10])\u000D\u000A# => nil\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 2203, column 1\\n\\n    (some pred xs)\\n\\n    Returns nil if all xs are false or nil, otherwise returns the result\\n    of the first truthy predicate, (pred x).\\n\\n\\n\"","gh-username":"sogaiu","name":"some","created-at":1608446999},{"example":"(some even? [1 3 5 7 11 18])\u000D\u000A# => true\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 2203, column 1\\n\\n    (some pred xs)\\n\\n    Returns nil if all xs are false or nil, otherwise returns the result\\n    of the first truthy predicate, (pred x).\\n\\n\\n\"","gh-username":"sogaiu","name":"some","created-at":1608446988},{"example":"(let [tbl @{:a 1}]\u000D\u000A  (merge-into tbl {:b 2})\u000D\u000A  tbl)\u000D\u000A# => @{:a 1 :b 2}\u000D\u000A\u000D\u000A# real-world example: https://git.sr.ht/~subsetpark/bagatto/tree/19aea03fe23fe5486890912df7dc4a936ce617a3/item/main.janet#L23\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1409, column 1\\n\\n    (merge-into tab & colls)\\n\\n    Merges multiple tables/structs into a table. If a key appears in more\\n    than one collection, then later values replace any previous ones.\\n    Returns the original table.\\n\\n\\n\"","gh-username":"sogaiu","name":"merge-into","created-at":1608446902},{"example":"(string/find \"a\" \"abcdefa\" 1)\u000D\u000A# not yet documented start ^ position\u000D\u000A# => 6","docstring":"\"\\n\\n    cfunction\\n\\n    (string/find patt str)\\n\\n    Searches for the first instance of pattern patt in string str.\\n    Returns the index of the first character in patt if found, otherwise\\n    returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"string/find","created-at":1608195642},{"example":"(merge {:a 1 :b 2} \u000D\u000A       {:c 3 :a 4})\u000D\u000A# -> @{:c 3 :a 4 :b 2}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1419, column 1\\n\\n    (merge & colls)\\n\\n    Merges multiple tables/structs to one. If a key appears in more than\\n    one collection, then later values replace any previous ones. Returns\\n    a new table.\\n\\n\\n\"","gh-username":"Krasjet","name":"merge","created-at":1607918243},{"example":"# excess elements of the longer list are discarded\u000D\u000A(interleave [1] \u000D\u000A            [2 4] \u000D\u000A            [3 6])\u000D\u000A# -> @[1 2 3]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1469, column 1\\n\\n    (interleave & cols)\\n\\n    Returns an array of the first elements of each col, then the second,\\n    etc.\\n\\n\\n\"","gh-username":"Krasjet","name":"interleave","created-at":1607915842},{"example":"(interpose 0 [1])\u000D\u000A# -> @[1]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1513, column 1\\n\\n    (interpose sep ind)\\n\\n    Returns a sequence of the elements of ind separated by sep. Returns a\\n    new array.\\n\\n\\n\"","gh-username":"Krasjet","name":"interpose","created-at":1607915157},{"example":"(interpose 0 [1 2 3])\u000D\u000A# -> @[1 0 2 0 3]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1513, column 1\\n\\n    (interpose sep ind)\\n\\n    Returns a sequence of the elements of ind separated by sep. Returns a\\n    new array.\\n\\n\\n\"","gh-username":"Krasjet","name":"interpose","created-at":1607915147},{"example":"(when-let [root   (math/sqrt 64) \u000D\u000A           unused (even? root)] \u000D\u000A         (printf \"%d is even\" root))\u000D\u000A# -> \"8 is even\"","docstring":"\"\\n\\n    macro\\n    boot.janet on line 648, column 1\\n\\n    (when-let bindings & body)\\n\\n    Same as (if-let bindings (do ;body)).\\n\\n\\n\"","gh-username":"felixr","name":"when-let","created-at":1607878438},{"example":"In order to use :fresh, write:\u000D\u000A(import path :fresh true)","docstring":"\"\\n\\n    macro\\n    boot.janet on line 2889, column 1\\n\\n    (import path & args)\\n\\n    Import a module. First requires the module, and then merges its\\n    symbols into the current environment, prepending a given prefix as\\n    needed. (use the :as or :prefix option to set a prefix). If no prefix\\n    is provided, use the name of the module as a prefix. One can also use\\n    :export true to re-export the imported symbols. If :exit true is\\n    given as an argument, any errors encountered at the top level in the\\n    module will cause (os/exit 1) to be called. Dynamic bindings will NOT\\n    be imported. Use :fresh to bypass the module cache.\\n\\n\\n\"","gh-username":"Saikyun","name":"import","created-at":1607805776},{"example":"(as-> [1 2 3] _ \u000D\u000A  (map inc _)\u000D\u000A  (sum _)\u000D\u000A  (- _ 10)\u000D\u000A  (< _ 0))\u000D\u000A# -> true\u000D\u000A\u000D\u000A# same as\u000D\u000A(< (- (sum (map inc [1 2 3])) 10) 0)","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1220, column 1\\n\\n    (as-> x as & forms)\\n\\n    Thread forms together, replacing as in forms with the value of the\\n    previous form. The first for is the value x. Returns the last value.\\n\\n\\n\"","gh-username":"felixr","name":"as->","created-at":1607791510},{"example":"(->\u000D\u000A  {:a [1 2 3] :b [4 5 6]}\u000D\u000A  (get :a)\u000D\u000A  (sum)\u000D\u000A  (string \" is the result\"))\u000D\u000A# -> \"6 is the result\"\u000D\u000A\u000D\u000A# same as:\u000D\u000A(string (sum (get {:a [1 2 3] :b [4 5 6]} :a))\" is the result\")\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1121, column 1\\n\\n    (-> x & forms)\\n\\n    Threading macro. Inserts x as the second value in the first form in\\n    forms, and inserts the modified first form into the second form in\\n    the same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"felixr","name":"->","created-at":1607791027},{"example":"(->> \u000D\u000A  (string/split \" \" \"this  is an  example yes, an example\")\u000D\u000A  (filter (complement empty?))\u000D\u000A  (frequencies))\u000D\u000A# -> @{\"is\" 1 \"example\" 2 \"yes,\" 1 \"an\" 2 \"this\" 1}\u000D\u000A\u000D\u000A# same as:\u000D\u000A(frequencies\u000D\u000A  (filter\u000D\u000A    (complement empty?)\u000D\u000A    (string/split \" \" \"this  is an  example yes, an example\")))","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1134, column 1\\n\\n    (->> x & forms)\\n\\n    Threading macro. Inserts x as the last value in the first form in\\n    forms, and inserts the modified first form into the second form in\\n    the same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"felixr","name":"->>","created-at":1607790691},{"example":"# see https://janet-lang.org/docs/abstract_machine.html\u000D\u000A\u000D\u000A(def plus10\u000D\u000A (asm \u000D\u000A   '{\u000D\u000A     :arity 1\u000D\u000A     :bytecode @[(ldi 1 10)    # $1 = 10\u000D\u000A                 (add 2 0 1)   # $2 = $0 + $1\u000D\u000A                 (ret 2)]}))   # return $2\u000D\u000A\u000D\u000A(plus10 1) # -> 11","docstring":"\"\\n\\n    cfunction\\n\\n    (asm assembly)\\n\\n    Returns a new function that is the compiled result of the assembly.\\n    The syntax for the assembly can be found on the Janet website, and\\n    should correspond to the return value of disasm. Will throw an error\\n    on invalid assembly.\\n\\n\\n\"","gh-username":"felixr","name":"asm","created-at":1607782267},{"example":"(sort @[5 4 1 3 2])   # -> @[1 2 3 4 5]\u000D\u000A(sort @[5 4 1 3 2] >) # -> @[5 4 3 2 1]","docstring":"\"\\n\\n    function\\n    boot.janet on line 794, column 1\\n\\n    (sort a &opt by)\\n\\n    Sort an array in-place. Uses quick-sort and is not a stable sort.\\n\\n\\n\"","gh-username":"felixr","name":"sort","created-at":1607779529},{"example":"(sort-by\u000D\u000A  (fn [x] (get x :b)\u000D\u000A   @[{:a 1 :b 100} {:a 100 :b 1} {:a -1 :b 50}])\u000D\u000A\u000D\u000A# -> @[{:a 100 :b 1} {:a -1 :b 50} {:a 1 :b 100}]","docstring":"\"\\n\\n    function\\n    boot.janet on line 802, column 1\\n\\n    (sort-by f ind)\\n\\n    Returns a new sorted array that compares elements by invoking a\\n    function on each element and comparing the result with <.\\n\\n\\n\"","gh-username":"felixr","name":"sort-by","created-at":1607779386},{"example":"(def person-ids {\"Alice\" 42 \"Bob\" 23})\u000D\u000A\u000D\u000A(keep person-ids [\"Carl\" \"Bob\" \"Alice\"])   # -> @[23 42]\u000D\u000A\u000D\u000A(filter person-ids [\"Carl\" \"Bob\" \"Alice\"]) # -> @[\"Bob\" \"Alice\"]\u000D\u000A(map person-ids [\"Carl\" \"Bob\" \"Alice\"])    # -> @[nil 23 42]","docstring":"\"\\n\\n    function\\n    boot.janet on line 956, column 1\\n\\n    (keep pred ind)\\n\\n    Given a predicate `pred`, return a new array containing the truthy\\n    results of applying `pred` to each element in the indexed collection\\n    `ind`. This is different from `filter` which returns an array of the\\n    original elements where the predicate is truthy.\\n\\n\\n\"","gh-username":"felixr","name":"keep","created-at":1607778417},{"example":"(def record @{:recipient @{:name \"Bob\" :age 60} :sender @{:name \"Alice\" :age 21}})\u000D\u000A\u000D\u000A(put-in\u000D\u000A  record\u000D\u000A  [:sender :age] \u000D\u000A  26)\u000D\u000A\u000D\u000A# @{:recipient @{:name \"Bob\" :age 60} :sender @{:name \"Alice\" :age 26}}\u000D\u000A\u000D\u000A(put-in\u000D\u000A  record\u000D\u000A  [:recipient] \u000D\u000A  @{:name \"Carl\"})\u000D\u000A\u000D\u000A# @{:recipient @{:name \"Carl\"} :sender @{:name \"Alice\" :age 26}}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1379, column 1\\n\\n    (put-in ds ks v)\\n\\n    Put a value into a nested data structure. Looks into the data\\n    structure via a sequence of keys. Missing data structures will be\\n    replaced with tables. Returns the modified, original data structure.\\n\\n\\n\"","gh-username":"felixr","name":"put-in","created-at":1607617429},{"example":"(print\u000D\u000A  (prompt :a \u000D\u000A          (for i 0 1000000000000 \u000D\u000A            (print (string \"i=\" i))\u000D\u000A            (if (= i 2) \u000D\u000A                (return :a 10)))))\u000D\u000A# output:\u000D\u000A# i=0\u000D\u000A# i=1\u000D\u000A# i=2\u000D\u000A# 10","docstring":"\"\\n\\n    function\\n    boot.janet on line 358, column 1\\n\\n    (return to &opt value)\\n\\n    Return to a prompt point.\\n\\n\\n\"","gh-username":"felixr","name":"return","created-at":1607507080},{"example":"(print\u000D\u000A  (prompt :a \u000D\u000A          (for i 0 1000000000000 \u000D\u000A            (print (string \"i=\" i))\u000D\u000A            (if (= i 2) \u000D\u000A                (return :a 10)))))\u000D\u000A# output:\u000D\u000A# i=0\u000D\u000A# i=1\u000D\u000A# i=2\u000D\u000A# 10","docstring":"\"\\n\\n    macro\\n    boot.janet on line 330, column 1\\n\\n    (prompt tag & body)\\n\\n    Set up a checkpoint that can be returned to. Tag should be a value\\n    that is used in a return statement, like a keyword.\\n\\n\\n\"","gh-username":"felixr","name":"prompt","created-at":1607507029},{"example":"(describe @[:a :b]) # => \"<array 0x55EC375CF440>\"","docstring":"\"\\n\\n    cfunction\\n\\n    (describe x)\\n\\n    Returns a string that is a human-readable description of a value x.\\n\\n\\n\"","gh-username":"sogaiu","name":"describe","created-at":1607381162},{"example":"(describe {:a 1}) # => \"<struct 0x5564AF1BD6C0>\"","docstring":"\"\\n\\n    cfunction\\n\\n    (describe x)\\n\\n    Returns a string that is a human-readable description of a value x.\\n\\n\\n\"","gh-username":"sogaiu","name":"describe","created-at":1607381063},{"example":"### read a file line by line ###\u000D\u000A\u000D\u000A(let [f (file/open \"filename.txt\")] # bind an open file handle to \"f\"\u000D\u000A  (while true                       # loop until \"break\" is called\u000D\u000A    (let [l (file/read f :line)]    # bind a line of the file to \"l\" \u000D\u000A      (if l                         \u000D\u000A\u0009(print l)                   # if l is truthy print l\u000D\u000A\u0009(break))))                  # if l is not break from loop\u000D\u000A  (file/close f))                   # close the file handle \u000D\u000A\u000D\u000A\u000D\u000A# same as above but using \"with\"\u000D\u000A# this means there's no need to \u000D\u000A# call file/close, also replace\u000D\u000A# let with var\u000D\u000A(with [f (file/open \"filename.txt\")]\u000D\u000A      (while true\u000D\u000A\u0009(var l (file/read f :line))\u000D\u000A\u0009(if l\u000D\u000A\u0009  (print l)\u000D\u000A\u0009  (break))))","docstring":"\"\\n\\n    cfunction\\n\\n    (file/read f what &opt buf)\\n\\n    Read a number of bytes from a file `f` into a buffer. A buffer `buf`\\n    can be provided as an optional third argument, otherwise a new buffer\\n    is created. `what` can either be an integer or a keyword. Returns the\\n    buffer with file contents. Values for `what`:\\n\\n    * :all - read the whole file\\n\\n    * :line - read up to and including the next newline character\\n\\n    * n (integer) - read up to n bytes from the file\\n\\n\\n\"","gh-username":"yvan","name":"file/read","created-at":1607108623},{"example":"(defn test\u000D\u000A  [x]\u000D\u000A  (cond\u000D\u000A    (> x 10) \"Pretty big!\"\u000D\u000A    (< x 5) \"Quite small\"\u000D\u000A    \"Medium size\"))\u000D\u000A\u000D\u000A(test 40) # => \"Pretty big!\"\u000D\u000A(test 2) # => \"Quite small\"\u000D\u000A(test 6) # => \"Medium size\"","docstring":"\"\\n\\n    macro\\n    boot.janet on line 181, column 1\\n\\n    (cond & pairs)\\n\\n    Evaluates conditions sequentially until the first true condition is\\n    found, and then executes the corresponding body. If there are an odd\\n    number of forms, and no forms are matched, the last expression is\\n    executed. If there are no matches, return nil.\\n\\n\\n\"","gh-username":"pingiun","name":"cond","created-at":1606658964},{"example":"(reduce (fn [s1 s2]\u000D\u000A          (string \"[\" s1 \"+\" s2 \"]\"))\u000D\u000A        \"x\"\u000D\u000A        [\"a\" \"b\" \"c\"])\u000D\u000A\u000D\u000A#=> \"[[[x+a]+b]+c]\"\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 819, column 1\\n\\n    (reduce f init ind)\\n\\n    Reduce, also know as fold-left in many languages, transforms an\\n    indexed type (array, tuple) with a function to produce a value by\\n    applying f to each element in order. f is a function of 2 arguments,\\n    (f accum el), where accum is the initial value and el is the next\\n    value in the indexed type ind. f returns a value that will be used as\\n    accum in the next call to f. reduce returns the value of the final\\n    call to f.\\n\\n\\n\"","gh-username":"uvtc","name":"reduce","created-at":1606332118},{"example":"(filter (fn [x] (> x 2)) [1 2 3 4 5])  # @[3 4 5]","docstring":"\"\\n\\n    function\\n    boot.janet on line 936, column 1\\n\\n    (filter pred ind)\\n\\n    Given a predicate, take only elements from an array or tuple for\\n    which (pred element) is truthy. Returns a new array.\\n\\n\\n\"","gh-username":"btbytes","name":"filter","created-at":1606239416},{"example":"(os/lstat \"t.janet\")\u000D\u000A# @{:size 249 :permissions \"rw-r--r--\" :nlink 1 :blocks 8 :dev 16777221 :accessed 1606236760 :modified 1606236759 :uid 501 :mode :file :blocksize 4096 :changed 1606236759 :inode 14801850 :rdev 0 :int-permissions 420 :gid 501}\u000D\u000A\u000D\u000A(get (os/lstat \"t.janet\") :size)  # 249","docstring":"\"\\n\\n    cfunction\\n\\n    (os/lstat path &opt tab|key)\\n\\n    Like os/stat, but don't follow symlinks.\\n\\n\\n\\n\"","gh-username":"btbytes","name":"os/lstat","created-at":1606239175},{"example":"(do\u000D\u000A  (var a 88)\u000D\u000A  (+= a 12))  # 100\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 140, column 1\\n\\n    (+= x n)\\n\\n    Increments the var x by n.\\n\\n\\n\"","gh-username":"btbytes","name":"+=","created-at":1606207234},{"example":"(print (doc-format \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\" 30))\u000D\u000A\u000D\u000A    Lorem ipsum dolor\u000D\u000A    sit amet, consectetur\u000D\u000A    adipiscing elit, sed\u000D\u000A    do eiusmod tempor\u000D\u000A    incididunt ut labore\u000D\u000A    et dolore magna\u000D\u000A    aliqua. Ut enim ad\u000D\u000A    minim veniam, quis\u000D\u000A    nostrud exercitation\u000D\u000A    ullamco laboris nisi\u000D\u000A    ut aliquip ex ea\u000D\u000A    commodo consequat.\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1780, column 1\\n\\n    (doc-format str &opt width indent)\\n\\n    Reformat a docstring to wrap a certain width. Docstrings can either\\n    be plaintext or a subset of markdown. This allows a long single line\\n    of prose or formatted text to be a well-formed docstring. Returns a\\n    buffer containing the formatted text.\\n\\n\\n\"","gh-username":"btbytes","name":"doc-format","created-at":1606207006},{"example":"(mod 13 5)  # 3","docstring":"\"\\n\\n    function\\n\\n    (mod dividend divisor)\\n\\n    Returns the modulo of dividend / divisor.\\n\\n\\n\"","gh-username":"btbytes","name":"mod","created-at":1606206533},{"example":"(math/random)  # 0.487181","docstring":"\"\\n\\n    cfunction\\n\\n    (math/random)\\n\\n    Returns a uniformly distributed random number between 0 and 1.\\n\\n\\n\"","gh-username":"btbytes","name":"math/random","created-at":1606206452},{"example":"(sorted [1 -2 2 3 9 -10])  # @[-10 -2 1 2 3 9]","docstring":"\"\\n\\n    function\\n    boot.janet on line 808, column 1\\n\\n    (sorted ind &opt by)\\n\\n    Returns a new sorted array without modifying the old one.\\n\\n\\n\"","gh-username":"btbytes","name":"sorted","created-at":1606206312},{"example":"(take 2 [1 -2 2 3 9 -10])  # (1 -2)","docstring":"\"\\n\\n    function\\n    boot.janet on line 1033, column 1\\n\\n    (take n ind)\\n\\n    Take first n elements in an indexed type. Returns new indexed\\n    instance.\\n\\n\\n\"","gh-username":"btbytes","name":"take","created-at":1606206194},{"example":"(math/atan 1)    # 0.785398\u000D\u000A(math/atan 0.5)  # 0.463648","docstring":"\"\\n\\n    cfunction\\n\\n    (math/atan x)\\n\\n    Returns the arctangent of x.\\n\\n\\n\"","gh-username":"btbytes","name":"math/atan","created-at":1606205699},{"example":"# catch and propagate an error with fiber\u000D\u000A\u000D\u000A(try\u000D\u000A  (+ 1 nil)\u000D\u000A  ([err fib]\u000D\u000A   (propagate err fib)))","docstring":"\"\\n\\n    macro\\n    boot.janet on line 232, column 1\\n\\n    (try body catch)\\n\\n    Try something and catch errors. Body is any expression, and catch\\n    should be a form with the first element a tuple. This tuple should\\n    contain a binding for errors and an optional binding for the fiber\\n    wrapping the body. Returns the result of body if no error, or the\\n    result of catch if an error.\\n\\n\\n\"","gh-username":"swlkr","name":"try","created-at":1605556163},{"example":"(compare> 1 0) # => true\u000D\u000A(compare> 10 9.9) # => true\u000D\u000A(compare> :a :b) # => false\u000D\u000A(compare> :b :a) # => true","docstring":"\"\\n\\n    function\\n    boot.janet on line 743, column 1\\n\\n    (compare> & xs)\\n\\n    Equivalent of `>` but using polymorphic `compare` instead of\\n    primitive comparator.\\n\\n\\n\"","gh-username":"swlkr","name":"compare>","created-at":1604702708},{"example":"(defn read-from-file [file-path]\u000D\u000A  (let [f (file/open file-path :r)\u000D\u000A        content  (file/read f :all)]\u000D\u000A    (file/close f)\u000D\u000A    content))\u000D\u000A\u000D\u000A### USAGE \u000D\u000A\u000D\u000A(read-from-file \"/path/to/file-read-example.janet\")\u000D\u000A# => @\"(defn read-from-file [file-path]\\n  (let [f (file/open file-path :r)\\n        content  (file/read f :all)]\\n    (file/close f)\\n    content))\\n\"","docstring":"\"\\n\\n    cfunction\\n\\n    (file/read f what &opt buf)\\n\\n    Read a number of bytes from a file `f` into a buffer. A buffer `buf`\\n    can be provided as an optional third argument, otherwise a new buffer\\n    is created. `what` can either be an integer or a keyword. Returns the\\n    buffer with file contents. Values for `what`:\\n\\n    * :all - read the whole file\\n\\n    * :line - read up to and including the next newline character\\n\\n    * n (integer) - read up to n bytes from the file\\n\\n\\n\"","gh-username":"harryvederci","name":"file/read","created-at":1603558237},{"example":"(defn to-double-digit-string [digit]\u000D\u000A  (string/slice (string \"0\" digit) -3))\u000D\u000A\u000D\u000A(defn get-date-time-string [time]\u000D\u000A  (let [date (os/date time)\u000D\u000A        year (get date :year)\u000D\u000A        month (to-double-digit-string (get date :month))\u000D\u000A        day (to-double-digit-string (get date :month-day))\u000D\u000A        hours (to-double-digit-string (get date :hours))\u000D\u000A        minutes (to-double-digit-string (get date :minutes))\u000D\u000A        seconds (to-double-digit-string (get date :seconds))]\u000D\u000A    (string year \"-\" month \"-\" day \"__\" hours \":\" minutes \":\" seconds)))\u000D\u000A\u000D\u000A(defn get-current-date-time-string []\u000D\u000A  (get-date-time-string (os/time)))\u000D\u000A\u000D\u000A\u000D\u000A### USAGE\u000D\u000A\u000D\u000A(get-current-date-time-string)\u000D\u000A# => \"2020-09-23__17:20:00\"","docstring":"\"\\n\\n    cfunction\\n\\n    (os/date &opt time local)\\n\\n    Returns the given time as a date struct, or the current time if\\n    `time` is not given. Returns a struct with following key values. Note\\n    that all numbers are 0-indexed. Date is given in UTC unless `local`\\n    is truthy, in which case the date is formatted for the local\\n    timezone.\\n\\n    * :seconds - number of seconds [0-61]\\n\\n    * :minutes - number of minutes [0-59]\\n\\n    * :hours - number of hours [0-23]\\n\\n    * :month-day - day of month [0-30]\\n\\n    * :month - month of year [0, 11]\\n\\n    * :year - years since year 0 (e.g. 2019)\\n\\n    * :week-day - day of the week [0-6]\\n\\n    * :year-day - day of the year [0-365]\\n\\n    * :dst - if Day Light Savings is in effect\\n\\n\\n\"","gh-username":"harryvederci","name":"os/date","created-at":1603557001},{"example":"# opens a file named filename for writing, and writes Hello World!\u000D\u000A(def f (file/open \"filename\" :w))\u000D\u000A(file/write f \"Hello World!\")\u000D\u000A(file/flush f)\u000D\u000A(file/close f)","docstring":"\"\\n\\n    cfunction\\n\\n    (file/write f bytes)\\n\\n    Writes to a file. 'bytes' must be string, buffer, or symbol. Returns\\n    the file.\\n\\n\\n\"","gh-username":"terminalcommand","name":"file/write","created-at":1602881414},{"example":"(comment this is a\u000D\u000A         multiline line comment.\u000D\u000A         It won't do anything)","docstring":"\"\\n\\n    macro\\n    boot.janet on line 162, column 1\\n\\n    (comment &)\\n\\n    Ignores the body of the comment.\\n\\n\\n\"","gh-username":"oz123","name":"comment","created-at":1602610011},{"example":"(defn ddup [ds ks val]\u000D\u000A  (update-in ds ks\u000D\u000A    (fn [x]\u000D\u000A      (if (= nil x)\u000D\u000A        @[val]\u000D\u000A        (array/push x val)))))\u000D\u000A\u000D\u000A(var a @{})\u000D\u000A(ddup a [:a] 1)\u000D\u000A(ddup a [:a] 2)\u000D\u000A(ddup a [:a] 3)\u000D\u000A# @{:a @[1 2 3]}\u000D\u000A\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1357, column 1\\n\\n    (update-in ds ks f & args)\\n\\n    Update a value in a nested data structure by applying f to the\\n    current value. Looks into the data structure via a sequence of keys.\\n    Missing data structures will be replaced with tables. Returns the\\n    modified, original data structure.\\n\\n\\n\"","gh-username":"sbjaver","name":"update-in","created-at":1602463691},{"example":"(update-in @{:a @{:b 1}} [:a :b] (fn [x] (+ 1 x)))\u000D\u000A# @{:a @{:b 2}}\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1357, column 1\\n\\n    (update-in ds ks f & args)\\n\\n    Update a value in a nested data structure by applying f to the\\n    current value. Looks into the data structure via a sequence of keys.\\n    Missing data structures will be replaced with tables. Returns the\\n    modified, original data structure.\\n\\n\\n\"","gh-username":"sbjaver","name":"update-in","created-at":1602463612},{"example":"(update-in @{:a 1} [:a] (fn [x] (+ 1 x)))\u000D\u000A# @{:a 2}\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1357, column 1\\n\\n    (update-in ds ks f & args)\\n\\n    Update a value in a nested data structure by applying f to the\\n    current value. Looks into the data structure via a sequence of keys.\\n    Missing data structures will be replaced with tables. Returns the\\n    modified, original data structure.\\n\\n\\n\"","gh-username":"sbjaver","name":"update-in","created-at":1602463581},{"example":"(eval-string \"(+ 1 2 3 4)\") # -> 10\u000D\u000A(eval-string \")\") # -> parse error\u000D\u000A(eval-string \"(bloop)\") # -> compile error\u000D\u000A(eval-string \"(+ nil nil)\") # -> runtime error","docstring":"\"\\n\\n    function\\n    boot.janet on line 2561, column 1\\n\\n    (eval-string str)\\n\\n    Evaluates a string in the current environment. If more control over\\n    the environment is needed, use run-context.\\n\\n\\n\"","gh-username":"swlkr","name":"eval-string","created-at":1602038987},{"example":"(if-let [x true \u000D\u000A         y (not (not x))]\u000D\u000A  :a\u000D\u000A  :b)\u000D\u000A# => :a\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 617, column 1\\n\\n    (if-let bindings tru &opt fal)\\n\\n    Make multiple bindings, and if all are truthy, evaluate the tru form.\\n    If any are false or nil, evaluate the fal form. Bindings have the\\n    same syntax as the let macro.\\n\\n\\n\"","gh-username":"sogaiu","name":"if-let","created-at":1601013276},{"example":"(if-let [x true \u000D\u000A         y (not x)]\u000D\u000A  :a\u000D\u000A  :b)\u000D\u000A# => :b\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 617, column 1\\n\\n    (if-let bindings tru &opt fal)\\n\\n    Make multiple bindings, and if all are truthy, evaluate the tru form.\\n    If any are false or nil, evaluate the fal form. Bindings have the\\n    same syntax as the let macro.\\n\\n\\n\"","gh-username":"sogaiu","name":"if-let","created-at":1601013237},{"example":"(partition 2 [:a 1 :b 2 :c 3])\u000D\u000A# => @[(:a 1) (:b 2) (:c 3)]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1526, column 1\\n\\n    (partition n ind)\\n\\n    Partition an indexed data structure into tuples of size n. Returns a\\n    new array.\\n\\n\\n\"","gh-username":"sogaiu","name":"partition","created-at":1601013032},{"example":"(interleave [:a :b :c] \u000D\u000A            [1 2 3] \u000D\u000A            [\"x\" \"y\" \"z\"])\u000D\u000A# => @[:a 1 \"x\" :b 2 \"y\" :c 3 \"z\"]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1469, column 1\\n\\n    (interleave & cols)\\n\\n    Returns an array of the first elements of each col, then the second,\\n    etc.\\n\\n\\n\"","gh-username":"sogaiu","name":"interleave","created-at":1601012972},{"example":"(invert {:a 1 :b 2 :c 3})\u000D\u000A# => @{3 :c 1 :a 2 :b}","docstring":"\"\\n\\n    function\\n    boot.janet on line 1324, column 1\\n\\n    (invert ds)\\n\\n    Returns a table where the keys of an associative data structure are\\n    the values, and the values of the keys. If multiple keys have the\\n    same value, one key will be ignored.\\n\\n\\n\"","gh-username":"sogaiu","name":"invert","created-at":1601011392},{"example":"(eachk [k v] {:a \"a val\" :b \"b val\" :c \"c val\"} (print k \" - \" v))\u000D\u000A# prints c - c val\u000D\u000A# prints a - a val\u000D\u000A# prints b - b val","docstring":"\"\\n\\n    macro\\n    boot.janet on line 501, column 1\\n\\n    (eachp x ds & body)\\n\\n    Loop over each (key, value) pair in ds. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"eachp","created-at":1600080366},{"example":"(eachk k [1 2 3] (print k))\u000D\u000A# prints 0\u000D\u000A# prints 1\u000D\u000A# prints 2\u000D\u000A# for indexed collections indices are printed  ","docstring":"\"\\n\\n    macro\\n    boot.janet on line 496, column 1\\n\\n    (eachk x ds & body)\\n\\n    Loop over each key in ds. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"eachk","created-at":1600080285},{"example":"(eachk k {:a \"a val\" :b \"b val\" :c \"c val\"} (print k))\u000D\u000A# prints c\u000D\u000A# prints a\u000D\u000A# prints b","docstring":"\"\\n\\n    macro\\n    boot.janet on line 496, column 1\\n\\n    (eachk x ds & body)\\n\\n    Loop over each key in ds. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"eachk","created-at":1600080185},{"example":"(each item [1 2 3 4] (print item))\u000D\u000A# prints 1\u000D\u000A# prints 2\u000D\u000A# prints 3\u000D\u000A# prints 4\u000D\u000A# => nil","docstring":"\"\\n\\n    macro\\n    boot.janet on line 517, column 1\\n\\n    (each x ds & body)\\n\\n    Loop over each value in ds. Returns nil.\\n\\n\\n\"","gh-username":"pepe","name":"each","created-at":1600079745},{"example":"(let [len 8\u000D\u000A      rand-string (string/join (map |(string/format \"%02x\" $)\u000D\u000A                                    (os/cryptorand len)))]\u000D\u000A  (= (length rand-string) (* 2 len))) # => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/cryptorand n &opt buf)\\n\\n    Get or append n bytes of good quality random data provided by the OS.\\n    Returns a new buffer or buf.\\n\\n\\n\"","gh-username":"sogaiu","name":"os/cryptorand","created-at":1598496767},{"example":"(os/execute\u000D\u000A  @(\"/usr/bin/bash\" \"-c\" \"set\")\u000D\u000A  :e\u000D\u000A  @{\"SOME\" \"value\"\u000D\u000A    \"OTHER\" \"one\"})\u000D\u000A# => 0\u000D\u000A\u000D\u000A# execute bash and prints environment variables\u000D\u000A# which contains SOME=value and Other=one","docstring":"\"\\n\\n    cfunction\\n\\n    (os/execute args &opts flags env)\\n\\n    Execute a program on the system and pass it string arguments. `flags`\\n    is a keyword that modifies how the program will execute.\\n\\n    * :e - enables passing an environment to the program. Without :e, the\\n      current environment is inherited.\\n\\n    * :p - allows searching the current PATH for the binary to execute.\\n      Without this flag, binaries must use absolute paths.\\n\\n    * :x - raise error if exit code is non-zero.\\n\\n    `env` is a table or struct mapping environment variables to values.\\n    It can also contain the keys :in, :out, and :err, which allow\\n    redirecting stdio in the subprocess. These arguments should be\\n    core/file values. One can also pass in the :pipe keyword for these\\n    arguments to create files that will read (for :err and :out) or write\\n    (for :in) to the file descriptor of the subprocess. This is only\\n    useful in `os/spawn`, which takes the same parameters as\\n    `os/execute`, but will return an object that contains references to\\n    these files via (return-value :in), (return-value :out), and\\n    (return-value :err). Returns the exit status of the program.\\n\\n\\n\"","gh-username":"goldenHairDafo","name":"os/execute","created-at":1598467159},{"example":"(os/execute\u000D\u000A  @(\"python\" \"-c\" \"print('Hello Janet'\"))\u000D\u000A  :p) \u000D\u000A# => 0\u000D\u000A\u000D\u000A# execute python -c \"print('Hello Janet') while\u000D\u000A# searching path on the current path","docstring":"\"\\n\\n    cfunction\\n\\n    (os/execute args &opts flags env)\\n\\n    Execute a program on the system and pass it string arguments. `flags`\\n    is a keyword that modifies how the program will execute.\\n\\n    * :e - enables passing an environment to the program. Without :e, the\\n      current environment is inherited.\\n\\n    * :p - allows searching the current PATH for the binary to execute.\\n      Without this flag, binaries must use absolute paths.\\n\\n    * :x - raise error if exit code is non-zero.\\n\\n    `env` is a table or struct mapping environment variables to values.\\n    It can also contain the keys :in, :out, and :err, which allow\\n    redirecting stdio in the subprocess. These arguments should be\\n    core/file values. One can also pass in the :pipe keyword for these\\n    arguments to create files that will read (for :err and :out) or write\\n    (for :in) to the file descriptor of the subprocess. This is only\\n    useful in `os/spawn`, which takes the same parameters as\\n    `os/execute`, but will return an object that contains references to\\n    these files via (return-value :in), (return-value :out), and\\n    (return-value :err). Returns the exit status of the program.\\n\\n\\n\"","gh-username":"goldenHairDafo","name":"os/execute","created-at":1598466977},{"example":"(defn output [x]\u000D\u000A  (case x\u000D\u000A    :a \"a\"\u000D\u000A    \"b\"))\u000D\u000A\u000D\u000A(output :a) # => \"a\"\u000D\u000A(output \"anything else\") # => \"b\"","docstring":"\"\\n\\n    macro\\n    boot.janet on line 196, column 1\\n\\n    (case dispatch & pairs)\\n\\n    Select the body that equals the dispatch value. When pairs has an odd\\n    number of arguments, the last is the default expression. If no match\\n    is found, returns nil.\\n\\n\\n\"","gh-username":"swlkr","name":"case","created-at":1595980046},{"example":"(first [4 5 6])  # => 4","docstring":"\"\\n\\n    function\\n    boot.janet on line 694, column 1\\n\\n    (first xs)\\n\\n    Get the first element from an indexed data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"first","created-at":1595968450},{"example":"(flatten [1 [2 3 [4]] 5])  # => @[1 2 3 4 5]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1499, column 1\\n\\n    (flatten xs)\\n\\n    Takes a nested array (tree), and returns the depth first traversal of\\n    that array. Returns a new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"flatten","created-at":1595965683},{"example":"> (eprin \"there is a boo-boo on line \" 33 \"\\n\")\u000D\u000Athere is a boo-boo on line 33\u000D\u000Anil\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (eprin & xs)\\n\\n    Same as prin, but uses (dyn :err stderr) instead of (dyn :out\\n    stdout).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"eprin","created-at":1595957432},{"example":"(update @[3 4 5] 1 dec)  # => @[3 3 5]\u000D\u000A(update (update @[3 4 5] 1 dec) 2 inc)  # => @[3 3 6]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1401, column 1\\n\\n    (update ds key func & args)\\n\\n    Accepts a key argument and passes its associated value to a function.\\n    The key is then re-associated to the function's return value. Returns\\n    the updated data structure `ds`.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"update","created-at":1595957268},{"example":"(get @\"A\"                      0)  # => 65 (0b01000001)\u000D\u000A(get (buffer/bit-clear @\"A\" 0) 0)  # => 64 (0b01000000)\u000D\u000A(get (buffer/bit-clear @\"A\" 6) 0)  # =>  1 (0b00000001)\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/bit-clear buffer index)\\n\\n    Clears the bit at the given bit-index. Returns the buffer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"buffer/bit-clear","created-at":1595956867},{"example":"(defn square [x] (* x x))\u000D\u000A(defn square-then-dec [x] ((comp dec square) x))\u000D\u000A(defn dec-then-square [x] ((comp square dec) x))\u000D\u000A(square-then-dec 3)  # => 8\u000D\u000A(dec-then-square 3)  # => 4\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 653, column 1\\n\\n    (comp & functions)\\n\\n    Takes multiple functions and returns a function that is the\\n    composition of those functions.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"comp","created-at":1595956449},{"example":"(any? [false false nil]) => nil\u000D\u000A(any? [false false nil 1]) => 1\u000D\u000A(any? [false false nil true]) => true","docstring":"\"\\n\\n    function\\n    boot.janet on line 1289, column 1\\n\\n    (any? ind)\\n\\n    Returns the first truthy value in ind, otherwise nil. falsey value.\\n\\n\\n\"","gh-username":"swlkr","name":"any?","created-at":1595527200},{"example":"(buffer/bit (buffer/new-filled 1 (chr \"0\")) 4)\u000D\u000A# => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/bit buffer index)\\n\\n    Gets the bit at the given bit-index. Returns true if the bit is set,\\n    false if not.\\n\\n\\n\"","gh-username":"sogaiu","name":"buffer/bit","created-at":1595035493},{"example":"(buffer/bit (buffer/new-filled 1 48) 4)\u000D\u000A# => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/bit buffer index)\\n\\n    Gets the bit at the given bit-index. Returns true if the bit is set,\\n    false if not.\\n\\n\\n\"","gh-username":"sogaiu","name":"buffer/bit","created-at":1595035467},{"example":"(buffer/bit @\"0\" 4)\u000D\u000A# => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/bit buffer index)\\n\\n    Gets the bit at the given bit-index. Returns true if the bit is set,\\n    false if not.\\n\\n\\n\"","gh-username":"sogaiu","name":"buffer/bit","created-at":1595035246},{"example":"(buffer/bit @\"1\" 0)\u000D\u000A# => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/bit buffer index)\\n\\n    Gets the bit at the given bit-index. Returns true if the bit is set,\\n    false if not.\\n\\n\\n\"","gh-username":"sogaiu","name":"buffer/bit","created-at":1595035122},{"example":"(buffer/format @\"0 - 1 = \" \"%d\" -1)\u000D\u000A# => @\"0 - 1 = -1\"","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/format buffer format & args)\\n\\n    Snprintf like functionality for printing values into a buffer.\\n    Returns the modified buffer.\\n\\n\\n\"","gh-username":"sogaiu","name":"buffer/format","created-at":1595034970},{"example":"(put-in  @{:a @{:aa 5} :b @{:bb 6}}  [:c]          9)  # => @{:a @{:aa 5} :b @{:bb 6} :c 9}\u000D\u000A(put-in  @{:a @{:aa 5} :b @{:bb 6}}  [:a :aa]      9)  # => @{:a @{:aa 9} :b @{:bb 6}}\u000D\u000A(put-in  @{:a @{:aa 5} :b @{:bb 6}}  [:a :cc :ddd] 9)  # => @{:a @{:cc @{:ddd 9} :aa 5} :b @{:bb 6}}\u000D\u000A\u000D\u000A(put-in  @[:a :b @[:aa :bb :cc]]  [2 1] :zz )  # => @[:a :b @[:aa :zz :cc]]\u000D\u000A(put-in  @[:a :b @[:aa :bb :cc]]  [5]   :z  )  # => @[:a :b @[:aa :bb :cc] nil nil :z]\u000D\u000A\u000D\u000A(put-in  @[:a :b @[:aa :bb :cc]]  [4 0]   :zz )  # => @[:a :b @[:aa :bb :cc] nil @{0 :zz}]\u000D\u000A(put-in  @[:a :b @[:aa :bb :cc]]  [4 :yy] :zz )  # => @[:a :b @[:aa :bb :cc] nil @{:yy :zz}]\u000D\u000A\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1379, column 1\\n\\n    (put-in ds ks v)\\n\\n    Put a value into a nested data structure. Looks into the data\\n    structure via a sequence of keys. Missing data structures will be\\n    replaced with tables. Returns the modified, original data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"put-in","created-at":1593914303},{"example":"(put  @{:a 4 :b 5}  :c 6         )  # => @{:a 4 :b 5 :c 6}\u000D\u000A(put  @{:a 4 :b 5}  :b nil       )  # => @{:a 4}\u000D\u000A(put  @{:a 4 :b 5}  :z nil       )  # => @{:a 4 :b 5}\u000D\u000A\u000D\u000A(put  @[:a :b :c]   0  :z        )  # => @[:z :b :c]\u000D\u000A(put  @[:a :b :c]   1  nil       )  # => @[:a nil :c]\u000D\u000A\u000D\u000A(put  @[:a :b :c]   5  :d        )  # => @[:a :b :c nil nil :d]\u000D\u000A\u000D\u000A(put  @\"hello\"      0  \"z\"       )  # error: can only put integers in buffers\u000D\u000A(defn ord [ch] (first (string/bytes ch)))\u000D\u000A(ord \"z\")  # => 122\u000D\u000A(put  @\"hello\"      0  122       )  # => @\"zello\"\u000D\u000A(put  @\"hello\"      0  (ord \"z\") )  # => @\"zello\"\u000D\u000A(put  @\"hello\"      8  (ord \"y\") )  # => @\"hello\\0\\0\\0y\"\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (put ds key value)\\n\\n    Associate a key with a value in any mutable associative data\\n    structure. Indexed data structures (arrays and buffers) only accept\\n    non-negative integer keys, and will expand if an out of bounds value\\n    is provided. In an array, extra space will be filled with nils, and\\n    in a buffer, extra space will be filled with 0 bytes. In a table,\\n    putting a key that is contained in the table prototype will hide the\\n    association defined by the prototype, but will not mutate the\\n    prototype table. Putting a value nil into a table will remove the key\\n    from the table. Returns the data structure ds.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"put","created-at":1593913019},{"example":"(next  [4 5 6]    )  # => 0\u000D\u000A(next  [4 5 6]  0 )  # => 1\u000D\u000A(next  [4 5 6]  1 )  # => 2\u000D\u000A(next  [4 5 6]  2 )  # => nil\u000D\u000A\u000D\u000A# note that dictionary keys are not necessarily in the same order\u000D\u000A# as the corresponding literal.\u000D\u000A(next  {:a 5 :b 6 :c 7}     )  # => :a\u000D\u000A(next  {:a 5 :b 6 :c 7}  :a )  # => :c\u000D\u000A(next  {:a 5 :b 6 :c 7}  :c )  # => :b\u000D\u000A(next  {:a 5 :b 6 :c 7}  :b )  # => nil\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (next ds &opt key)\\n\\n    Gets the next key in a data structure. Can be used to iterate through\\n    the keys of a data structure in an unspecified order. Keys are\\n    guaranteed to be seen only once per iteration if they data structure\\n    is not mutated during iteration. If key is nil, next returns the\\n    first key. If next returns nil, there are no more keys to iterate\\n    through.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"next","created-at":1593911557},{"example":"(or true)        # => true\u000D\u000A(or true true)   # => true\u000D\u000A(or true false)  # => true\u000D\u000A\u000D\u000A(or false 1 2)  # => 1\u000D\u000A(or false 2 1)  # => 2\u000D\u000A\u000D\u000A(or false nil)  # => nil\u000D\u000A(or nil false)  # => false\u000D\u000A\u000D\u000A# note that `or` does not behave as you might expect\u000D\u000A# when used with `apply` and `splice`:\u000D\u000A(or 1 2 3)             # => 1\u000D\u000A(or (splice [1 2 3]))  # => (1 2 3)\u000D\u000A(apply or [1 2 3])     # => (if 1 1 (if 2 2 3))\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 276, column 1\\n\\n    (or & forms)\\n\\n    Evaluates to the last argument if all preceding elements are falsey,\\n    otherwise evaluates to the first truthy element.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"or","created-at":1593911207},{"example":"(map false? [ false nil   true  0     1     42    'a    :a    \"a\"   [97]  {:a 42} (fn []) ])\u000D\u000A# =>       @[ true  false false false false false false false false false false   false   ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 113, column 1\\n\\n    (false? x)\\n\\n    Check if x is false.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"false?","created-at":1593910125},{"example":"(map true? [ true nil   false 0     1     42    'a    :a    \"a\"   [97]  {:a 42} (fn []) ])\u000D\u000A# =>      @[ true false false false false false false false false false false   false   ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 112, column 1\\n\\n    (true? x)\\n\\n    Check if x is true.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"true?","created-at":1593909983},{"example":"(map bytes?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  true  true   true   false    false     false        false         ]\u000D\u000A\u000D\u000A(map symbol?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  false false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map keyword?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false true  false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map string?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false true   false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map buffer?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  true   false    false     false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 90, column 1\\n\\n    (string? x)\\n\\n    Check if x is a string.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string?","created-at":1593893482},{"example":"(map bytes?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  true  true   true   false    false     false        false         ]\u000D\u000A\u000D\u000A(map symbol?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  false false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map keyword?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false true  false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map string?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false true   false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map buffer?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  true   false    false     false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 92, column 1\\n\\n    (keyword? x)\\n\\n    Check if x is a keyword.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"keyword?","created-at":1593893475},{"example":"(map bytes?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  true  true   true   false    false     false        false         ]\u000D\u000A\u000D\u000A(map symbol?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  false false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map keyword?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false true  false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map string?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false true   false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map buffer?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  true   false    false     false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 91, column 1\\n\\n    (symbol? x)\\n\\n    Check if x is a symbol.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"symbol?","created-at":1593893468},{"example":"(map  |($ {:a 7 :b 8} )   [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[:a :b]  @[7 8]    @[:a 7 :b 8]    @[(:a 7) (:b 8)]      ]\u000D\u000A\u000D\u000A(map  |($ [4 5 6] )       [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1 2]  @[4 5 6]  @[0 4 1 5 2 6]  @[(0 4) (1 5) (2 6)]  ]\u000D\u000A\u000D\u000A(map  |($ 'ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ :ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ \"ab\" )          [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1450, column 1\\n\\n    (pairs x)\\n\\n    Get the key-value pairs of an associative data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"pairs","created-at":1593890440},{"example":"(map  |($ {:a 7 :b 8} )   [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[:a :b]  @[7 8]    @[:a 7 :b 8]    @[(:a 7) (:b 8)]      ]\u000D\u000A\u000D\u000A(map  |($ [4 5 6] )       [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1 2]  @[4 5 6]  @[0 4 1 5 2 6]  @[(0 4) (1 5) (2 6)]  ]\u000D\u000A\u000D\u000A(map  |($ 'ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ :ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ \"ab\" )          [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1505, column 1\\n\\n    (kvs dict)\\n\\n    Takes a table or struct and returns and array of key value pairs like\\n    @[k v k v ...]. Returns a new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"kvs","created-at":1593889782},{"example":"(map  |($ {:a 7 :b 8} )   [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[:a :b]  @[7 8]    @[:a 7 :b 8]    @[(:a 7) (:b 8)]      ]\u000D\u000A\u000D\u000A(map  |($ [4 5 6] )       [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1 2]  @[4 5 6]  @[0 4 1 5 2 6]  @[(0 4) (1 5) (2 6)]  ]\u000D\u000A\u000D\u000A(map  |($ 'ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ :ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ \"ab\" )          [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1440, column 1\\n\\n    (values x)\\n\\n    Get the values of an associative data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"values","created-at":1593889631},{"example":"(map  |($ {:a 7 :b 8} )   [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[:a :b]  @[7 8]    @[:a 7 :b 8]    @[(:a 7) (:b 8)]      ]\u000D\u000A\u000D\u000A(map  |($ [4 5 6] )       [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1 2]  @[4 5 6]  @[0 4 1 5 2 6]  @[(0 4) (1 5) (2 6)]  ]\u000D\u000A\u000D\u000A(map  |($ 'ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ :ab )           [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A\u000D\u000A(map  |($ \"ab\" )          [  keys      values    kvs             pairs                 ])\u000D\u000A# =>                     @[  @[0 1]    @[97 98]  @[0 97 1 98]    @[(0 97) (1 98)]      ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1430, column 1\\n\\n    (keys x)\\n\\n    Get the keys of an associative data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"keys","created-at":1593889501},{"example":"(get-in  {:a {:cc 2} :b {:dd 3}}  [:a]     42)  # => {:cc 2}\u000D\u000A(get-in  {:a {:cc 2} :b {:dd 3}}  [:a :cc] 42)  # => 2\u000D\u000A\u000D\u000A(get-in  {:a {:cc 2} :b {:dd 3}}  [0]  42)  # => 42\u000D\u000A(get-in  {:a {:cc 2} :b {:dd 3}}  [:z] 42)  # => 42\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1349, column 1\\n\\n    (get-in ds ks &opt dflt)\\n\\n    Access a value in a nested data structure. Looks into the data\\n    structure via a sequence of keys.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"get-in","created-at":1593889060},{"example":"(get-in  [[4 5] [6 7]]  [0]    42)  # => (4 5)\u000D\u000A(get-in  [[4 5] [6 7]]  [0 1]  42)  # => 5\u000D\u000A\u000D\u000A(get-in  [[4 5] [6 7]]  [-1]     42)  # => 42\u000D\u000A(get-in  [[4 5] [6 7]]  [9 9 9]  42)  # => 42\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1349, column 1\\n\\n    (get-in ds ks &opt dflt)\\n\\n    Access a value in a nested data structure. Looks into the data\\n    structure via a sequence of keys.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"get-in","created-at":1593888962},{"example":"(get      [4 5 6]   -1     )  # => nil\u000D\u000A(in       [4 5 6]   -1  42 )  # error\u000D\u000A(get-in   [4 5 6]  [-1] 42 )  # => 42\u000D\u000A\u000D\u000A(get     {:a 1}   -1     )  # => nil\u000D\u000A(in      {:a 1}   -1  42 )  # => 42\u000D\u000A(get-in  {:a 1}  [-1] 42 )  # => 42\u000D\u000A\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (get ds key &opt dflt)\\n\\n    Get the value mapped to key in data structure ds, and return dflt or\\n    nil if not found. Similar to in, but will not throw an error if the\\n    key is invalid for the data structure unless the data structure is an\\n    abstract type. In that case, the abstract type getter may throw an\\n    error.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"get","created-at":1593888604},{"example":"(get      [4 5 6]   -1     )  # => nil\u000D\u000A(in       [4 5 6]   -1  42 )  # error\u000D\u000A(get-in   [4 5 6]  [-1] 42 )  # => 42\u000D\u000A\u000D\u000A(get     {:a 1}   -1     )  # => nil\u000D\u000A(in      {:a 1}   -1  42 )  # => 42\u000D\u000A(get-in  {:a 1}  [-1] 42 )  # => 42","docstring":"\"\\n\\n    function\\n\\n    (in ds key &opt dflt)\\n\\n    Get value in ds at key, works on associative data structures. Arrays,\\n    tuples, tables, structs, strings, symbols, and buffers are all\\n    associative and can be used. Arrays, tuples, strings, buffers, and\\n    symbols must use integer keys that are in bounds or an error is\\n    raised. Structs and tables can take any value as a key except nil and\\n    will return nil or dflt if not found.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"in","created-at":1593888594},{"example":"(in  [10 11 12 13]  0   42 )  # => 10\u000D\u000A(in  {:a 10 :b 20}  :a  42 )  # => 10\u000D\u000A\u000D\u000A(in  [10 11 12]  99 42 )  # error\u000D\u000A(in  [10 11 12]  -1 42 )  # error\u000D\u000A(in  [10 11 12]  -2 42 )  # error\u000D\u000A(in  {:a 1}      :z 42 )  # => 42\u000D\u000A\u000D\u000A(map  (fn [x] (in x 0 42))   [  'a  :a  \"a\"  [97]  @[97]  {0 97}  @{0 97}  {:a 1} ])\u000D\u000A# =>                        @[  97  97  97   97    97     97      97       42     ]\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (in ds key &opt dflt)\\n\\n    Get value in ds at key, works on associative data structures. Arrays,\\n    tuples, tables, structs, strings, symbols, and buffers are all\\n    associative and can be used. Arrays, tuples, strings, buffers, and\\n    symbols must use integer keys that are in bounds or an error is\\n    raised. Structs and tables can take any value as a key except nil and\\n    will return nil or dflt if not found.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"in","created-at":1593888298},{"example":"(get  [10 11 12 13]  0  )  # => 10\u000D\u000A(get  {:a 10 :b 20}  :a )  # => 10\u000D\u000A\u000D\u000A(get  [10 11 12]  99  )  # => nil\u000D\u000A(get  [10 11 12]  -1  )  # => nil\u000D\u000A(get  [10 11 12]  -2  )  # => nil\u000D\u000A(get  {:a 1}      :z  )  # => nil\u000D\u000A\u000D\u000A(map  (fn [x] (get x 0))   [  'a  :a  \"a\"  [97]  @[97]  {0 97}  @{0 97}  ])\u000D\u000A# =>                      @[  97  97  97   97    97     97      97       ]\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (get ds key &opt dflt)\\n\\n    Get the value mapped to key in data structure ds, and return dflt or\\n    nil if not found. Similar to in, but will not throw an error if the\\n    key is invalid for the data structure unless the data structure is an\\n    abstract type. In that case, the abstract type getter may throw an\\n    error.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"get","created-at":1593887208},{"example":"(map length  [  'a  :a  \"a\"  [97]  @[97]  {0 97}  @{0 97}  ])\u000D\u000A# =>        @[  1   1   1    1     1      1       1        ]\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (length ds)\\n\\n    Returns the length or count of a data structure in constant time as\\n    an integer. For structs and tables, returns the number of key-value\\n    pairs in the data structure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"length","created-at":1593886794},{"example":"(int/u64 42)    # => <core/u64 42>\u000D\u000A(int/u64 42.1)  # => <core/u64 42>\u000D\u000A(int/u64 \"42\")  # => <core/u64 42>","docstring":"\"\\n\\n    cfunction\\n\\n    (int/u64 value)\\n\\n    Create a boxed unsigned 64 bit integer from a string value.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"int/u64","created-at":1593886598},{"example":"(int/s64 42)    # => <core/s64 42>\u000D\u000A(int/s64 42.1)  # => <core/s64 42>\u000D\u000A(int/s64 \"42\")  # => <core/s64 42>\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (int/s64 value)\\n\\n    Create a boxed signed 64 bit integer from a string value.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"int/s64","created-at":1593886543},{"example":"(abstract? (file/temp))  # => true\u000D\u000A(abstract? (int/s64 1))  # => true\u000D\u000A\u000D\u000A(map abstract?  [ nil true 97 'a :a \"a\" ])\u000D\u000A# => @[false false false false false false]\u000D\u000A\u000D\u000A(map abstract?  [ [97]  @[97]  {0 97}  @{0 97} ])\u000D\u000A# => @[false false false false]\u000D\u000A\u000D\u000A(map abstract?  [ even? loop file/open  (fn [])  ])\u000D\u000A# => @[false false false false]\u000D\u000A\u000D\u000A(map abstract?  [ (file/temp)  (fiber/new (fn []))  ])\u000D\u000A# => @[true false]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (abstract? x)\\n\\n    Check if x is an abstract type.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"abstract?","created-at":1593886081},{"example":"(map idempotent?  [ nil  true 97   'a   :a   \"a\"  ])\u000D\u000A# =>             @[ true true true true true true ]\u000D\u000A\u000D\u000A(map idempotent?  [  [97]   @[97]  {0 97}  @{0 97}  ])\u000D\u000A# =>             @[  false  false  false   false    ]\u000D\u000A\u000D\u000A(map idempotent?  [  (fn [])  even?  loop  file/open  ])\u000D\u000A# =>             @[  true     true   true  true       ]\u000D\u000A\u000D\u000A(map idempotent?  [  (file/temp)  (fiber/new (fn []))  ])\u000D\u000A# =>             @[  true         true                 ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 120, column 1\\n\\n    (idempotent? x)\\n\\n    Check if x is a value that evaluates to itself when compiled.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"idempotent?","created-at":1593885708},{"example":"(map dictionary? [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         true          ]\u000D\u000A\u000D\u000A(map struct?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         false         ]\u000D\u000A\u000D\u000A(map table?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     false        true          ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 105, column 1\\n\\n    (dictionary? x)\\n\\n    Check if x is a table or struct.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"dictionary?","created-at":1593885103},{"example":"(map indexed?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     true      false        false         ]\u000D\u000A\u000D\u000A(map tuple?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     false     false        false         ]\u000D\u000A\u000D\u000A(map array?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    true      false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 108, column 1\\n\\n    (indexed? x)\\n\\n    Check if x is an array or tuple.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"indexed?","created-at":1593884977},{"example":"(map bytes?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  true  true   true   false    false     false        false         ]\u000D\u000A\u000D\u000A(map symbol?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  false false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map keyword?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false true  false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map string?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false true   false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map buffer?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  true   false    false     false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 102, column 1\\n\\n    (bytes? x)\\n\\n    Check if x is a string, symbol, keyword, or buffer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"bytes?","created-at":1593884686},{"example":"(map dictionary? [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         true          ]\u000D\u000A\u000D\u000A(map struct?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         false         ]\u000D\u000A\u000D\u000A(map table?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     false        true          ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 97, column 1\\n\\n    (table? x)\\n\\n    Check if x a table.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"table?","created-at":1593884559},{"example":"(map dictionary? [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         true          ]\u000D\u000A\u000D\u000A(map struct?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     true         false         ]\u000D\u000A\u000D\u000A(map table?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    false     false        true          ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 98, column 1\\n\\n    (struct? x)\\n\\n    Check if x a struct.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"struct?","created-at":1593882359},{"example":"(map indexed?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     true      false        false         ]\u000D\u000A\u000D\u000A(map tuple?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     false     false        false         ]\u000D\u000A\u000D\u000A(map array?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    true      false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 100, column 1\\n\\n    (tuple? x)\\n\\n    Check if x is a tuple.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"tuple?","created-at":1593882292},{"example":"(map bytes?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  true  true   true   false    false     false        false         ]\u000D\u000A\u000D\u000A(map symbol?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ true  false false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map keyword?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false true  false  false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map string?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false true   false  false    false     false        false         ]\u000D\u000A\u000D\u000A(map buffer?     [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  true   false    false     false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 93, column 1\\n\\n    (buffer? x)\\n\\n    Check if x is a buffer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"buffer?","created-at":1593882230},{"example":"(keyword? :a)   # => true\u000D\u000A(keyword? \"a\")  # => false","docstring":"\"\\n\\n    function\\n    boot.janet on line 92, column 1\\n\\n    (keyword? x)\\n\\n    Check if x is a keyword.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"keyword?","created-at":1593882128},{"example":"(map cfunction? [ even?  (fn [])  |($)   file/read  ->    ])\u000D\u000A# =>           @[ false  false    false  true       false ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 96, column 1\\n\\n    (cfunction? x)\\n\\n    Check if x a cfunction.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"cfunction?","created-at":1593882006},{"example":"(map function? [ even?  (fn [])  |($)  file/read  ->   ])\u000D\u000A# =>          @[ true   true     true  false      true ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 94, column 1\\n\\n    (function? x)\\n\\n    Check if x is a function (not a cfunction).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"function?","created-at":1593881959},{"example":"(map int?  [ nil   true  0    1    3.14   (math/trunc 3.14)  (band 1.1 2.2) ])\u000D\u000A# =>      @[ false false true true false  true               true           ]","docstring":"\"\\n\\n    cfunction\\n\\n    (int? x)\\n\\n    Check if x can be exactly represented as a 32 bit signed two's\\n    complement integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"int?","created-at":1593881753},{"example":"(map boolean? [true false nil   0     1    ])\u000D\u000A# =>         @[true true  false false false]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 101, column 1\\n\\n    (boolean? x)\\n\\n    Check if x is a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"boolean?","created-at":1593881572},{"example":"(map nil? [nil  0     false []   ])\u000D\u000A# =>     @[true false false false]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 114, column 1\\n\\n    (nil? x)\\n\\n    Check if x is nil.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"nil?","created-at":1593881515},{"example":"(map type [nil true 42 [] @[] {} @{} \"a\" @\"b\" 'c :d identity (fn [])])\u000D\u000A# => @[:nil :boolean :number :tuple :array :struct :table :string :buffer :symbol :keyword :function :function]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (type x)\\n\\n    Returns the type of `x` as a keyword. `x` is one of:\\n\\n    * :nil\\n\\n    * :boolean\\n\\n    * :number\\n\\n    * :array\\n\\n    * :tuple\\n\\n    * :table\\n\\n    * :struct\\n\\n    * :string\\n\\n    * :buffer\\n\\n    * :symbol\\n\\n    * :keyword\\n\\n    * :function\\n\\n    * :cfunction\\n\\n    * :fiber\\n\\n    or another keyword for an abstract type.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"type","created-at":1593881446},{"example":"(os/shell \"echo bar > /tmp/foo\")\u000D\u000A(with\u000D\u000A  [file-handle\u000D\u000A   (file/open \"/tmp/foo\")\u000D\u000A   (fn [fd] (file/close fd))]\u000D\u000A  (file/read file-handle :all))  # => @\"bar\\n\"\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 363, column 1\\n\\n    (with [binding ctor dtor] & body)\\n\\n    Evaluate body with some resource, which will be automatically cleaned\\n    up if there is an error in body. binding is bound to the expression\\n    ctor, and dtor is a function or callable that is passed the binding.\\n    If no destructor (dtor) is given, will call :close on the resource.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"with","created-at":1593880973},{"example":"(let [a 1 b 2 c 3] (+ a b c))  # => 6\u000D\u000A\u000D\u000A(let\u000D\u000A  [a 1\u000D\u000A   b (+ a 1)\u000D\u000A   c (+ b 1)]\u000D\u000A  (+ a b c))  # => 6\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 216, column 1\\n\\n    (let bindings & body)\\n\\n    Create a scope and bind values to symbols. Each pair in bindings is\\n    assigned as if with def, and the body of the let form returns the\\n    last value.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"let","created-at":1593880576},{"example":"(map  (fn [x] (< x 10))    [8 9 10 11])  # => @[true true false false]\u000D\u000A(map  (short-fn (< $ 10))  [8 9 10 11])  # => @[true true false false]\u000D\u000A(map  |(< $ 10)            [8 9 10 11])  # => @[true true false false]\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 2294, column 1\\n\\n    (short-fn arg)\\n\\n    Shorthand for fn. Arguments are given as $n, where n is the 0-indexed\\n    argument of the function. $ is also an alias for the first (index 0)\\n    argument. The $& symbol will make the anonymous function variadic if\\n    it apears in the body of the function - it can be combined with\\n    positional arguments.\\n\\n    Example usage:\\n\\n      * (short-fn (+ $ $)) - A function that doubles its arguments.\\n\\n      * (short-fn (string $0 $1)) - accepting multiple args\\n\\n      * |(+ $ $) - use pipe reader macro for terse function literals\\n\\n      * |(+ $&) - variadic functions\\n\\n\\n\"","gh-username":"cellularmitosis","name":"short-fn","created-at":1593880398},{"example":"(string/trimr \" foo \")  # => \" foo\"\u000D\u000A(string/trimr \"_!_foo_!_\" \"_!\")  # => \"_!_foo\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/trimr str &opt set)\\n\\n    Trim trailing whitespace from a byte sequence. If the argument set is\\n    provided, consider only characters in set to be whitespace.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/trimr","created-at":1593854866},{"example":"(string/triml \" foo \")  # => \"foo \"\u000D\u000A(string/triml \"_!_foo_!_\" \"_!\")  # => \"foo_!_\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/triml str &opt set)\\n\\n    Trim leading whitespace from a byte sequence. If the argument set is\\n    provided, consider only characters in set to be whitespace.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/triml","created-at":1593854808},{"example":"(string/trim \" foo \")  # => \"foo\"\u000D\u000A(string/trim \"_!_foo_!_\" \"_!\")  # => \"foo\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/trim str &opt set)\\n\\n    Trim leading and trailing whitespace from a byte sequence. If the\\n    argument set is provided, consider only characters in set to be\\n    whitespace.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/trim","created-at":1593854700},{"example":"(string/slice \"hello\")    # => \"hello\"\u000D\u000A\u000D\u000A(string/slice \"hello\" 0)  # => \"hello\"\u000D\u000A(string/slice \"hello\" 1)  # => \"ello\"\u000D\u000A(string/slice \"hello\" 4)  # => \"o\"\u000D\u000A(string/slice \"hello\" 5)  # => \"\"\u000D\u000A\u000D\u000A(string/slice \"hello\" -1)  # => \"\"\u000D\u000A(string/slice \"hello\" -2)  # => \"o\"\u000D\u000A(string/slice \"hello\" -5)  # => \"ello\"\u000D\u000A(string/slice \"hello\" -6)  # => \"hello\"\u000D\u000A\u000D\u000A(string/slice \"hello\" 1 1)  # => \"\"\u000D\u000A(string/slice \"hello\" 1 2)  # => \"e\"\u000D\u000A(string/slice \"hello\" 1 5)  # => \"ello\"\u000D\u000A\u000D\u000A(string/slice \"hello\" -5 -4)  # => \"e\"\u000D\u000A(string/slice \"hello\" -6 -4)  # => \"he\"\u000D\u000A\u000D\u000A(string/slice \"hello\"  2  1)  # => \"\"\u000D\u000A(string/slice \"hello\" -1 -2)  # => \"\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (string/slice bytes &opt start end)\\n\\n    Returns a substring from a byte sequence. The substring is from index\\n    start inclusive to index end exclusive. All indexing is from 0.\\n    'start' and 'end' can also be negative to indicate indexing from the\\n    end of the string. Note that index -1 is synonymous with index\\n    (length bytes) to allow a full negative slice range.\\n\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/slice","created-at":1593854572},{"example":"(string/repeat \"moshi\" 2)  # => \"moshimoshi\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/repeat bytes n)\\n\\n    Returns a string that is n copies of bytes concatenated.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/repeat","created-at":1593854109},{"example":"(string/ascii-upper \"hello\")  # => \"HELLO\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/ascii-upper str)\\n\\n    Returns a new string where all bytes are replaced with the uppercase\\n    version of themselves in ASCII. Does only a very simple case check,\\n    meaning no unicode support.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/ascii-upper","created-at":1593853715},{"example":"(not=        [1 1]   [1 1])  # => false\u000D\u000A(not=        [1 1]   [2 3])  # => true\u000D\u000A(not=        [1 1]  @[1 1])  # => true\u000D\u000A(not=        [1 1]  @[2 3])  # => true\u000D\u000A(not=       @[1 1]  @[1 1])  # => true\u000D\u000A(not=       @[1 1]  @[2 3])  # => true\u000D\u000A\u000D\u000A(deep-not=   [1 1]   [1 1])  # => nil\u000D\u000A(deep-not=   [1 1]   [2 3])  # => true\u000D\u000A(deep-not=   [1 1]  @[1 1])  # => true\u000D\u000A(deep-not=   [1 1]  @[2 3])  # => true\u000D\u000A(deep-not=  @[1 1]  @[1 1])  # => nil\u000D\u000A(deep-not=  @[1 1]  @[2 3])  # => true\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 2211, column 1\\n\\n    (deep-not= x y)\\n\\n    Like not=, but mutable types (arrays, tables, buffers) are considered\\n    equal if they have identical structure. Much slower than not=.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"deep-not=","created-at":1593843247},{"example":"(not=        [1 1]   [1 1])  # => false\u000D\u000A(not=        [1 1]   [2 3])  # => true\u000D\u000A(not=        [1 1]  @[1 1])  # => true\u000D\u000A(not=        [1 1]  @[2 3])  # => true\u000D\u000A(not=       @[1 1]  @[1 1])  # => true\u000D\u000A(not=       @[1 1]  @[2 3])  # => true\u000D\u000A\u000D\u000A(deep-not=   [1 1]   [1 1])  # => nil\u000D\u000A(deep-not=   [1 1]   [2 3])  # => true\u000D\u000A(deep-not=   [1 1]  @[1 1])  # => true\u000D\u000A(deep-not=   [1 1]  @[2 3])  # => true\u000D\u000A(deep-not=  @[1 1]  @[1 1])  # => nil\u000D\u000A(deep-not=  @[1 1]  @[2 3])  # => true","docstring":"\"\\n\\n    function\\n\\n    (not= & xs)\\n\\n    Check if any values in xs are not equal. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"not=","created-at":1593843232},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(=       [1 1]   [1 1])  # => true\u000D\u000A(=       [1 1]   [2 3])  # => false\u000D\u000A(=       [1 1]  @[1 1])  # => false\u000D\u000A(=       [1 1]  @[2 3])  # => false\u000D\u000A(=      @[1 1]  @[1 1])  # => false\u000D\u000A(=      @[1 1]  @[2 3])  # => false\u000D\u000A\u000D\u000A(deep=   [1 1]   [1 1])  # => true\u000D\u000A(deep=   [1 1]   [2 3])  # => false\u000D\u000A(deep=   [1 1]  @[1 1])  # => false\u000D\u000A(deep=   [1 1]  @[2 3])  # => false\u000D\u000A(deep=  @[1 1]  @[1 1])  # => true\u000D\u000A(deep=  @[1 1]  @[2 3])  # => false\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 2226, column 1\\n\\n    (deep= x y)\\n\\n    Like =, but mutable types (arrays, tables, buffers) are considered\\n    equal if they have identical structure. Much slower than =.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"deep=","created-at":1593842910},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(=       [1 1]   [1 1])  # => true\u000D\u000A(=       [1 1]   [2 3])  # => false\u000D\u000A(=       [1 1]  @[1 1])  # => false\u000D\u000A(=       [1 1]  @[2 3])  # => false\u000D\u000A(=      @[1 1]  @[1 1])  # => false\u000D\u000A(=      @[1 1]  @[2 3])  # => false\u000D\u000A\u000D\u000A(deep=   [1 1]   [1 1])  # => true\u000D\u000A(deep=   [1 1]   [2 3])  # => false\u000D\u000A(deep=   [1 1]  @[1 1])  # => false\u000D\u000A(deep=   [1 1]  @[2 3])  # => false\u000D\u000A(deep=  @[1 1]  @[1 1])  # => true\u000D\u000A(deep=  @[1 1]  @[2 3])  # => false","docstring":"\"\\n\\n    function\\n\\n    (= & xs)\\n\\n    Check if all values in xs are equal. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"=","created-at":1593842894},{"example":"(brshift 32 2)  # => 8","docstring":"\"\\n\\n    function\\n\\n    (brshift x & shifts)\\n\\n    Returns the value of x bit shifted right by the sum of all values in\\n    shifts. x and each element in shift must be an integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"brshift","created-at":1593842712},{"example":"(blshift 8 2)  # => 32","docstring":"\"\\n\\n    function\\n\\n    (blshift x & shifts)\\n\\n    Returns the value of x bit shifted left by the sum of all values in\\n    shifts. x and each element in shift must be an integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"blshift","created-at":1593842672},{"example":"(bxor 3 6)  # => 5\u000D\u000A\u000D\u000A#     011  (3)\u000D\u000A# xor 110  (6)\u000D\u000A# -------\u000D\u000A#     101  (5)\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (bxor & xs)\\n\\n    Returns the bit-wise xor of all values in xs. Each in xs must be an\\n    integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"bxor","created-at":1593842405},{"example":"(bor 1 2 4)  # => 7\u000D\u000A(bor 7 12)  # => 15\u000D\u000A\u000D\u000A#    0111   (7)\u000D\u000A# or 1100  (12)\u000D\u000A# -------\u000D\u000A#    1111  (15)\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (bor & xs)\\n\\n    Returns the bit-wise or of all values in xs. Each x in xs must be an\\n    integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"bor","created-at":1593842264},{"example":"(band 7 11)  # => 3\u000D\u000A\u000D\u000A#     0111  (7)\u000D\u000A# and 1011  (11)\u000D\u000A# --------\u000D\u000A#     0011  (3)\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (band & xs)\\n\\n    Returns the bit-wise and of all values in xs. Each x in xs must be an\\n    integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"band","created-at":1593842028},{"example":"(bnot 255)  # => -256\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (bnot x)\\n\\n    Returns the bit-wise inverse of integer x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"bnot","created-at":1593841824},{"example":"(map number? [nil   true  42   :a    \"a\"   []    {}    (fn []) ])\u000D\u000A# =>        @[false false true false false false false false   ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 88, column 1\\n\\n    (number? x)\\n\\n    Check if x is a number.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"number?","created-at":1593841757},{"example":"(nan? 1)  # => false\u000D\u000A(nan? (/ 0 0))  # => true\u000D\u000A(nan? (sqrt -1))  # => true","docstring":"\"\\n\\n    function\\n    boot.janet on line 87, column 1\\n\\n    (nan? x)\\n\\n    Check if x is NaN\\n\\n\\n\"","gh-username":"cellularmitosis","name":"nan?","created-at":1593841629},{"example":"(nat? 1)       # => true\u000D\u000A(nat? 3.14159) # => false\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (nat? x)\\n\\n    Check if x can be exactly represented as a non-negative 32 bit signed\\n    two's complement integer.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"nat?","created-at":1593841557},{"example":"(neg? -42)  # => true\u000D\u000A(map neg? [-1 0 1])  # => @[true false false]","docstring":"\"\\n\\n    function\\n    boot.janet on line 755, column 1\\n\\n    (neg? x)\\n\\n    Check if x is less than 0.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"neg?","created-at":1593841441},{"example":"(zero? 0)  # => true\u000D\u000A(map zero? [0 1 2])  # => @[true false false]","docstring":"\"\\n\\n    function\\n    boot.janet on line 753, column 1\\n\\n    (zero? x)\\n\\n    Check if x is zero.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"zero?","created-at":1593841385},{"example":"(one? (math/next 1 math/inf))  # => false","docstring":"\"\\n\\n    cfunction\\n\\n    (math/next x y)\\n\\n    Returns the next representable floating point value after x in the\\n    direction of y.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/next","created-at":1593841337},{"example":"(one? 1)  # => true\u000D\u000A(map one? [0 1 2])  # => @[false true false]\u000D\u000A\u000D\u000A(one? (math/next 1 math/inf))  # => false","docstring":"\"\\n\\n    function\\n    boot.janet on line 756, column 1\\n\\n    (one? x)\\n\\n    Check if x is equal to 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"one?","created-at":1593841323},{"example":"(map odd? [1 2 3 4])  # => @[true false true false]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 758, column 1\\n\\n    (odd? x)\\n\\n    Check if x is odd.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"odd?","created-at":1593841240},{"example":"(even? 1)  # => false\u000D\u000A(map even? [1 2 3 4])  # => @[false true false true]","docstring":"\"\\n\\n    function\\n    boot.janet on line 757, column 1\\n\\n    (even? x)\\n\\n    Check if x is even.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"even?","created-at":1593841192},{"example":"(var a 2)\u000D\u000Aa        # => 2\u000D\u000A(dec a)  # => 1\u000D\u000Aa        # => 2\u000D\u000A(-- a)   # => 1\u000D\u000Aa        # => 1\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 139, column 1\\n\\n    (-- x)\\n\\n    Decrements the var x by 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"--","created-at":1593841031},{"example":"(var a 1)\u000D\u000Aa        # => 1\u000D\u000A(inc a)  # => 2\u000D\u000Aa        # => 1\u000D\u000A(++ a)   # => 2\u000D\u000Aa        # => 2\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 138, column 1\\n\\n    (++ x)\\n\\n    Increments the var x by 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"++","created-at":1593840970},{"example":"(math/log (* math/e math/e))  # => 2\u000D\u000A(math/log2 256)               # => 8\u000D\u000A(math/log10 1000)             # => 3\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/log10 x)\\n\\n    Returns log base 10 of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/log10","created-at":1593840806},{"example":"(math/log (* math/e math/e))  # => 2\u000D\u000A(math/log2 256)               # => 8\u000D\u000A(math/log10 1000)             # => 3\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/log2 x)\\n\\n    Returns log base 2 of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/log2","created-at":1593840797},{"example":"(math/log (* math/e math/e))  # => 2\u000D\u000A(math/log2 256)               # => 8\u000D\u000A(math/log10 1000)             # => 3\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/log x)\\n\\n    Returns log base natural number of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/log","created-at":1593840786},{"example":"(math/pow 10 3)   # => 1000\u000D\u000A(math/cbrt 1000)  # => 10","docstring":"\"\\n\\n    cfunction\\n\\n    (math/cbrt x)\\n\\n    Returns the cube root of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/cbrt","created-at":1593840461},{"example":"(math/sqrt 9)  # => 3","docstring":"\"\\n\\n    cfunction\\n\\n    (math/sqrt x)\\n\\n    Returns the square root of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/sqrt","created-at":1593840317},{"example":"(math/pow 2 8)  # => 256","docstring":"\"\\n\\n    cfunction\\n\\n    (math/pow a x)\\n\\n    Return a to the power of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/pow","created-at":1593840292},{"example":"(map math/abs   [-2.9 -2.1 2.1 2.9])  # => @[ 2.9  2.1  2.1  2.9 ]\u000D\u000A(map math/floor [-2.9 -2.1 2.1 2.9])  # => @[ -3   -3   2    2   ]\u000D\u000A(map math/ceil  [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   3    3   ]\u000D\u000A(map math/round [-2.9 -2.1 2.1 2.9])  # => @[ -3   -2   2    3   ]\u000D\u000A(map math/trunc [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   2    2   ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/trunc x)\\n\\n    Returns the integer between x and 0 nearest to x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/trunc","created-at":1593840224},{"example":"(map math/abs   [-2.9 -2.1 2.1 2.9])  # => @[ 2.9  2.1  2.1  2.9 ]\u000D\u000A(map math/floor [-2.9 -2.1 2.1 2.9])  # => @[ -3   -3   2    2   ]\u000D\u000A(map math/ceil  [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   3    3   ]\u000D\u000A(map math/round [-2.9 -2.1 2.1 2.9])  # => @[ -3   -2   2    3   ]\u000D\u000A(map math/trunc [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   2    2   ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/round x)\\n\\n    Returns the integer nearest to x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/round","created-at":1593840211},{"example":"(map math/abs   [-2.9 -2.1 2.1 2.9])  # => @[ 2.9  2.1  2.1  2.9 ]\u000D\u000A(map math/floor [-2.9 -2.1 2.1 2.9])  # => @[ -3   -3   2    2   ]\u000D\u000A(map math/ceil  [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   3    3   ]\u000D\u000A(map math/round [-2.9 -2.1 2.1 2.9])  # => @[ -3   -2   2    3   ]\u000D\u000A(map math/trunc [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   2    2   ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/ceil x)\\n\\n    Returns the smallest integer value number that is not less than x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/ceil","created-at":1593840200},{"example":"(map math/abs   [-2.9 -2.1 2.1 2.9])  # => @[ 2.9  2.1  2.1  2.9 ]\u000D\u000A(map math/floor [-2.9 -2.1 2.1 2.9])  # => @[ -3   -3   2    2   ]\u000D\u000A(map math/ceil  [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   3    3   ]\u000D\u000A(map math/round [-2.9 -2.1 2.1 2.9])  # => @[ -3   -2   2    3   ]\u000D\u000A(map math/trunc [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   2    2   ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/floor x)\\n\\n    Returns the largest integer value number that is not greater than x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/floor","created-at":1593840190},{"example":"(map math/abs   [-2.9 -2.1 2.1 2.9])  # => @[ 2.9  2.1  2.1  2.9 ]\u000D\u000A(map math/floor [-2.9 -2.1 2.1 2.9])  # => @[ -3   -3   2    2   ]\u000D\u000A(map math/ceil  [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   3    3   ]\u000D\u000A(map math/round [-2.9 -2.1 2.1 2.9])  # => @[ -3   -2   2    3   ]\u000D\u000A(map math/trunc [-2.9 -2.1 2.1 2.9])  # => @[ -2   -2   2    2   ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/abs x)\\n\\n    Return the absolute value of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/abs","created-at":1593840175},{"example":"(math/round 1.1)  # => 1\u000D\u000A(map math/round [1.49 1.50 1.51])  # => @[1 2 2]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/round x)\\n\\n    Returns the integer nearest to x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/round","created-at":1593839728},{"example":"(math/floor 1.1)  # => 1\u000D\u000A(map math/floor [1.1 1.2 1.3])  # => @[1 1 1]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/floor x)\\n\\n    Returns the largest integer value number that is not greater than x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/floor","created-at":1593839626},{"example":"(math/ceil 1.1)  # => 2\u000D\u000A(map math/ceil [1.1 1.2 1.3])  # => @[2 2 2]","docstring":"\"\\n\\n    cfunction\\n\\n    (math/ceil x)\\n\\n    Returns the smallest integer value number that is not less than x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/ceil","created-at":1593839598},{"example":"(math/abs -42)  # => 42\u000D\u000A(map math/abs [-1 0 1])  # => @[1 0 1]","docstring":"\"\\n\\n    cfunction\\n\\n    (math/abs x)\\n\\n    Return the absolute value of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/abs","created-at":1593839464},{"example":"(dec 42)  # => 41\u000D\u000A(map dec [1 2 3])  # => @[0 1 2]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 137, column 1\\n\\n    (dec x)\\n\\n    Returns x - 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"dec","created-at":1593839424},{"example":"(inc 42)  # => 43\u000D\u000A(map inc [1 2 3])  # => @[2 3 4]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 136, column 1\\n\\n    (inc x)\\n\\n    Returns x + 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"inc","created-at":1593839400},{"example":"(mean [1 10 100])  # => 37\u000D\u000A(mean [])          # => nan","docstring":"\"\\n\\n    function\\n    boot.janet on line 605, column 1\\n\\n    (mean xs)\\n\\n    Returns the mean of xs. If empty, returns NaN.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"mean","created-at":1593839338},{"example":"(min 1 2 3)             # => 1\u000D\u000A(min (splice [1 2 3]))  # => 1\u000D\u000A(min ;[1 2 3])          # => 1\u000D\u000A(apply min [1 2 3])     # => 1","docstring":"\"\\n\\n    function\\n    boot.janet on line 690, column 1\\n\\n    (min & args)\\n\\n    Returns the numeric minimum of the arguments.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"min","created-at":1593839271},{"example":"(max 1 2 3)             # => 3\u000D\u000A(max (splice [1 2 3]))  # => 3\u000D\u000A(max ;[1 2 3])          # => 3\u000D\u000A(apply max [1 2 3])     # => 3\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 686, column 1\\n\\n    (max & args)\\n\\n    Returns the numeric maximum of the arguments.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"max","created-at":1593839213},{"example":"(* 3 4 5)          # => 60\u000D\u000A(product [3 4 5])  # => 60","docstring":"\"\\n\\n    function\\n    boot.janet on line 610, column 1\\n\\n    (product xs)\\n\\n    Returns the product of xs. If xs is empty, returns 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"product","created-at":1593839123},{"example":"(+ 1 2 3)      # => 6\u000D\u000A(sum [1 2 3])  # => 6","docstring":"\"\\n\\n    function\\n    boot.janet on line 598, column 1\\n\\n    (sum xs)\\n\\n    Returns the sum of xs. If xs is empty, returns 0.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"sum","created-at":1593839075},{"example":"(map hash [nil true false -1 0 3.14 :a \"foo\" [1 2 3] {:a 1} (fn [])])\u000D\u000A# => @[0 1 0 -1074790400 0 1244950043 -2107123988 -1254832049 -2021739803 -1395744911 53378043]","docstring":"\"\\n\\n    cfunction\\n\\n    (hash value)\\n\\n    Gets a hash for any value. The hash is an integer can be used as a\\n    cheap hash function for all values. If two values are strictly equal,\\n    then they will have the same hash value.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"hash","created-at":1593838998},{"example":"# Note: the numbers may appear the same, but this is only due to printing truncation.\u000D\u000A1                             # => 1\u000D\u000A(math/next 1 math/inf)        # => 1\u000D\u000A(< 1 1)                       # => false\u000D\u000A(< 1 (math/next 1 math/inf))  # => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/next x y)\\n\\n    Returns the next representable floating point value after x in the\\n    direction of y.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/next","created-at":1593838919},{"example":"(math/exp2 8)  # => 256\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/exp2 x)\\n\\n    Returns 2 to the power of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/exp2","created-at":1593838757},{"example":"(math/exp 1)  # => 2.71828\u000D\u000Amath/e        # => 2.71828","docstring":"\"\\n\\n    cfunction\\n\\n    (math/exp x)\\n\\n    Returns e to the power of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/exp","created-at":1593838710},{"example":"(math/hypot 1 1)  # => 1.41421\u000D\u000A(math/sqrt 2)     # => 1.41421\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (math/hypot a b)\\n\\n    Returns the c from the equation c^2 = a^2 + b^2\\n\\n\\n\"","gh-username":"cellularmitosis","name":"math/hypot","created-at":1593838611},{"example":"(os/time)  # => 1593838384\u000D\u000A(os/date)  # => {:month 6 :dst false :year-day 185 :seconds 8 :minutes 53 :week-day 6 :year 2020 :hours 4 :month-day 3}\u000D\u000A(os/mktime (os/date))  # => 1593838390\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/mktime date-struct &opt local)\\n\\n    Get the broken down date-struct time expressed as the number of\\n    seconds since January 1, 1970, the Unix epoch. Returns a real number.\\n    Date is given in UTC unless local is truthy, in which case the date\\n    is computed for the local timezone.\\n\\n    Inverse function to os/date.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/mktime","created-at":1593838432},{"example":"(os/sleep 1)    # => nil\u000D\u000A(os/sleep 0.1)  # => nil\u000D\u000A(os/sleep 0)    # => nil\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/sleep n)\\n\\n    Suspend the program for n seconds. 'nsec' can be a real number.\\n    Returns nil.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/sleep","created-at":1593838322},{"example":"(os/date)\u000D\u000A# => {:month 6 :dst false :year-day 185 :seconds 38 :minutes 44 :week-day 6 :year 2020 :hours 4 :month-day 3}","docstring":"\"\\n\\n    cfunction\\n\\n    (os/date &opt time local)\\n\\n    Returns the given time as a date struct, or the current time if\\n    `time` is not given. Returns a struct with following key values. Note\\n    that all numbers are 0-indexed. Date is given in UTC unless `local`\\n    is truthy, in which case the date is formatted for the local\\n    timezone.\\n\\n    * :seconds - number of seconds [0-61]\\n\\n    * :minutes - number of minutes [0-59]\\n\\n    * :hours - number of hours [0-23]\\n\\n    * :month-day - day of month [0-30]\\n\\n    * :month - month of year [0, 11]\\n\\n    * :year - years since year 0 (e.g. 2019)\\n\\n    * :week-day - day of the week [0-6]\\n\\n    * :year-day - day of the year [0-365]\\n\\n    * :dst - if Day Light Savings is in effect\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/date","created-at":1593838228},{"example":"(def time (os/time))  # => 1593838001\u000D\u000A\u000D\u000A(os/date t)\u000D\u000A# => {:month 6 :dst false :year-day 185 :seconds 41 :minutes 46 :week-day 6 :year 2020 :hours 4 :month-day 3}\u000D\u000A(os/date t false)\u000D\u000A# => {:month 6 :dst false :year-day 185 :seconds 41 :minutes 46 :week-day 6 :year 2020 :hours 4 :month-day 3}\u000D\u000A\u000D\u000A(os/date t true)\u000D\u000A# => {:month 6 :dst true :year-day 184 :seconds 41 :minutes 46 :week-day 5 :year 2020 :hours 23 :month-day 2}\u000D\u000A(os/date t :local)\u000D\u000A# => {:month 6 :dst true :year-day 184 :seconds 41 :minutes 46 :week-day 5 :year 2020 :hours 23 :month-day 2}\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/date &opt time local)\\n\\n    Returns the given time as a date struct, or the current time if\\n    `time` is not given. Returns a struct with following key values. Note\\n    that all numbers are 0-indexed. Date is given in UTC unless `local`\\n    is truthy, in which case the date is formatted for the local\\n    timezone.\\n\\n    * :seconds - number of seconds [0-61]\\n\\n    * :minutes - number of minutes [0-59]\\n\\n    * :hours - number of hours [0-23]\\n\\n    * :month-day - day of month [0-30]\\n\\n    * :month - month of year [0, 11]\\n\\n    * :year - years since year 0 (e.g. 2019)\\n\\n    * :week-day - day of the week [0-6]\\n\\n    * :year-day - day of the year [0-365]\\n\\n    * :dst - if Day Light Savings is in effect\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/date","created-at":1593838176},{"example":"$ janet -e '(os/exit 42)' ; echo $?\u000D\u000A42\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/exit &opt x)\\n\\n    Exit from janet with an exit code equal to x. If x is not an integer,\\n    the exit with status equal the hash of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/exit","created-at":1593837847},{"example":"(os/cryptorand 1)  # => @\"\\n\"\u000D\u000A(os/cryptorand 1)  # => @\"<\"\u000D\u000A(os/cryptorand 1)  # => @\"\\xC0\"\u000D\u000A(os/cryptorand 1)  # => @\"\\x89\"\u000D\u000A\u000D\u000A(os/cryptorand 8)  # => @\"\\x87\\x13\\x99\\x95\\x10su\\e\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/cryptorand n &opt buf)\\n\\n    Get or append n bytes of good quality random data provided by the OS.\\n    Returns a new buffer or buf.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/cryptorand","created-at":1593837735},{"example":"(os/which)  # => :macos","docstring":"\"\\n\\n    cfunction\\n\\n    (os/which)\\n\\n    Check the current operating system. Returns one of:\\n\\n    * :windows\\n\\n    * :macos\\n\\n    * :web - Web assembly (emscripten)\\n\\n    * :linux\\n\\n    * :freebsd\\n\\n    * :openbsd\\n\\n    * :netbsd\\n\\n    * :posix - A POSIX compatible system (default)\\n\\n    May also return a custom keyword specified at build time.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/which","created-at":1593837646},{"example":"(os/clock)  # => 1.59384e+09","docstring":"\"\\n\\n    cfunction\\n\\n    (os/clock)\\n\\n    Return the number of seconds since some fixed point in time. The\\n    clock is guaranteed to be non decreasing in real time.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/clock","created-at":1593837602},{"example":"(os/time)  # => 1593837535","docstring":"\"\\n\\n    cfunction\\n\\n    (os/time)\\n\\n    Get the current time expressed as the number of seconds since January\\n    1, 1970, the Unix epoch. Returns a real number.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/time","created-at":1593837547},{"example":"(defn recent-mods\u000D\u000A  \"List the files in the current directory which have changed within the last hour.\"\u000D\u000A  []\u000D\u000A  (filter\u000D\u000A    (fn [fname]\u000D\u000A      (<\u000D\u000A        (- (os/time) 3600)\u000D\u000A        (os/stat fname :modified)))\u000D\u000A    (os/dir \".\")))\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/stat path &opt tab|key)\\n\\n    Gets information about a file or directory. Returns a table if the\\n    second argument is a keyword, returns only that information from\\n    stat. If the file or directory does not exist, returns nil. The keys\\n    are:\\n\\n    * :dev - the device that the file is on\\n\\n    * :mode - the type of file, one of :file, :directory, :block,\\n      :character, :fifo, :socket, :link, or :other\\n\\n    * :int-permissions - A Unix permission integer like 8r744\\n\\n    * :permissions - A Unix permission string like \\\"rwxr--r--\\\"\\n\\n    * :uid - File uid\\n\\n    * :gid - File gid\\n\\n    * :nlink - number of links to file\\n\\n    * :rdev - Real device of file. 0 on windows.\\n\\n    * :size - size of file in bytes\\n\\n    * :blocks - number of blocks in file. 0 on windows\\n\\n    * :blocksize - size of blocks in file. 0 on windows\\n\\n    * :accessed - timestamp when file last accessed\\n\\n    * :changed - timestamp when file last changed (permissions changed)\\n\\n    * :modified - timestamp when file last modified (content changed)\\n\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/stat","created-at":1593837408},{"example":"(defn ls-sockets\u000D\u000A  \"List the sockets in the current directory.\"\u000D\u000A  []\u000D\u000A  (filter\u000D\u000A    (fn [fname] (= :socket (os/stat fname :mode)))\u000D\u000A    (os/dir \".\")))\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/stat path &opt tab|key)\\n\\n    Gets information about a file or directory. Returns a table if the\\n    second argument is a keyword, returns only that information from\\n    stat. If the file or directory does not exist, returns nil. The keys\\n    are:\\n\\n    * :dev - the device that the file is on\\n\\n    * :mode - the type of file, one of :file, :directory, :block,\\n      :character, :fifo, :socket, :link, or :other\\n\\n    * :int-permissions - A Unix permission integer like 8r744\\n\\n    * :permissions - A Unix permission string like \\\"rwxr--r--\\\"\\n\\n    * :uid - File uid\\n\\n    * :gid - File gid\\n\\n    * :nlink - number of links to file\\n\\n    * :rdev - Real device of file. 0 on windows.\\n\\n    * :size - size of file in bytes\\n\\n    * :blocks - number of blocks in file. 0 on windows\\n\\n    * :blocksize - size of blocks in file. 0 on windows\\n\\n    * :accessed - timestamp when file last accessed\\n\\n    * :changed - timestamp when file last changed (permissions changed)\\n\\n    * :modified - timestamp when file last modified (content changed)\\n\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/stat","created-at":1593837163},{"example":"(os/perm-string 420)    # => \"rw-r--r--\"\u000D\u000A(os/perm-string 8r644)  # => \"rw-r--r--\"\u000D\u000A(os/perm-string 493)    # => \"rwxr-xr-x\"\u000D\u000A(os/perm-string 8r755)  # => \"rwxr-xr-x\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/perm-string int)\\n\\n    Convert a Unix octal permission value from a permission integer as\\n    returned by os/stat to a human readable string, that follows the\\n    formatting of unix tools like ls. Returns the string as a 9 character\\n    string of r, w, x and - characters. Does not include the\\n    file/directory/symlink character as rendered by `ls`.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/perm-string","created-at":1593836476},{"example":"(os/perm-int \"rw-r--r--\")  # => 420\u000D\u000A(os/perm-int \"rwxr-xr-x\")  # => 493\u000D\u000A\u000D\u000A# note:\u000D\u000A8r644  # => 420\u000D\u000A8r755  # => 493\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/perm-int bytes)\\n\\n    Parse a 9 character permission string and return an integer that can\\n    be used by chmod.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/perm-int","created-at":1593836300},{"example":"(spit \"/tmp/hello.sh\" \"#!/bin/bash\\necho 'Hello from Bash!'\\n\")\u000D\u000A(os/chmod \"/tmp/hello.sh\" \"rwx------\")\u000D\u000A(os/setenv \"PATH\" (string (os/getenv \"PATH\") \":/tmp\"))\u000D\u000A(os/shell \"hello.sh\")","docstring":"\"\\n\\n    cfunction\\n\\n    (os/chmod path mode)\\n\\n    Change file permissions, where mode is a permission string as\\n    returned by os/perm-string, or an integer as returned by os/perm-int.\\n    When mode is an integer, it is interpreted as a Unix permission\\n    value, best specified in octal, like 8r666 or 8r400. Windows will not\\n    differentiate between user, group, and other permissions, and thus\\n    will combine all of these permissions. Returns nil.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/chmod","created-at":1593836181},{"example":"(os/shell \"touch foo\")\u000D\u000A(os/stat \"foo\" :modified)  # => 1593836002\u000D\u000A(os/touch \"foo\")\u000D\u000A(os/stat \"foo\" :modified)  # => 1593836013","docstring":"\"\\n\\n    cfunction\\n\\n    (os/stat path &opt tab|key)\\n\\n    Gets information about a file or directory. Returns a table if the\\n    second argument is a keyword, returns only that information from\\n    stat. If the file or directory does not exist, returns nil. The keys\\n    are:\\n\\n    * :dev - the device that the file is on\\n\\n    * :mode - the type of file, one of :file, :directory, :block,\\n      :character, :fifo, :socket, :link, or :other\\n\\n    * :int-permissions - A Unix permission integer like 8r744\\n\\n    * :permissions - A Unix permission string like \\\"rwxr--r--\\\"\\n\\n    * :uid - File uid\\n\\n    * :gid - File gid\\n\\n    * :nlink - number of links to file\\n\\n    * :rdev - Real device of file. 0 on windows.\\n\\n    * :size - size of file in bytes\\n\\n    * :blocks - number of blocks in file. 0 on windows\\n\\n    * :blocksize - size of blocks in file. 0 on windows\\n\\n    * :accessed - timestamp when file last accessed\\n\\n    * :changed - timestamp when file last changed (permissions changed)\\n\\n    * :modified - timestamp when file last modified (content changed)\\n\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/stat","created-at":1593836066},{"example":"(os/shell \"touch foo\")\u000D\u000A(os/stat \"foo\" :modified)  # => 1593836002\u000D\u000A(os/touch \"foo\")\u000D\u000A(os/stat \"foo\" :modified)  # => 1593836013","docstring":"\"\\n\\n    cfunction\\n\\n    (os/touch path &opt actime modtime)\\n\\n    Update the access time and modification times for a file. By default,\\n    sets times to the current time.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/touch","created-at":1593836029},{"example":"# note that os/touch does not create a file if it does not yet exist.\u000D\u000A(os/touch \"foo\")\u000D\u000Aerror: No such file or directory\u000D\u000A  in os/touch\u000D\u000A  in _thunk [repl] (tailcall) on line 2, column 1\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/touch path &opt actime modtime)\\n\\n    Update the access time and modification times for a file. By default,\\n    sets times to the current time.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/touch","created-at":1593835730},{"example":"(os/dir \".\")              # => @[\"foo\" \"bar\"]\u000D\u000A(os/rename \"bar\" \"bar2\")  # => nil\u000D\u000A(os/dir \".\")              # => @[\"bar2\" \"foo\"]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/rename oldname newname)\\n\\n    Rename a file on disk to a new path. Returns nil.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/rename","created-at":1593835155},{"example":"(os/dir \"./\")                   # => @[]\u000D\u000A(os/shell \"touch foo bar baz\")  # => nil\u000D\u000A(os/dir \"./\")                   # => @[\"foo\" \"bar\" \"baz\"]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/dir dir &opt array)\\n\\n    Iterate over files and subdirectories in a directory. Returns an\\n    array of paths parts, with only the file name or directory name and\\n    no prefix.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/dir","created-at":1593834910},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A# note that os/cd does not appear to update PWD in the shell's environment.\u000D\u000A(os/cwd)           # => \"/Users/cell/tmp\"\u000D\u000A(os/getenv \"PWD\")  # => \"/Users/cell/tmp\"\u000D\u000A(os/cd \"/tmp\")     # => nil\u000D\u000A(os/cwd)           # => \"/private/tmp\"  (on Apple, /tmp is actually /private/tmp)\u000D\u000A(os/getenv \"PWD\")  # => \"/Users/cell/tmp\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/cd path)\\n\\n    Change current directory to path. Returns nil on success, errors on\\n    failure.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/cd","created-at":1593834258},{"example":"(os/cwd)  # => \"/Users/cell/tmp\"\u000D\u000A(os/getenv \"PWD\")  # => \"/Users/cell/tmp\"\u000D\u000A(get (os/environ) \"PWD\")  # => \"/Users/cell/tmp\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/cwd)\\n\\n    Returns the current working directory.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/cwd","created-at":1593833973},{"example":"(os/shell \"uptime > /tmp/uptime.txt\")  # => 0\u000D\u000A(slurp \"/tmp/uptime.txt\")\u000D\u000A# => @\"22:33  up 5 days,  9:34, 15 users, load averages: 1.93 1.74 1.59\\n\"\u000D\u000A(os/rm \"/tmp/uptime.txt\")  # => nil","docstring":"\"\\n\\n    cfunction\\n\\n    (os/readlink path)\\n\\n    Read the contents of a symbolic link. Does not work on Windows.\\n\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/readlink","created-at":1593833794},{"example":"(os/shell \"uptime > /tmp/uptime.txt\")  # => 0\u000D\u000A(slurp \"/tmp/uptime.txt\")\u000D\u000A# => @\"22:33  up 5 days,  9:34, 15 users, load averages: 1.93 1.74 1.59\\n\"\u000D\u000A(os/rm \"/tmp/uptime.txt\")  # => nil","docstring":"\"\\n\\n    cfunction\\n\\n    (os/shell str)\\n\\n    Pass a command string str directly to the system shell.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/shell","created-at":1593833702},{"example":"(os/shell \"uptime\")  # => 0\u000D\u000A# printed to the console:\u000D\u000A22:30  up 5 days,  9:31, 15 users, load averages: 1.48 1.50 1.49\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/shell str)\\n\\n    Pass a command string str directly to the system shell.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/shell","created-at":1593833495},{"example":"(spit \"/tmp/hello.sh\" \"#!/bin/bash\\necho 'Hello from Bash!'\\n\")\u000D\u000A(os/chmod \"/tmp/hello.sh\" \"rwx------\")\u000D\u000A(os/setenv \"PATH\" (string (os/getenv \"PATH\") \":/tmp\"))\u000D\u000A(os/shell \"hello.sh\")\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/setenv variable value)\\n\\n    Set an environment variable.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/setenv","created-at":1593833227},{"example":"(get (os/environ) \"HOME\")  # => \"/Users/cell\"\u000D\u000A(os/getenv \"HOME\")  # => \"/Users/cell\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (os/environ)\\n\\n    Get a copy of the os environment table.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/environ","created-at":1593832465},{"example":"# on a Core i5-4590:\u000D\u000A(os/arch)  # => :x64\u000D\u000A\u000D\u000A# on an Intel Atom N270:\u000D\u000A(os/arch)  # => :x86\u000D\u000A\u000D\u000A# on a raspberry pi:\u000D\u000A(os/arch)  # => :arm","docstring":"\"\\n\\n    cfunction\\n\\n    (os/arch)\\n\\n    Check the ISA that janet was compiled for. Returns one of:\\n\\n    * :x86\\n\\n    * :x86-64\\n\\n    * :arm\\n\\n    * :aarch64\\n\\n    * :sparc\\n\\n    * :wasm\\n\\n    * :unknown\\n\\n\\n\\n\"","gh-username":"cellularmitosis","name":"os/arch","created-at":1593832312},{"example":"# in a terminal:\u000D\u000A# $ while true; do date | nc 0.0.0.0 1234 -w 1; sleep 1; done\u000D\u000A\u000D\u000A# in a janet repl:\u000D\u000A(net/server \"0.0.0.0\" 1234\u000D\u000A  (fn [conn]\u000D\u000A    (prin (net/read conn 4096))\u000D\u000A    (net/close conn)))\u000D\u000A# note: output doesn't actually start until you (quit) your repl's fiber:\u000D\u000A(quit)\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (net/read stream nbytes &opt buf timeout)\\n\\n    Read up to n bytes from a stream, suspending the current fiber until\\n    the bytes are available. `n` can also be the keyword `:all` to read\\n    into the buffer until end of stream. If less than n bytes are\\n    available (and more than 0), will push those bytes and return early.\\n    Takes an optional timeout in seconds, after which will return nil.\\n    Returns a buffer with up to n more bytes in it, or raises an error if\\n    the read failed.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"net/read","created-at":1593831884},{"example":"# note, if running a server from the repl, you need to (quit) your repl.\u000D\u000A\u000D\u000A# in a terminal:\u000D\u000A# $ while true; do date | nc 0.0.0.0 1234 -w 1; sleep 1; done\u000D\u000A\u000D\u000A# in a janet repl:\u000D\u000A(net/server \"0.0.0.0\" 1234\u000D\u000A  (fn [conn]\u000D\u000A    (prin (net/read conn 4096))\u000D\u000A    (net/close conn)))\u000D\u000A# output doesn't actually start until you (quit) your repl's fiber:\u000D\u000A(quit)\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 3196, column 3\\n\\n    (net/server host port &opt handler type)\\n\\n    Start a server asynchronously with net/listen and net/accept-loop.\\n    Returns the new server stream.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"net/server","created-at":1593831829},{"example":"$ # trivial server which echo's to the console.\u000D\u000A$ cat > srv.janet << EOF\u000D\u000A#!/usr/bin/env janet\u000D\u000A\u000D\u000A(defn handle-conn [conn]\u000D\u000A  (print \"new connection\")\u000D\u000A  (while true\u000D\u000A    (def data (net/read conn 4096))\u000D\u000A    (if (not data) (break))\u000D\u000A    (prin data))\u000D\u000A  (net/close conn)\u000D\u000A  (print \"connection closed\"))\u000D\u000A\u000D\u000A(print \"starting server on 0.0.0.0:1234\")\u000D\u000A(net/server \"0.0.0.0\" 1234 handle-conn)\u000D\u000AEOF\u000D\u000A$ chmod +x srv.janet\u000D\u000A$ ./srv.janet\u000D\u000A\u000D\u000A----\u000D\u000A\u000D\u000A$ # in another terminal:\u000D\u000A$ echo hello | nc 0.0.0.0 1234\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 3196, column 3\\n\\n    (net/server host port &opt handler type)\\n\\n    Start a server asynchronously with net/listen and net/accept-loop.\\n    Returns the new server stream.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"net/server","created-at":1593831081},{"example":"#!/usr/bin/env janet\u000D\u000A# echo stdin to stdout.\u000D\u000A(file/write stdout (file/read stdin :all))\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (file/write f bytes)\\n\\n    Writes to a file. 'bytes' must be string, buffer, or symbol. Returns\\n    the file.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"file/write","created-at":1593798053},{"example":"#!/usr/bin/env janet\u000D\u000A# echo stdin to stdout.\u000D\u000A(file/write stdout (file/read stdin :all))\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (file/read f what &opt buf)\\n\\n    Read a number of bytes from a file `f` into a buffer. A buffer `buf`\\n    can be provided as an optional third argument, otherwise a new buffer\\n    is created. `what` can either be an integer or a keyword. Returns the\\n    buffer with file contents. Values for `what`:\\n\\n    * :all - read the whole file\\n\\n    * :line - read up to and including the next newline character\\n\\n    * n (integer) - read up to n bytes from the file\\n\\n\\n\"","gh-username":"cellularmitosis","name":"file/read","created-at":1593798040},{"example":"(defn spit-lines [path lines]\u000D\u000A  (spit path (string/join lines \"\\n\")))","docstring":"\"\\n\\n    cfunction\\n\\n    (string/join parts &opt sep)\\n\\n    Joins an array of strings into one string, optionally separated by a\\n    separator string sep.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/join","created-at":1593797308},{"example":"(defn slurp-lines [path]\u000D\u000A  (string/split \"\\n\" (slurp path)))","docstring":"\"\\n\\n    cfunction\\n\\n    (string/split delim str &opt start limit)\\n\\n    Splits a string str with delimiter delim and returns an array of\\n    substrings. The substrings will not contain the delimiter delim. If\\n    delim is not found, the returned array will have one element. Will\\n    start searching for delim at the index start (if provided), and\\n    return up to a maximum of limit results (if provided).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/split","created-at":1593797280},{"example":"# foo.txt is a file with contents \"hello\\nworld\\n\".\u000D\u000A(slurp \"foo.txt\")  # => @\"hello\\nworld\\n\"\u000D\u000A(string/split \"\\n\" (slurp \"foo.txt\"))  # => @[\"hello\" \"world\" \"\"]\u000D\u000A\u000D\u000A(defn slurp-lines [path]\u000D\u000A  (string/split \"\\n\" (slurp path)))\u000D\u000A\u000D\u000A(slurp-lines \"foo.txt\")  # => @[\"hello\" \"world\" \"\"]\u000D\u000A\u000D\u000A(string/join @[\"hello\" \"world\" \"\"] \"\\n\")  # => \"hello\\nworld\\n\"\u000D\u000A(spit \"foo2.txt\" (string/join @[\"hello\" \"world\" \"\"] \"\\n\"))\u000D\u000A# The contents of foo.txt and foo2.txt are now identical.\u000D\u000A\u000D\u000A(defn spit-lines [path lines]\u000D\u000A  (spit path (string/join lines \"\\n\")))\u000D\u000A\u000D\u000A(spit-lines \"foo3.txt\" (slurp-lines \"foo.txt\"))\u000D\u000A# The contents of foo.txt and foo3.txt are now identical.\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1557, column 1\\n\\n    (spit path contents &opt mode)\\n\\n    Write contents to a file at path. Can optionally append to the file.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"spit","created-at":1593797216},{"example":"# foo.txt is a file with contents \"hello\\nworld\\n\".\u000D\u000A(slurp \"foo.txt\")  # => @\"hello\\nworld\\n\"\u000D\u000A(string/split \"\\n\" (slurp \"foo.txt\"))  # => @[\"hello\" \"world\" \"\"]\u000D\u000A\u000D\u000A(defn slurp-lines [path]\u000D\u000A  (string/split \"\\n\" (slurp path)))\u000D\u000A\u000D\u000A(slurp-lines \"foo.txt\")  # => @[\"hello\" \"world\" \"\"]\u000D\u000A\u000D\u000A(string/join @[\"hello\" \"world\" \"\"] \"\\n\")  # => \"hello\\nworld\\n\"\u000D\u000A(spit \"foo2.txt\" (string/join @[\"hello\" \"world\" \"\"] \"\\n\"))\u000D\u000A# The contents of foo.txt and foo2.txt are now identical.\u000D\u000A\u000D\u000A(defn spit-lines [path lines]\u000D\u000A  (spit path (string/join lines \"\\n\")))\u000D\u000A\u000D\u000A(spit-lines \"foo3.txt\" (slurp-lines \"foo.txt\"))\u000D\u000A# The contents of foo.txt and foo3.txt are now identical.\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1547, column 1\\n\\n    (slurp path)\\n\\n    Read all data from a file with name path and then close the file.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"slurp","created-at":1593797178},{"example":"# './foo.janet' is a file with contents '(def bar 42)'.\u000D\u000A(use foo)\u000D\u000Abar  # => 42","docstring":"\"\\n\\n    macro\\n    boot.janet on line 2903, column 1\\n\\n    (use & modules)\\n\\n    Similar to import, but imported bindings are not prefixed with a\\n    module identifier. Can also import multiple modules in one shot.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"use","created-at":1593795827},{"example":"(extreme < [1 2 3])  # => 1\u000D\u000A(extreme > [1 2 3])  # => 3\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 677, column 1\\n\\n    (extreme order args)\\n\\n    Returns the most extreme value in args based on the function order.\\n    order should take two values and return true or false (a comparison).\\n    Returns nil if args is empty.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"extreme","created-at":1593744407},{"example":"(distinct [1 1 2 3])  # => @[1 2 3]\u000D\u000A\u000D\u000A(distinct \"hello\")  # => @[104 101 108 111]\u000D\u000A(string/from-bytes (splice (distinct \"hello\")))  # => \"helo\"\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1481, column 1\\n\\n    (distinct xs)\\n\\n    Returns an array of the deduplicated values in xs.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"distinct","created-at":1593744060},{"example":"(chr \"a\")  # => 97","docstring":"\"\\n\\n    macro\\n    boot.janet on line 343, column 1\\n\\n    (chr c)\\n\\n    Convert a string of length 1 to its byte (ascii) value at compile\\n    time.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"chr","created-at":1593743441},{"example":"(string/bytes \"foo\")  # => (102 111 111)\u000D\u000A(string/from-bytes 102 111 111)  # => \"foo\"\u000D\u000A(string/from-bytes (splice (string/bytes \"foo\")))  # => \"foo\"\u000D\u000A\u000D\u000A(map (fn [x] x)        \"foo\")  # => @[102 111 111]\u000D\u000A(map string/from-bytes \"foo\")  # => @[\"f\" \"o\" \"o\"]\u000D\u000A\u000D\u000A(defn string/explode [s] (map string/from-bytes s))\u000D\u000A(string/explode \"foo\")  # => @[\"f\" \"o\" \"o\"]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (string/from-bytes & byte-vals)\\n\\n    Creates a string from integer parameters with byte values. All\\n    integers will be coerced to the range of 1 byte 0-255.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string/from-bytes","created-at":1593743252},{"example":"(filter  even?                     [1 2 3 4 5])  # => @[2 4]\u000D\u000A(filter  odd?                      [1 2 3 4 5])  # => @[1 3 5]\u000D\u000A(filter  (fn [x] (not (even? x)))  [1 2 3 4 5])  # => @[1 3 5]\u000D\u000A(filter  (complement even?)        [1 2 3 4 5])  # => @[1 3 5]\u000D\u000A\u000D\u000A(def fns [even? odd?])\u000D\u000A(map  (fn [f] (filter f [-2 -1 0 1 2]))  fns)  # => @[ @[-2 0 2] @[-1 1]   ]\u000D\u000A(def fns (map complement fns))\u000D\u000A(map  (fn [f] (filter f [-2 -1 0 1 2]))  fns)  # => @[ @[-1 1]   @[-2 0 2] ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 672, column 1\\n\\n    (complement f)\\n\\n    Returns a function that is the complement to the argument.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"complement","created-at":1593741016},{"example":"(count even? [1 2 3 4 5])  # => 2\u000D\u000A\u000D\u000A(count  (fn [x] (> x 3))  [1 2 3 4 5])  # => 2\u000D\u000A(count         |(> $ 3)   [1 2 3 4 5])  # => 2\u000D\u000A\u000D\u000A(count  (fn [x] (truthy? x))  [nil false true 42 :a \"foo\"])  # => 4\u000D\u000A(count         |(truthy? $)   [nil false true 42 :a \"foo\"])  # => 4\u000D\u000A\u000D\u000A(var f even?)\u000D\u000A(count f [1 2 3 4 5])  # => 2\u000D\u000A(set f odd?)\u000D\u000A(count f [1 2 3 4 5])  # => 3\u000D\u000A\u000D\u000A(map  (fn [f] (count f [1 2 3 4 5]))  [even? odd?])  # => @[2 3]\u000D\u000A(map         |(count $ [1 2 3 4 5])   [even? odd?])  # => @[2 3]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 946, column 1\\n\\n    (count pred ind)\\n\\n    Count the number of items in ind for which (pred item) is true.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"count","created-at":1593739967},{"example":"[1 2 3]               # => (1 2 3)\u000D\u000A(tuple/type [1 2 3])  # => :parens\u000D\u000A\u000D\u000A(tuple/brackets 1 2 3)               # => [1 2 3]\u000D\u000A(tuple/type (tuple/brackets 1 2 3))  # => :brackets\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (tuple/type tup)\\n\\n    Checks how the tuple was constructed. Will return the keyword\\n    :brackets if the tuple was parsed with brackets, and :parens\\n    otherwise. The two types of tuples will behave the same most of the\\n    time, but will print differently and be treated differently by the\\n    compiler.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"tuple/type","created-at":1593723063},{"example":"[1 2 3]                  # => (1 2 3)\u000D\u000A(tuple 1 2 3)            # => (1 2 3)\u000D\u000A(tuple (splice [1 2 3])  # => (1 2 3)\u000D\u000A(tuple ;[1 2 3])         # => (1 2 3)\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (tuple & items)\\n\\n    Creates a new tuple that contains items. Returns the new tuple.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"tuple","created-at":1593722474},{"example":"(array 1 2.3 :a \"foo\" true nil [] {} (fn []))\u000D\u000A# => @[1 2.3 :a \"foo\" true nil () {} <function 0x7FB2A3F02170>]","docstring":"\"\\n\\n    cfunction\\n\\n    (array & items)\\n\\n    Create a new array that contains items. Returns the new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array","created-at":1593722142},{"example":"(tuple 1 2.3 :a \"foo\" true nil [] {} (fn []))\u000D\u000A# =>  (1 2.3 :a \"foo\" true nil () {} <function 0x7FB2A3D030B0>)\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (tuple & items)\\n\\n    Creates a new tuple that contains items. Returns the new tuple.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"tuple","created-at":1593722084},{"example":"(tuple/slice [:a :b :c :d])  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(tuple/slice [:a :b :c :d] 0)  # => (:a :b :c :d)\u000D\u000A(tuple/slice [:a :b :c :d] 1)  # => (:b :c :d)\u000D\u000A(tuple/slice [:a :b :c :d] 3)  # => (:d)\u000D\u000A(tuple/slice [:a :b :c :d] 4)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] 5)  # error: index out of range\u000D\u000A\u000D\u000A(tuple/slice [:a :b :c :d] -1)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] -2)  # => (:d)\u000D\u000A(tuple/slice [:a :b :c :d] -4)  # => (:b :c :d)\u000D\u000A(tuple/slice [:a :b :c :d] -5)  # => (:a :b :c :d)\u000D\u000A(tuple/slice [:a :b :c :d] -6)  # error: index out of range\u000D\u000A\u000D\u000A(tuple/slice [:a :b :c :d] 0 0)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] 0 1)  # => (:a)\u000D\u000A(tuple/slice [:a :b :c :d] 0 4)  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(tuple/slice [:a :b :c :d] -1 -1)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] -2 -1)  # => (:d)\u000D\u000A(tuple/slice [:a :b :c :d] -5 -1)  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(tuple/slice [:a :b :c :d] 1 0)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] 4 0)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] -1 -2)  # => ()\u000D\u000A(tuple/slice [:a :b :c :d] -1 -5)  # => ()","docstring":"\"\\n\\n    cfunction\\n\\n    (tuple/slice arrtup [,start=0 [,end=(length arrtup)]])\\n\\n    Take a sub sequence of an array or tuple from index start inclusive\\n    to index end exclusive. If start or end are not provided, they\\n    default to 0 and the length of arrtup respectively. 'start' and 'end'\\n    can also be negative to indicate indexing from the end of the input.\\n    Note that index -1 is synonymous with index '(length arrtup)' to\\n    allow a full negative slice range. Returns the new tuple.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"tuple/slice","created-at":1593721826},{"example":"(slice [:a :b :c :d])  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(slice [:a :b :c :d] 0)  # => (:a :b :c :d)\u000D\u000A(slice [:a :b :c :d] 1)  # => (:b :c :d)\u000D\u000A(slice [:a :b :c :d] 3)  # => (:d)\u000D\u000A(slice [:a :b :c :d] 4)  # => ()\u000D\u000A(slice [:a :b :c :d] 5)  # error: index out of range\u000D\u000A\u000D\u000A(slice [:a :b :c :d] -1)  # => ()\u000D\u000A(slice [:a :b :c :d] -2)  # => (:d)\u000D\u000A(slice [:a :b :c :d] -4)  # => (:b :c :d)\u000D\u000A(slice [:a :b :c :d] -5)  # => (:a :b :c :d)\u000D\u000A(slice [:a :b :c :d] -6)  # error: index out of range\u000D\u000A\u000D\u000A(slice [:a :b :c :d] 0 0)  # => ()\u000D\u000A(slice [:a :b :c :d] 0 1)  # => (:a)\u000D\u000A(slice [:a :b :c :d] 0 4)  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(slice [:a :b :c :d] -1 -1)  # => ()\u000D\u000A(slice [:a :b :c :d] -2 -1)  # => (:d)\u000D\u000A(slice [:a :b :c :d] -5 -1)  # => (:a :b :c :d)\u000D\u000A\u000D\u000A(slice [:a :b :c :d] 1 0)  # => ()\u000D\u000A(slice [:a :b :c :d] 4 0)  # => ()\u000D\u000A(slice [:a :b :c :d] -1 -2)  # => ()\u000D\u000A(slice [:a :b :c :d] -1 -5)  # => ()\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (slice x &opt start end)\\n\\n    Extract a sub-range of an indexed data structure or byte sequence.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"slice","created-at":1593721330},{"example":"(string \"hello\" nil true 42 :bar)  # => \"helloniltrue42bar\"\u000D\u000A(string :a :b :c)  # => \"abc\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (string & xs)\\n\\n    Creates a string by concatenating the elements of `xs` together. If\\n    an element is not a byte sequence, it is converted to bytes via\\n    `describe`. Returns the new string.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string","created-at":1593719381},{"example":"(string? \"hello\")   # => true\u000D\u000A(string? @\"hello\")  # => false\u000D\u000A(string? :hello)    # => false\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 90, column 1\\n\\n    (string? x)\\n\\n    Check if x is a string.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"string?","created-at":1593719302},{"example":"(symbol \"foo\")  # => foo\u000D\u000A\u000D\u000A(def a \"foo\")\u000D\u000A(symbol a)         # => foo\u000D\u000A(symbol a 42 nil)  # => foo42nil\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (symbol & xs)\\n\\n    Creates a symbol by concatenating the elements of `xs` together. If\\n    an element is not a byte sequence, it is converted to bytes via\\n    `describe`. Returns the new symbol.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"symbol","created-at":1593719018},{"example":"(symbol? sum)          # => false\u000D\u000A(symbol? (quote sum))  # => true\u000D\u000A(symbol? 'sum)         # => true\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 91, column 1\\n\\n    (symbol? x)\\n\\n    Check if x is a symbol.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"symbol?","created-at":1593718739},{"example":"(array/slice @[1 2 3] 0 0)  # => @[]\u000D\u000A(array/slice @[1 2 3] 0 1)  # => @[1]\u000D\u000A(array/slice @[1 2 3] 0 2)  # => @[1 2]\u000D\u000A(array/slice @[1 2 3] 0 3)  # => @[1 2 3]\u000D\u000A(array/slice @[1 2 3] 0 4)  # error: index out of range\u000D\u000A\u000D\u000A(array/slice @[1 2 3] 1 1)  # => @[]\u000D\u000A(array/slice @[1 2 3] 1 2)  # => @[2]\u000D\u000A\u000D\u000A(array/slice @[1 2 3] 0 -1)  # => @[1 2 3]\u000D\u000A(array/slice @[1 2 3] 0 -2)  # => @[1 2]\u000D\u000A(array/slice @[1 2 3] 0 -3)  # => @[1]\u000D\u000A(array/slice @[1 2 3] 0 -4)  # => @[]\u000D\u000A(array/slice @[1 2 3] 0 -5)  # error: index out of range\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/slice arrtup &opt start end)\\n\\n    Takes a slice of array or tuple from start to end. The range is half\\n    open, [start, end). Indexes can also be negative, indicating indexing\\n    from the end of the end of the array. By default, start is 0 and end\\n    is the length of the array. Note that index -1 is synonymous with\\n    index (length arrtup) to allow a full negative slice range. Returns a\\n    new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/slice","created-at":1593646470},{"example":"(map indexed?    [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     true      false        false         ]\u000D\u000A\u000D\u000A(map tuple?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  true     false     false        false         ]\u000D\u000A\u000D\u000A(map array?      [ 'ab   :ab   \"ab\"   @\"ab\"  [97 98]  @[97 98]  {0 97 1 98}  @{0 97 1 98}  ])\u000D\u000A# =>            @[ false false false  false  false    true      false        false         ]","docstring":"\"\\n\\n    function\\n    boot.janet on line 99, column 1\\n\\n    (array? x)\\n\\n    Check if x is an array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array?","created-at":1593645898},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(array/remove @[1 2 3] 0)  # => @[2 3]\u000D\u000A(array/remove @[1 2 3] 1)  # => @[1 3]\u000D\u000A(array/remove @[1 2 3] 2)  # => @[1 2]\u000D\u000A(array/remove @[1 2 3] 3)  # => @[1 2 3]\u000D\u000A(array/remove @[1 2 3] 4)  # error: index out of range\u000D\u000A\u000D\u000A(array/remove @[1 2 3] -1)  # => @[1 2 3]\u000D\u000A(array/remove @[1 2 3] -2)  # => @[1 2]\u000D\u000A(array/remove @[1 2 3] -3)  # => @[1 3]\u000D\u000A(array/remove @[1 2 3] -4)  # => @[2 3]\u000D\u000A(array/remove @[1 2 3] -5)  # error: index out of range\u000D\u000A\u000D\u000A(array/remove @[1 2 3 4] 1 1)   # => @[1 3 4]\u000D\u000A(array/remove @[1 2 3 4] 1 2)   # => @[1 4]\u000D\u000A(array/remove @[1 2 3 4] 1 3)   # => @[1]\u000D\u000A(array/remove @[1 2 3 4] 1 4)   # => @[1]\u000D\u000A(array/remove @[1 2 3 4] 1 99)  # => @[1]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/remove arr at &opt n)\\n\\n    Remove up to n elements starting at index at in array arr. at can\\n    index from the end of the array with a negative index, and n must be\\n    a non-negative integer. By default, n is 1. Returns the array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/remove","created-at":1593645607},{"example":"(def a @[])\u000D\u000A(array/push a 1)  # => @[1]\u000D\u000Aa                 # => @[1]\u000D\u000A(array/push a 2)  # => @[1 2]\u000D\u000Aa                 # => @[1 2]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/push arr x)\\n\\n    Insert an element in the end of an array. Modifies the input array\\n    and returns it.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/push","created-at":1593644174},{"example":"(def a @[1 2])\u000D\u000A(array/pop a)  # => 2\u000D\u000Aa              # => @[1]\u000D\u000A(array/pop a)  # => 1\u000D\u000Aa              # => @[]\u000D\u000A(array/pop a)  # => nil\u000D\u000Aa              # => @[]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/pop arr)\\n\\n    Remove the last element of the array and return it. If the array is\\n    empty, will return nil. Modifies the input array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/pop","created-at":1593644073},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(array/peek @[])     # => nil\u000D\u000A(array/peek @[1])    # => 1\u000D\u000A(array/peek @[1 2])  # => 2\u000D\u000A\u000D\u000A(array/peek [1 2])           # error: expected array, got tuple\u000D\u000A(array/peek (array [1 2]))   # => (1 2)\u000D\u000A(array/peek (array ;[1 2]))  # => 2\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/peek arr)\\n\\n    Returns the last element of the array. Does not modify the array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/peek","created-at":1593643949},{"example":"(parse \"[:a :b :c]\") # => [:a :b :c]","docstring":"\"\\n\\n    function\\n    boot.janet on line 2595, column 1\\n\\n    (parse str)\\n\\n    Parse a string and return the first value. For complex parsing, such\\n    as for a repl with error handling, use the parser api.\\n\\n\\n\"","gh-username":"sogaiu","name":"parse","created-at":1593643939},{"example":"# note that 'not' works as an implementation of 'falsey?'\u000D\u000A(map not     [ nil   false true  0     1     'a    :a    \"a\"   []    {}    (fn []) ])\u000D\u000A# =>        @[ true  true  false false false false false false false false false   ]\u000D\u000A\u000D\u000A(map truthy? [ nil   false true  0     1     'a    :a    \"a\"   []    {}    (fn []) ])\u000D\u000A# =>        @[ false false true  true  true  true  true  true  true  true  true    ]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (not x)\\n\\n    Returns the boolean inverse of x.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"not","created-at":1593643547},{"example":"(array/new-filled 3)     # => @[nil nil nil]\u000D\u000A(array/new-filled 3 :a)  # => @[:a :a :a]","docstring":"\"\\n\\n    cfunction\\n\\n    (array/new-filled count &opt value)\\n\\n    Creates a new array of count elements, all set to value, which\\n    defaults to nil. Returns the new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/new-filled","created-at":1593643089},{"example":"(def a @[])\u000D\u000A(array/insert a  1 :a)  # error: index out of range\u000D\u000A(array/insert a -2 :a)  # error: index out of range\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/insert arr at & xs)\\n\\n    Insert all xs into array arr at index at. at should be an integer\\n    between 0 and the length of the array. A negative value for at will\\n    index backwards from the end of the array, such that inserting at -1\\n    appends to the array. Returns the array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/insert","created-at":1593642907},{"example":"(def a @[1 6])                     # => @[1 6]\u000D\u000A(array/insert a 1 (splice [2 3]))  # => @[1 2 3 6]\u000D\u000A(array/insert a 3 ;[4 5])          # => @[1 2 3 4 5 6]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/insert arr at & xs)\\n\\n    Insert all xs into array arr at index at. at should be an integer\\n    between 0 and the length of the array. A negative value for at will\\n    index backwards from the end of the array, such that inserting at -1\\n    appends to the array. Returns the array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/insert","created-at":1593642759},{"example":"(def a @[11 12])              # => @[11 12]\u000D\u000A(array/insert a 0 10)         # => @[10 11 12]\u000D\u000A(array/insert a 3 13)         # => @[10 11 12 13]\u000D\u000A(array/insert a -1 14)        # => @[10 11 12 13 14]\u000D\u000A(array/insert a -1 15 16 17)  # => @[10 11 12 13 14 15 16 17]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/insert arr at & xs)\\n\\n    Insert all xs into array arr at index at. at should be an integer\\n    between 0 and the length of the array. A negative value for at will\\n    index backwards from the end of the array, such that inserting at -1\\n    appends to the array. Returns the array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/insert","created-at":1593642103},{"example":"(def a @[1 2])           # => @[1 2]\u000D\u000A(array/fill a @[3 4 5])  # => @[@[3 4 5] @[3 4 5]]\u000D\u000A(array/concat (0 a) 6)   # => @[3 4 5 6]\u000D\u000Aa                        # => @[@[3 4 5 6] @[3 4 5 6]]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/fill arr &opt value)\\n\\n    Replace all elements of an array with value (defaulting to nil)\\n    without changing the length of the array. Returns the modified array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/fill","created-at":1593641392},{"example":"(def a @[1 2 3])\u000D\u000A(array/fill a 17)   # => @[17 17 17]\u000D\u000A(array/fill a \"n\")  # => @[\"b\" \"b\" \"b\"]\u000D\u000A(array/fill a)      # => @[nil nil nil]\u000D\u000Aa                   # => @[nil nil nil]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/fill arr &opt value)\\n\\n    Replace all elements of an array with value (defaulting to nil)\\n    without changing the length of the array. Returns the modified array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/fill","created-at":1593641042},{"example":"(def a @[1 2])\u000D\u000A(def b @[1 2])\u000D\u000A(= a b)  # => false\u000D\u000A\u000D\u000A(def a @[1 2])\u000D\u000A(def b (array/concat a 3))\u000D\u000Aa        # => @[1 2 3]\u000D\u000Ab        # => @[1 2 3]\u000D\u000A(= a b)  # => true\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (= & xs)\\n\\n    Check if all values in xs are equal. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"=","created-at":1593640605},{"example":"(def a @[1 2])\u000D\u000A(def b @[1 2])\u000D\u000A(= a b)  # => false\u000D\u000A\u000D\u000A(def a @[1 2])\u000D\u000A(def b (array/concat a 3))\u000D\u000Aa        # => @[1 2 3]\u000D\u000Ab        # => @[1 2 3]\u000D\u000A(= a b)  # => true\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/concat arr & parts)\\n\\n    Concatenates a variable number of arrays (and tuples) into the first\\n    argument which must be an array. If any of the parts are arrays or\\n    tuples, their elements will be inserted into the array. Otherwise,\\n    each part in parts will be appended to arr in order. Return the\\n    modified array arr.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/concat","created-at":1593640565},{"example":"(def a @[1 2])\u000D\u000A(array/concat a 3 [4 5] @[6 7] [] @[] 8)\u000D\u000Aa  # => @[1 2 3 4 5 6 7 8]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array/concat arr & parts)\\n\\n    Concatenates a variable number of arrays (and tuples) into the first\\n    argument which must be an array. If any of the parts are arrays or\\n    tuples, their elements will be inserted into the array. Otherwise,\\n    each part in parts will be appended to arr in order. Return the\\n    modified array arr.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array/concat","created-at":1593640280},{"example":"(map truthy? [ nil   false true  0     1     'a    :a    \"a\"   []    {}    (fn []) ])\u000D\u000A# =>        @[ false false true  true  true  true  true  true  true  true  true    ]\u000D\u000A\u000D\u000A# note that 'not' works as an implementation of 'falsey?'\u000D\u000A(map not     [ nil   false true  0     1     'a    :a    \"a\"   []    {}    (fn []) ])\u000D\u000A# =>        @[ true  true  false false false false false false false false false   ]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 111, column 1\\n\\n    (truthy? x)\\n\\n    Check if x is truthy.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"truthy?","created-at":1593639748},{"example":"@[1 2 3]                 # -> @[1 2 3]\u000D\u000A(array 1 2 3)            # -> @[1 2 3]\u000D\u000A(array (splice [1 2 3])  # -> @[1 2 3]\u000D\u000A(array ;[1 2 3])         # -> @[1 2 3]\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (array & items)\\n\\n    Create a new array that contains items. Returns the new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"array","created-at":1593639479},{"example":"(filter (partial string/has-prefix? \"z\") (all-bindings))  # => @[zero? zipcoll]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1766, column 1\\n\\n    (all-bindings &opt env local)\\n\\n    Get all symbols available in an environment. Defaults to the current\\n    fiber's environment. If local is truthy, will not show inherited\\n    bindings (from prototype tables).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"all-bindings","created-at":1593639245},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(all pos? [1 2 3])     # => true\u000D\u000A(all pos? [1 2 3 -4])  # => false\u000D\u000A(all pos? [1 2 3 0])   # => false\u000D\u000A\u000D\u000A(all (partial string/has-prefix? \"a\") [\"aa\" \"ab\"])       # => true\u000D\u000A(all (partial string/has-prefix? \"a\") [\"aa\" \"ab\" \"bb\"])  # => false\u000D\u000A\u000D\u000A(all truthy? [1 2])              # => true\u000D\u000A(all truthy? [1 2 3])            # => true\u000D\u000A(all truthy? [1 2 nil 3])        # => false\u000D\u000A(all truthy? [1 false 2 nil 3])  # => false\u000D\u000A\u000D\u000A(all (fn [x] x) [1 2])              # => 2\u000D\u000A(all (fn [x] x) [1 2 3])            # => 3\u000D\u000A(all (fn [x] x) [1 2 nil 3])        # => nil\u000D\u000A(all (fn [x] x) [1 false 2 nil 3])  # => false\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 2195, column 1\\n\\n    (all pred xs)\\n\\n    Returns true if all xs are truthy, otherwise the result of first\\n    falsey predicate value, (pred x).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"all","created-at":1593638840},{"example":"(reduce2     + [1 2 3])  # -> 6\u000D\u000A(accumulate2 + [1 2 3])  # -> @[1 3 6]","docstring":"\"\\n\\n    function\\n    boot.janet on line 856, column 1\\n\\n    (accumulate2 f ind)\\n\\n    The 2-argument version of accumulate that does not take an\\n    initialization value. The first value in ind will be added to the\\n    array as is, so the length of the return value will be (length ind).\\n\\n\\n\"","gh-username":"cellularmitosis","name":"accumulate2","created-at":1593637830},{"example":"(reduce     + 1 [2 3 4])  # -> 10\u000D\u000A(accumulate + 1 [2 3 4])  # -> @[3 6 10]","docstring":"\"\\n\\n    function\\n    boot.janet on line 844, column 1\\n\\n    (accumulate f init ind)\\n\\n    Similar to reduce, but accumulates intermediate values into an array.\\n    The last element in the array is what would be the return value from\\n    reduce. The init value is not added to the array (the return value\\n    will have the same number of elements as ind). Returns a new array.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"accumulate","created-at":1593637726},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(= :a :a)    # => true\u000D\u000A(= :a \"a\")   # => false\u000D\u000A(= :a \":a\")  # => false\u000D\u000A\u000D\u000A(= \"a\" \"a\")    # => true\u000D\u000A(= \"a\" @\"a\")   # => false\u000D\u000A(= @\"a\" @\"a\")  # => false\u000D\u000A\u000D\u000A(= [1 2] [1 2])    # => true\u000D\u000A(= [1 2] @[1 2])   # => false\u000D\u000A(= @[1 2] @[1 2])  # => false\u000D\u000A\u000D\u000A(= {:a 1} {:a 1})    # => true\u000D\u000A(= {:a 1} @{:a 1})   # => false\u000D\u000A(= @{:a 1} @{:a 1})  # => false\u000D\u000A\u000D\u000A(= (fn []) (fn []))  # => false\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (= & xs)\\n\\n    Check if all values in xs are equal. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"=","created-at":1593634329},{"example":"(= 1 1)  # => true\u000D\u000A(= 1 2)  # => false\u000D\u000A\u000D\u000A(= 1.1 1.1)  # => true\u000D\u000A(= 1.1 1.2)  # => false\u000D\u000A\u000D\u000A(= 1 1.0)  # => true\u000D\u000A\u000D\u000A# these are representations of two different IEEE-754 64-bit buckets:\u000D\u000A(= \u000D\u000A 1.0000000000000001\u000D\u000A 1.0000000000000002)  # => false\u000D\u000A\u000D\u000A# these are two representations of the same IEEE-754 64-bit bucket:\u000D\u000A(= \u000D\u000A 1.00000000000000001\u000D\u000A 1.00000000000000002)  # => true\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (= & xs)\\n\\n    Check if all values in xs are equal. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"=","created-at":1593633612},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A# non-numeric values appear to always be greater than numeric values\u000D\u000A(< math/inf nil)      # -> true\u000D\u000A(< math/inf true)     # -> true\u000D\u000A(< math/inf false)    # -> true\u000D\u000A(< math/inf \"hello\")  # -> true\u000D\u000A(< math/inf :heyo)    # -> true\u000D\u000A(< math/inf (fn []))  # -> true\u000D\u000A(< math/inf {:a 1})   # -> true\u000D\u000A\u000D\u000A# non-numeric values also follow an ordering.\u000D\u000A# rearranging any of these values turns the result false:\u000D\u000A(< nil false true \"a\" \"b\" :a :b [] [1] [1 1] [2] {} {:a 1} (fn []))  # -> true\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (< & xs)\\n\\n    Check if xs is in ascending order. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"<","created-at":1593633243},{"example":"(<)        # -> true\u000D\u000A(< 1)      # -> true\u000D\u000A(< 1 2)    # -> true\u000D\u000A(< 2 1)    # -> false\u000D\u000A(< 1 2 3)  # -> true\u000D\u000A(< 1 3 2)  # -> false\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (< & xs)\\n\\n    Check if xs is in ascending order. Returns a boolean.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"<","created-at":1593632564},{"example":"(defn return-nil [x] nil)\u000D\u000A(-?> 1 inc)                     # -> 2\u000D\u000A(-?> 1 inc inc)                 # -> 3\u000D\u000A(-?> 1 inc inc return-nil)      # -> nil\u000D\u000A(-?> 1 inc inc return-nil inc)  # -> nil\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1147, column 1\\n\\n    (-?> x & forms)\\n\\n    Short circuit threading macro. Inserts x as the second value in the\\n    first form in forms, and inserts the modified first form into the\\n    second form in the same manner, and so on. The pipeline will return\\n    nil if an intermediate value is nil. Useful for expressing pipelines\\n    of data.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"-?>","created-at":1593632409},{"example":"(->  1 (< 2))   # -> true\u000D\u000A(->> 1 (< 2))   # -> false","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1134, column 1\\n\\n    (->> x & forms)\\n\\n    Threading macro. Inserts x as the last value in the first form in\\n    forms, and inserts the modified first form into the second form in\\n    the same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"->>","created-at":1593631838},{"example":"(->  1 (< 2))   # -> true\u000D\u000A(->> 1 (< 2))   # -> false","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1121, column 1\\n\\n    (-> x & forms)\\n\\n    Threading macro. Inserts x as the second value in the first form in\\n    forms, and inserts the modified first form into the second form in\\n    the same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"->","created-at":1593631775},{"example":"(-> 1 (+ 2) (+ 3))  # -> 6","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1121, column 1\\n\\n    (-> x & forms)\\n\\n    Threading macro. Inserts x as the second value in the first form in\\n    forms, and inserts the modified first form into the second form in\\n    the same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"->","created-at":1593631692},{"example":"(defn add17 (partial + 17))\u000D\u000A(add17 3)            # -> 20\u000D\u000A(add17 3 4)          # -> 24\u000D\u000A(map add17 [1 2 3])  # -> @[18 19 20]\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 1274, column 1\\n\\n    (partial f & more)\\n\\n    Partial function application.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"partial","created-at":1593631246},{"example":"(defn inc [x] (+ x 1))\u000D\u000A(defn inv [x] (* x -1))\u000D\u000A(defn sq  [x] (* x x))\u000D\u000A\u000D\u000A(-> 2 inc)             # -> 3\u000D\u000A(-> 2 inc inc)         # -> 4\u000D\u000A(-> 2 inc inc inv)     # -> -4\u000D\u000A(-> 2 inc inc inv sq)  # -> 16\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1121, column 1\\n\\n    (-> x & forms)\\n\\n    Threading macro. Inserts x as the second value in the first form in\\n    forms, and inserts the modified first form into the second form in\\n    the same manner, and so on. Useful for expressing pipelines of data.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"->","created-at":1593630897},{"example":"(* 2 3)      # -> 6\u000D\u000A(* 2 3.3)    # -> 6.6\u000D\u000A(* 2.2 3.3)  # -> 7.26\u000D\u000A\u000D\u000A(def pi 3.14159)\u000D\u000A(* 2 pi)  # -> 6.28318\u000D\u000A\u000D\u000A(* 2)  # -> 2\u000D\u000A(*)    # -> 1\u000D\u000A\u000D\u000A(* 2 3 4)             # -> 24\u000D\u000A(apply * [2 3 4])     # -> 24\u000D\u000A(* (splice [2 3 4]))  # -> 24\u000D\u000A(* ;[2 3 4])          # -> 24\u000D\u000A(def a [2 3 4])\u000D\u000A(* ;a)                # -> 24\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (* & xs)\\n\\n    Returns the product of all elements in xs. If xs is empty, returns 1.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"*","created-at":1593630224},{"example":"# janet 1.10.1\u000D\u000A\u000D\u000A(pos? 1)      # => true\u000D\u000A(pos? 1.618)  # => true\u000D\u000A\u000D\u000A(pos? 0)      # => false\u000D\u000A(pos? -1)     # => false\u000D\u000A\u000D\u000A(def pi 3.14159)\u000D\u000A(pos? pi)       # => true\u000D\u000A\u000D\u000A(pos? nil)      # => true\u000D\u000A(pos? false)    # => true\u000D\u000A(pos? \"hello\")  # => true\u000D\u000A(pos? :heyo)    # => true\u000D\u000A(pos? [-1])     # => true\u000D\u000A(pos? {:a 1})   # => true\u000D\u000A(pos? (fn []))  # => true\u000D\u000A","docstring":"\"\\n\\n    function\\n    boot.janet on line 754, column 1\\n\\n    (pos? x)\\n\\n    Check if x is greater than 0.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"pos?","created-at":1593629576},{"example":"(and true true)   # => true\u000D\u000A(and true false)  # => false\u000D\u000A\u000D\u000A(and true false nil)  # => false\u000D\u000A(and true nil false)  # => nil\u000D\u000A\u000D\u000A(and)       # => true\u000D\u000A(and true)  # => true\u000D\u000A\u000D\u000A(and 1)                  # => 1\u000D\u000A(and 1 \"hello\")          # => \"hello\"\u000D\u000A(and [false] 1 \"world\")  # => \"world\"\u000D\u000A\u000D\u000A# note that `and` does not behave as you might expect\u000D\u000A# when used with `apply` and `splice`:\u000D\u000A(and 1 2 3)                 # => 3\u000D\u000A(and (splice [1 2 3]))      # => (1 2 3)\u000D\u000A(apply and [1 2 3])         # => (if 1 (if 2 3 2) 1)\u000D\u000A(eval (apply and [1 2 3]))  # => 3\u000D\u000A\u000D\u000A# if you need an `and` which you can feed to `apply`,\u000D\u000A# you can use a reduce-based implementation:\u000D\u000A(defn and2 [& xs]\u000D\u000A  (reduce\u000D\u000A    (fn [a b] (if (not a) a b))\u000D\u000A    true xs))\u000D\u000A\u000D\u000A# however, note that `and2` does not implement short-circuiting:\u000D\u000A# janet:23:> (and false (do (print \"hello\") true))\u000D\u000A# false\u000D\u000A# janet:24:> (and2 false (do (print \"hello\") true))\u000D\u000A# hello\u000D\u000A# false\u000D\u000A\u000D\u000A# alternatively, you can use `all` for this case.\u000D\u000A(all truthy?  [true 0 1     'a :a \"a\" [] {}])  # => true\u000D\u000A(all truthy?  [true 0 nil   'a :a \"a\" [] {}])  # => nil\u000D\u000A(all truthy?  [true 0 false 'a :a \"a\" [] {}])  # => false\u000D\u000A(apply (partial all truthy?) [[true 0 1 'a :a \"a\" [] {}]])  # => true\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 258, column 1\\n\\n    (and & forms)\\n\\n    Evaluates to the last argument if all preceding elements are truthy,\\n    otherwise evaluates to the first falsey argument.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"and","created-at":1593627905},{"example":"(apply * [1 2 3])     # -> 6\u000D\u000A(* (splice [1 2 3]))  # -> 6\u000D\u000A(* ;[1 2 3])          # -> 6\u000D\u000A(* 1 2 3)             # -> 6","docstring":"\"\\n\\n    function\\n\\n    (apply f & args)\\n\\n    Applies a function to a variable number of arguments. Each element in\\n    args is used as an argument to f, except the last element in args,\\n    which is expected to be an array-like. Each element in this last\\n    argument is then also pushed as an argument to f. For example:\\n\\n    \\t(apply + 1000 (range 10))\\n\\n    sums the first 10 integers and 1000.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"apply","created-at":1593627335},{"example":"(defn fizzbuzz [n]\u000D\u000A  (cond \u000D\u000A    (and\u000D\u000A      (= 0 (% n 3))\u000D\u000A      (= 0 (% n 5))) \"fizzbuzz\"\u000D\u000A    (= 0 (% n 3)) \"fizz\"\u000D\u000A    (= 0 (% n 5)) \"buzz\"\u000D\u000A    :else n))\u000D\u000A\u000D\u000A(fizzbuzz 1)   # 1\u000D\u000A(fizzbuzz 3)   # \"fizz\"\u000D\u000A(fizzbuzz 5)   # \"buzz\"\u000D\u000A(fizzbuzz 15)  # \"fizzbuzz\"","docstring":"\"\\n\\n    function\\n\\n    (% dividend divisor)\\n\\n    Returns the remainder of dividend / divisor.\\n\\n\\n\"","gh-username":"cellularmitosis","name":"%","created-at":1593620745},{"example":"(freeze @{:a @[1 2] \u000D\u000A          :b @{:x @[8 9] \u000D\u000A               :y :smile}})\u000D\u000A# => {:a (1 2) :b {:x (8 9) :y :smile}}","docstring":"\"\\n\\n    function\\n    boot.janet on line 2232, column 1\\n\\n    (freeze x)\\n\\n    Freeze an object (make it immutable) and do a deep copy, making child\\n    values also immutable. Closures, fibers, and abstract types will not\\n    be recursively frozen, but all other types will.\\n\\n\\n\"","gh-username":"sogaiu","name":"freeze","created-at":1593595309},{"example":"(string/reverse \"hello\") # => \"olleh\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/reverse str)\\n\\n    Returns a string that is the reversed version of str.\\n\\n\\n\"","gh-username":"swlkr","name":"string/reverse","created-at":1593203788},{"example":"(describe :a) # => \":a\"","docstring":"\"\\n\\n    cfunction\\n\\n    (describe x)\\n\\n    Returns a string that is a human-readable description of a value x.\\n\\n\\n\"","gh-username":"sogaiu","name":"describe","created-at":1592981947},{"example":"(put (table) :a 1) # => @{:a 1}\u000D\u000A","docstring":"\"\\n\\n    function\\n\\n    (put ds key value)\\n\\n    Associate a key with a value in any mutable associative data\\n    structure. Indexed data structures (arrays and buffers) only accept\\n    non-negative integer keys, and will expand if an out of bounds value\\n    is provided. In an array, extra space will be filled with nils, and\\n    in a buffer, extra space will be filled with 0 bytes. In a table,\\n    putting a key that is contained in the table prototype will hide the\\n    association defined by the prototype, but will not mutate the\\n    prototype table. Putting a value nil into a table will remove the key\\n    from the table. Returns the data structure ds.\\n\\n\\n\"","gh-username":"sogaiu","name":"put","created-at":1592184591},{"example":"(struct :a 1 :b 2) # => {:a 1 :b 2}","docstring":"\"\\n\\n    cfunction\\n\\n    (struct & kvs)\\n\\n    Create a new struct from a sequence of key value pairs. kvs is a\\n    sequence k1, v1, k2, v2, k3, v3, ... If kvs has an odd number of\\n    elements, an error will be thrown. Returns the new struct.\\n\\n\\n\"","gh-username":"sogaiu","name":"struct","created-at":1592184261},{"example":"(kvs (struct :a 1 :b 2))\u000D\u000A# => @[:a 1 :b 2]","docstring":"\"\\n\\n    function\\n    boot.janet on line 1505, column 1\\n\\n    (kvs dict)\\n\\n    Takes a table or struct and returns and array of key value pairs like\\n    @[k v k v ...]. Returns a new array.\\n\\n\\n\"","gh-username":"sogaiu","name":"kvs","created-at":1592184205},{"example":"(table ;(kvs (struct :a 1 :b 2)))\u000D\u000A# => @{:a 1 :b 2}","docstring":"\"\\n\\n    cfunction\\n\\n    (table & kvs)\\n\\n    Creates a new table from a variadic number of keys and values. kvs is\\n    a sequence k1, v1, k2, v2, k3, v3, ... If kvs has an odd number of\\n    elements, an error will be thrown. Returns the new table.\\n\\n\\n\"","gh-username":"sogaiu","name":"table","created-at":1592184132},{"example":"(table ;[:a 1 :b 2 :c 3])\u000D\u000A# => @{:a 1 :b 2 :c 3}\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (table & kvs)\\n\\n    Creates a new table from a variadic number of keys and values. kvs is\\n    a sequence k1, v1, k2, v2, k3, v3, ... If kvs has an odd number of\\n    elements, an error will be thrown. Returns the new table.\\n\\n\\n\"","gh-username":"sogaiu","name":"table","created-at":1591861586},{"example":"(string/check-set \"0123456789abcdef\" \"deadbeef\") # => true","docstring":"\"\\n\\n    cfunction\\n\\n    (string/check-set set str)\\n\\n    Checks that the string str only contains bytes that appear in the\\n    string set. Returns true if all bytes in str appear in set, false if\\n    some bytes in str do not appear in set.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/check-set","created-at":1590982975},{"example":"(string/split \",\" \"bruce,scott,tiger,woods\")\u000D\u000A# => @[\"bruce\" \"scott\" \"tiger\" \"woods\"]","docstring":"\"\\n\\n    cfunction\\n\\n    (string/split delim str &opt start limit)\\n\\n    Splits a string str with delimiter delim and returns an array of\\n    substrings. The substrings will not contain the delimiter delim. If\\n    delim is not found, the returned array will have one element. Will\\n    start searching for delim at the index start (if provided), and\\n    return up to a maximum of limit results (if provided).\\n\\n\\n\"","gh-username":"sogaiu","name":"string/split","created-at":1590982860},{"example":"(string/find-all \"duck\" \"duck duck duck goose!\") # => @[0 5 10]","docstring":"\"\\n\\n    cfunction\\n\\n    (string/find-all patt str)\\n\\n    Searches for all instances of pattern patt in string str. Returns an\\n    array of all indices of found patterns. Overlapping instances of the\\n    pattern are counted individually, meaning a byte in str may\\n    contribute to multiple found patterns.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/find-all","created-at":1590982389},{"example":"(string/find \"needle\" \"hay hay hay needle hay\") # => 12","docstring":"\"\\n\\n    cfunction\\n\\n    (string/find patt str)\\n\\n    Searches for the first instance of pattern patt in string str.\\n    Returns the index of the first character in patt if found, otherwise\\n    returns nil.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/find","created-at":1590982200},{"example":"(string/has-prefix? \"project.\" \"project.janet\") # => true","docstring":"\"\\n\\n    cfunction\\n\\n    (string/has-prefix? pfx str)\\n\\n    Tests whether str starts with pfx.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/has-prefix?","created-at":1590981654},{"example":"(string/has-suffix? \".janet\" \"code.janet\") # => true","docstring":"\"\\n\\n    cfunction\\n\\n    (string/has-suffix? sfx str)\\n\\n    Tests whether str ends with sfx.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/has-suffix?","created-at":1590981563},{"example":"(string/replace-all \"e\" \"o\" \"feed\") # => \"food\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/replace-all patt subst str)\\n\\n    Replace all instances of patt with subst in the string str.\\n    Overlapping matches will not be counted, only the first match in such\\n    a span will be replaced. Will return the new string if patt is found,\\n    otherwise returns str.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/replace-all","created-at":1590981470},{"example":"(string/replace \"+\" \"-\" \"ctrl+c\") # => \"ctrl-c\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/replace patt subst str)\\n\\n    Replace the first occurrence of patt with subst in the string str.\\n    Will return the new string if patt is found, otherwise returns str.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/replace","created-at":1590981422},{"example":"(string/join @[\"alice\" \"bob\" \"eve\"] \"\\t\") # => \"alice\\tbob\\teve\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/join parts &opt sep)\\n\\n    Joins an array of strings into one string, optionally separated by a\\n    separator string sep.\\n\\n\\n\"","gh-username":"sogaiu","name":"string/join","created-at":1590981019},{"example":"(def request {:params {:id 1}}) # => {:params {:id 1}}\u000D\u000A\u000D\u000A(get-in request [:params :id]) # => 1\u000D\u000A\u000D\u000A(get-in request [:params :name]) # => nil\u000D\u000A\u000D\u000A(get-in request [:params :name] \"N/A\") # => \"N/A\"","docstring":"\"\\n\\n    function\\n    boot.janet on line 1349, column 1\\n\\n    (get-in ds ks &opt dflt)\\n\\n    Access a value in a nested data structure. Looks into the data\\n    structure via a sequence of keys.\\n\\n\\n\"","gh-username":"inchingforward","name":"get-in","created-at":1590337493},{"example":"(def a-tuple-1 [:number 10])\u000D\u000A(def a-tuple-2 [:string \"Hello there!\"])\u000D\u000A(defn show [what]\u000D\u000A  (match what\u000D\u000A    [:number n] (printf \"It's a number! %d\" n)\u000D\u000A    [:string s] (printf \"Here's a string: %s\" s)\u000D\u000A    _ (printf \"I dunno what this is: %q\" what)))\u000D\u000A\u000D\u000A(show a-tuple-1)\u000D\u000A(show a-tuple-2)\u000D\u000A(show [:array @[]])","docstring":"\"\\n\\n    macro\\n    boot.janet on line 1580, column 1\\n\\n    (match x & cases)\\n\\n    Pattern matching. Match an expression `x` against any number of\\n    cases. Each case is a pattern to match against, followed by an\\n    expression to evaluate to if that case is matched. Legal patterns\\n    are:\\n\\n    * symbol -- a pattern that is a symbol will match anything, binding\\n      `x`'s value to that symbol.\\n\\n    * array -- an array will match only if all of its elements match the\\n      corresponding elements in `x`.\\n\\n    * table or struct -- a table or struct will match if all values match\\n      with the corresponding values in `x`.\\n\\n    * tuple -- a tuple pattern will match if its first element matches,\\n      and the following elements are treated as predicates and are true.\\n\\n    * `_` symbol -- the last special case is the `_` symbol, which is a\\n      wildcard that will match any value without creating a binding.\\n\\n    Any other value pattern will only match if it is equal to `x`.\\n\\n\\n\"","gh-username":"roobie","name":"match","created-at":1590253873},{"example":"(loop [x :range [1 10]\u000D\u000A       :let [square (* x x)]\u000D\u000A       :until (> square 9)\u000D\u000A       :before (print \"before\")\u000D\u000A       :after (print \"after\")\u000D\u000A       :repeat 2]\u000D\u000A  (print (string \"square: \" square)))\u000D\u000A\u000D\u000A# before\u000D\u000A# square: 1\u000D\u000A# square: 1\u000D\u000A# after\u000D\u000A# before\u000D\u000A# square: 4\u000D\u000A# square: 4\u000D\u000A# after\u000D\u000A# before\u000D\u000A# square: 9\u000D\u000A# square: 9\u000D\u000A# after\u000D\u000A\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 522, column 1\\n\\n    (loop head & body)\\n\\n    A general purpose loop macro. This macro is similar to the Common\\n    Lisp loop macro, although intentionally much smaller in scope. The\\n    head of the loop should be a tuple that contains a sequence of either\\n    bindings or conditionals. A binding is a sequence of three values\\n    that define something to loop over. They are formatted like:\\n\\n        binding :verb object/expression\\n\\n    Where `binding` is a binding as passed to def, `:verb` is one of a\\n    set of keywords, and `object` is any expression. The available verbs\\n    are:\\n\\n    * :iterate -- repeatedly evaluate and bind to the expression while it\\n      is truthy.\\n\\n    * :range -- loop over a range. The object should be a two-element\\n      tuple with a start and end value, and an optional positive step.\\n      The range is half open, [start, end).\\n\\n    * :range-to -- same as :range, but the range is inclusive [start,\\n      end].\\n\\n    * :down -- loop over a range, stepping downwards. The object should\\n      be a two-element tuple with a start and (exclusive) end value, and\\n      an optional (positive!) step size.\\n\\n    * :down-to -- same as :down, but the range is inclusive [start, end].\\n\\n    * :keys -- iterate over the keys in a data structure.\\n\\n    * :pairs -- iterate over the key-value pairs as tuples in a data\\n      structure.\\n\\n    * :in -- iterate over the values in a data structure or fiber.\\n\\n    `loop` also accepts conditionals to refine the looping further.\\n    Conditionals are of the form:\\n\\n        :modifier argument\\n\\n    where `:modifier` is one of a set of keywords, and `argument` is\\n    keyword-dependent. `:modifier` can be one of:\\n\\n    * `:while expression` - breaks from the loop if `expression` is\\n      falsey.\\n\\n    * `:until expression` - breaks from the loop if `expression` is\\n      truthy.\\n\\n    * `:let bindings` - defines bindings inside the loop as passed to the\\n      `let` macro.\\n\\n    * `:before form` - evaluates a form for a side effect before the next\\n      inner loop.\\n\\n    * `:after form` - same as `:before`, but the side effect happens\\n      after the next inner loop.\\n\\n    * `:repeat n` - repeats the next inner loop `n` times.\\n\\n    * `:when condition` - only evaluates the loop body when condition is\\n      true.\\n\\n    The `loop` macro always evaluates to nil.\\n\\n\\n\"","gh-username":"staab","name":"loop","created-at":1590252293},{"example":"# Suppose you have a fiber that yields chunks of paginated api results:\u000D\u000A(def api-results (fiber/new (fn [] (yield [1 2 3]) (yield [4 5 6]))))\u000D\u000A\u000D\u000A# Using :iterate, the right side of the binding is evaluated each time the loop is run,\u000D\u000A# which allows for running a side-effecting expression that may be different each time.\u000D\u000A(loop [_ :iterate (fiber/can-resume? api-results)] (pp (resume api-results)))\u000D\u000A\u000D\u000A# This example can be simplified using :generate\u000D\u000A(loop [chunk :generate api-results] (pp chunk))\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 522, column 1\\n\\n    (loop head & body)\\n\\n    A general purpose loop macro. This macro is similar to the Common\\n    Lisp loop macro, although intentionally much smaller in scope. The\\n    head of the loop should be a tuple that contains a sequence of either\\n    bindings or conditionals. A binding is a sequence of three values\\n    that define something to loop over. They are formatted like:\\n\\n        binding :verb object/expression\\n\\n    Where `binding` is a binding as passed to def, `:verb` is one of a\\n    set of keywords, and `object` is any expression. The available verbs\\n    are:\\n\\n    * :iterate -- repeatedly evaluate and bind to the expression while it\\n      is truthy.\\n\\n    * :range -- loop over a range. The object should be a two-element\\n      tuple with a start and end value, and an optional positive step.\\n      The range is half open, [start, end).\\n\\n    * :range-to -- same as :range, but the range is inclusive [start,\\n      end].\\n\\n    * :down -- loop over a range, stepping downwards. The object should\\n      be a two-element tuple with a start and (exclusive) end value, and\\n      an optional (positive!) step size.\\n\\n    * :down-to -- same as :down, but the range is inclusive [start, end].\\n\\n    * :keys -- iterate over the keys in a data structure.\\n\\n    * :pairs -- iterate over the key-value pairs as tuples in a data\\n      structure.\\n\\n    * :in -- iterate over the values in a data structure or fiber.\\n\\n    `loop` also accepts conditionals to refine the looping further.\\n    Conditionals are of the form:\\n\\n        :modifier argument\\n\\n    where `:modifier` is one of a set of keywords, and `argument` is\\n    keyword-dependent. `:modifier` can be one of:\\n\\n    * `:while expression` - breaks from the loop if `expression` is\\n      falsey.\\n\\n    * `:until expression` - breaks from the loop if `expression` is\\n      truthy.\\n\\n    * `:let bindings` - defines bindings inside the loop as passed to the\\n      `let` macro.\\n\\n    * `:before form` - evaluates a form for a side effect before the next\\n      inner loop.\\n\\n    * `:after form` - same as `:before`, but the side effect happens\\n      after the next inner loop.\\n\\n    * `:repeat n` - repeats the next inner loop `n` times.\\n\\n    * `:when condition` - only evaluates the loop body when condition is\\n      true.\\n\\n    The `loop` macro always evaluates to nil.\\n\\n\\n\"","gh-username":"staab","name":"loop","created-at":1590210711},{"example":"(peg/match ~{:main (capture (some :S))}\u000D\u000A           \"hello world\")              # => @[\"hello\"]","docstring":"\"\\n\\n    cfunction\\n\\n    (peg/match peg text &opt start & args)\\n\\n    Match a Parsing Expression Grammar to a byte string and return an\\n    array of captured values. Returns nil if text does not match the\\n    language defined by peg. The syntax of PEGs is documented on the\\n    Janet website.\\n\\n\\n\"","gh-username":"sogaiu","name":"peg/match","created-at":1590207813},{"example":"(def h [\"a\" \"b\" :c]) # => (\"a\" \"b\" :c)\u000D\u000A\u000D\u000A(find (fn [a] (= \"a\" a)) h) # => \"a\"","docstring":"\"\\n\\n    function\\n    boot.janet on line 1006, column 1\\n\\n    (find pred ind &opt dflt)\\n\\n    Find the first value in an indexed collection that satisfies a\\n    predicate. Returns dflt if not found.\\n\\n\\n\"","gh-username":"faywong","name":"find","created-at":1590197194},{"example":"(odd? 2) # => false\u000D\u000A(odd? nil) # throws an error\u000D\u000A(odd? 1) # => true\u000D\u000A(odd? \"a\") # => throws an error","docstring":"\"\\n\\n    function\\n    boot.janet on line 758, column 1\\n\\n    (odd? x)\\n\\n    Check if x is odd.\\n\\n\\n\"","gh-username":"swlkr","name":"odd?","created-at":1590111804},{"example":"(string/bytes \"hello\") # => (104 101 108 108 111)","docstring":"\"\\n\\n    cfunction\\n\\n    (string/bytes str)\\n\\n    Returns an array of integers that are the byte values of the string.\\n\\n\\n\"","gh-username":"swlkr","name":"string/bytes","created-at":1590100275},{"example":"# There is a list of formatters here: https://janet-lang.org/capi/writing-c-functions.html\u000D\u000A\u000D\u000A\u000D\u000A(string/format \"With terminal colors: %M\" [:array {:key-in \"struct\"}]) # => \"With terminal colors: (\\e[33m:array\\e[0m {\\e[33m:key-in\\e[0m \\e[35m\\\"struct\\\"\\e[0m})\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (string/format format & values)\\n\\n    Similar to snprintf, but specialized for operating with Janet values.\\n    Returns a new string.\\n\\n\\n\"","gh-username":"roobie","name":"string/format","created-at":1590093029},{"example":"(map |(+ $0 $1) [1 2 3] [4 5 6]) # @[5 7 9] - uses the fn shorthand","docstring":"\"\\n\\n    function\\n    boot.janet on line 873, column 1\\n\\n    (map f & inds)\\n\\n    Map a function over every value in a data structure and return an\\n    array of the results.\\n\\n\\n\"","gh-username":"ahungry","name":"map","created-at":1590038055},{"example":"## Quadratic Formula\u000D\u000A\u000D\u000A(defn qform\u000D\u000A  \"Use the quadratic formula to solve for x. Returns all real solutions.\"\u000D\u000A  [a b c]\u000D\u000A  (def det (- (* b b) (* 4 a c)))\u000D\u000A  (def factor (/ 0.5 a))\u000D\u000A  (cond\u000D\u000A    (neg? det) []\u000D\u000A    (zero? det) [(* factor (- b))]\u000D\u000A    (let [root-det (math/sqrt det)]\u000D\u000A        [(* factor (- (- b) root-det)) (* factor (+ (- b) root-det))])))\u000D\u000A\u000D\u000A    (qform 1 4 3) # -> (-3 -1)\u000D\u000A","docstring":"\"\\n\\n    macro\\n    boot.janet on line 12, column 1\\n\\n    (defn name & more)\\n\\n    Define a function. Equivalent to (def name (fn name [args] ...)).\\n\\n\\n\"","gh-username":"bakpakin","name":"defn","created-at":1590032837},{"example":"(map string/from-bytes \"Hello, world!\")  # => @[\"H\" \"e\" \"l\" \"l\" \"o\" \",\" \" \" \"w\" \"o\" \"r\" \"l\" \"d\" \"!\"]","docstring":"\"\\n\\n    function\\n    boot.janet on line 873, column 1\\n\\n    (map f & inds)\\n\\n    Map a function over every value in a data structure and return an\\n    array of the results.\\n\\n\\n\"","gh-username":"GrayJack","name":"map","created-at":1590021354},{"example":"(os/getenv \"TERM\") # => \"xterm-256color\"","docstring":"\"\\n\\n    cfunction\\n\\n    (os/getenv variable &opt dflt)\\n\\n    Get the string value of an environment variable.\\n\\n\\n\"","gh-username":"sogaiu","name":"os/getenv","created-at":1590018185},{"example":"janet:2:> (all true? [true true false])\u000D\u000Afalse\u000D\u000Ajanet:3:> (all even? [2 4 6 7])\u000D\u000Afalse\u000D\u000Ajanet:5:> (all even? [2 4 6])\u000D\u000Atrue","docstring":"\"\\n\\n    function\\n    boot.janet on line 2195, column 1\\n\\n    (all pred xs)\\n\\n    Returns true if all xs are truthy, otherwise the result of first\\n    falsey predicate value, (pred x).\\n\\n\\n\"","gh-username":"swlkr","name":"all","created-at":1590006608},{"example":"(string/ascii-lower \"HELLO\") #=> \"hello\"","docstring":"\"\\n\\n    cfunction\\n\\n    (string/ascii-lower str)\\n\\n    Returns a new string where all bytes are replaced with the lowercase\\n    version of themselves in ASCII. Does only a very simple case check,\\n    meaning no unicode support.\\n\\n\\n\"","gh-username":"swlkr","name":"string/ascii-lower","created-at":1590006451},{"example":"Example usage\u000D\u000A\u000D\u000A\u000D\u000Ajanet:1:> (def buf @\"ABCDE\")\u000D\u000A@\"ABCDE\"\u000D\u000Ajanet:2:> (buffer/slice 0)\u000D\u000Aerror: bad slot #0, expected string|symbol|keyword|buffer, got 0\u000D\u000A  in buffer/slice\u000D\u000A  in _thunk [repl] (tailcall) on line 2, column 1\u000D\u000Ajanet:3:> (buffer/slice buf 0)\u000D\u000A@\"ABCDE\"\u000D\u000Ajanet:4:> (buffer/slice buf 0 1)\u000D\u000A@\"A\"\u000D\u000Ajanet:5:> (buffer/slice buf 0 -1)\u000D\u000A@\"ABCDE\"\u000D\u000Ajanet:6:> (buffer/slice buf 1 3)\u000D\u000A@\"BC\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (buffer/slice bytes &opt start end)\\n\\n    Takes a slice of a byte sequence from start to end. The range is half\\n    open, [start, end). Indexes can also be negative, indicating indexing\\n    from the end of the end of the array. By default, start is 0 and end\\n    is the length of the buffer. Returns a new buffer.\\n\\n\\n\"","gh-username":"roobie","name":"buffer/slice","created-at":1589999785},{"example":"(scan-number \"123\") # => 123\u000D\u000A(scan-number \"f\") # => nil\u000D\u000A\u000D\u000A(scan-number 123) # =>\u000D\u000A# error: bad slot #0, expected string|symbol|keyword|buffer, got 123\u000D\u000A#   in scan-number\u000D\u000A#   in _thunk [repl] (tailcall) on line 1, column 1","docstring":"\"\\n\\n    cfunction\\n\\n    (scan-number str)\\n\\n    Parse a number from a byte sequence an return that number, either and\\n    integer or a real. The number must be in the same format as numbers\\n    in janet source code. Will return nil on an invalid number.\\n\\n\\n\"","gh-username":"swlkr","name":"scan-number","created-at":1589997888},{"example":"(string \"hello \" \"world\") # => \"hello world\"\u000D\u000A","docstring":"\"\\n\\n    cfunction\\n\\n    (string & xs)\\n\\n    Creates a string by concatenating the elements of `xs` together. If\\n    an element is not a byte sequence, it is converted to bytes via\\n    `describe`. Returns the new string.\\n\\n\\n\"","gh-username":"swlkr","name":"string","created-at":1589997117},{"example":"You can see janet datastructure values by typing:\u000D\u000A\u000D\u000A(string/format \"%q\" {:a 1 :b 2}) # => {:a 1 :b 2} ","docstring":"\"\\n\\n    cfunction\\n\\n    (string/format format & values)\\n\\n    Similar to snprintf, but specialized for operating with Janet values.\\n    Returns a new string.\\n\\n\\n\"","gh-username":"swlkr","name":"string/format","created-at":1589995467}]